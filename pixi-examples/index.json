{
  "metadata": {
    "generatedAt": "2025-11-12T23:31:15.627Z",
    "source": "pixi-examples/public/examples",
    "totalCategories": 25,
    "totalExamples": 131,
    "successfulExamples": 131
  },
  "readme": "> **Warning**\n> This repository is no longer maintained. Examples have been moved into the [main website's repository](https://github.com/pixijs/pixijs.com/tree/main/src/data/examples) and is deployed to [pixijs.com/examples](https://pixijs.com/examples).\n\n# PixiJS Examples Guidelines\n\nThis is the repository for examples using latest version of PixiJS.\n\nThe `iframe` that displays the examples is **800 * 600**, consequently please avoid creating a renderer that is larger than these dimensions.\n\n## Running\n\nThis micro-site is built using HTML and jQuery and can be run on your local server without additional requirements.\n\nIf you change the site code within `src/main.js` or any styling within `src/main.less` you will need to rebuild the project.\nAfter installing dependencies via `npm i`, you can perform a one off projection build via `npm run watch`, or you can start a watch process for development via `npm run watch`.\n\n## Project Structure\n\nAll the examples are stored in the `public/examples/js` folder and loaded via the `public/examples/manifest.json` file.\n\nAll the assets are stored in `public/examples/assets`.\n\nEvery sub-folder in the examples folder corresponds to a sub-menu in the website's sidebar.\n\n## Creating an Example\n\nYou can use the basic example as a template, it is located in [`public/examples/js/demos-basic/container.js`](public/examples/js/demos-basic/container.js).\nAll you need to do is copy and paste this file to where you think your example belongs within the `examples/js` folder structure, and change the contents to make a new example. You will then also need to update the `public/examples/manifest.json` to allow the menu to point to your new example.\n",
  "categories": [
    {
      "id": "demos-basic",
      "title": "Basic",
      "examples": [
        {
          "title": "Container",
          "entry": "container.js",
          "path": "demos-basic/container.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nconst container = new PIXI.Container();\n\napp.stage.addChild(container);\n\n// Create a new texture\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\n\n// Create a 5x5 grid of bunnies\nfor (let i = 0; i < 25; i++) {\n    const bunny = new PIXI.Sprite(texture);\n    bunny.anchor.set(0.5);\n    bunny.x = (i % 5) * 40;\n    bunny.y = Math.floor(i / 5) * 40;\n    container.addChild(bunny);\n}\n\n// Move container to the center\ncontainer.x = app.screen.width / 2;\ncontainer.y = app.screen.height / 2;\n\n// Center bunny sprite in local container coordinates\ncontainer.pivot.x = container.width / 2;\ncontainer.pivot.y = container.height / 2;\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // rotate the container!\n    // use delta to create frame-independent transform\n    container.rotation -= 0.01 * delta;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Transparent Background",
          "entry": "transparent-background.js",
          "path": "demos-basic/transparent-background.js",
          "code": "const app = new PIXI.Application({ backgroundAlpha: 0 });\ndocument.body.appendChild(app.view);\n\n// create a new Sprite from an image path.\nconst bunny = PIXI.Sprite.from('examples/assets/bunny.png');\n\n// center the sprite's anchor point\nbunny.anchor.set(0.5);\n\n// move the sprite to the center of the screen\nbunny.x = app.screen.width / 2;\nbunny.y = app.screen.height / 2;\n\napp.stage.addChild(bunny);\n\napp.ticker.add(() => {\n    // just for fun, let's rotate mr rabbit a little\n    bunny.rotation += 0.1;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Tinting",
          "entry": "tinting.js",
          "path": "demos-basic/tinting.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// holder to store the aliens\nconst aliens = [];\n\nconst totalDudes = 20;\n\nfor (let i = 0; i < totalDudes; i++) {\n    // create a new Sprite that uses the image name that we just generated as its source\n    const dude = PIXI.Sprite.from('examples/assets/eggHead.png');\n\n    // set the anchor point so the texture is centered on the sprite\n    dude.anchor.set(0.5);\n\n    // set a random scale for the dude - no point them all being the same size!\n    dude.scale.set(0.8 + Math.random() * 0.3);\n\n    // finally lets set the dude to be at a random position..\n    dude.x = Math.random() * app.screen.width;\n    dude.y = Math.random() * app.screen.height;\n\n    dude.tint = Math.random() * 0xFFFFFF;\n\n    // create some extra properties that will control movement :\n    // create a random direction in radians. This is a number between 0 and PI*2 which is the equivalent of 0 - 360 degrees\n    dude.direction = Math.random() * Math.PI * 2;\n\n    // this number will be used to modify the direction of the dude over time\n    dude.turningSpeed = Math.random() - 0.8;\n\n    // create a random speed for the dude between 2 - 4\n    dude.speed = 2 + Math.random() * 2;\n\n    // finally we push the dude into the aliens array so it it can be easily accessed later\n    aliens.push(dude);\n\n    app.stage.addChild(dude);\n}\n\n// create a bounding box for the little dudes\nconst dudeBoundsPadding = 100;\nconst dudeBounds = new PIXI.Rectangle(-dudeBoundsPadding,\n    -dudeBoundsPadding,\n    app.screen.width + dudeBoundsPadding * 2,\n    app.screen.height + dudeBoundsPadding * 2);\n\napp.ticker.add(() => {\n    // iterate through the dudes and update their position\n    for (let i = 0; i < aliens.length; i++) {\n        const dude = aliens[i];\n        dude.direction += dude.turningSpeed * 0.01;\n        dude.x += Math.sin(dude.direction) * dude.speed;\n        dude.y += Math.cos(dude.direction) * dude.speed;\n        dude.rotation = -dude.direction - Math.PI / 2;\n\n        // wrap the dudes by testing their bounds...\n        if (dude.x < dudeBounds.x) {\n            dude.x += dudeBounds.width;\n        } else if (dude.x > dudeBounds.x + dudeBounds.width) {\n            dude.x -= dudeBounds.width;\n        }\n\n        if (dude.y < dudeBounds.y) {\n            dude.y += dudeBounds.height;\n        } else if (dude.y > dudeBounds.y + dudeBounds.height) {\n            dude.y -= dudeBounds.height;\n        }\n    }\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "CacheAsBitmap",
          "entry": "cacheAsBitmap.js",
          "path": "demos-basic/cacheAsBitmap.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\napp.stop();\n\n// load resources\nPIXI.Assets.load('examples/assets/spritesheet/monsters.json')\n    .then(onAssetsLoaded);\n\n// holder to store aliens\nconst aliens = [];\nconst alienFrames = [\n    'eggHead.png',\n    'flowerTop.png',\n    'helmlok.png',\n    'skully.png',\n];\n\nlet count = 0;\n\n// create an empty container\nconst alienContainer = new PIXI.Container();\nalienContainer.x = 400;\nalienContainer.y = 300;\n\n// make the stage interactive\napp.stage.interactive = true;\napp.stage.addChild(alienContainer);\n\nfunction onAssetsLoaded() {\n    // add a bunch of aliens with textures from image paths\n    for (let i = 0; i < 100; i++) {\n        const frameName = alienFrames[i % 4];\n\n        // create an alien using the frame name..\n        const alien = PIXI.Sprite.from(frameName);\n        alien.tint = Math.random() * 0xFFFFFF;\n\n        alien.x = Math.random() * 800 - 400;\n        alien.y = Math.random() * 600 - 300;\n        alien.anchor.x = 0.5;\n        alien.anchor.y = 0.5;\n        aliens.push(alien);\n        alienContainer.addChild(alien);\n    }\n    app.start();\n}\n\n// Combines both mouse click + touch tap\napp.stage.on('pointertap', onClick);\n\nfunction onClick() {\n    alienContainer.cacheAsBitmap = !alienContainer.cacheAsBitmap;\n}\n\napp.ticker.add(() => {\n    // let's rotate the aliens a little bit\n    for (let i = 0; i < 100; i++) {\n        const alien = aliens[i];\n        alien.rotation += 0.1;\n    }\n\n    count += 0.01;\n\n    alienContainer.scale.x = Math.sin(count);\n    alienContainer.scale.y = Math.sin(count);\n    alienContainer.rotation += 0.01;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Particle Container",
          "entry": "particle-container.js",
          "path": "demos-basic/particle-container.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst sprites = new PIXI.ParticleContainer(10000, {\n    scale: true,\n    position: true,\n    rotation: true,\n    uvs: true,\n    alpha: true,\n});\napp.stage.addChild(sprites);\n\n// create an array to store all the sprites\nconst maggots = [];\n\nconst totalSprites = app.renderer instanceof PIXI.Renderer ? 10000 : 100;\n\nfor (let i = 0; i < totalSprites; i++) {\n    // create a new Sprite\n    const dude = PIXI.Sprite.from('examples/assets/maggot_tiny.png');\n\n    // set the anchor point so the texture is centerd on the sprite\n    dude.anchor.set(0.5);\n\n    // different maggots, different sizes\n    dude.scale.set(0.8 + Math.random() * 0.3);\n\n    // scatter them all\n    dude.x = Math.random() * app.screen.width;\n    dude.y = Math.random() * app.screen.height;\n\n    dude.tint = Math.random() * 0x808080;\n\n    // create a random direction in radians\n    dude.direction = Math.random() * Math.PI * 2;\n\n    // this number will be used to modify the direction of the sprite over time\n    dude.turningSpeed = Math.random() - 0.8;\n\n    // create a random speed between 0 - 2, and these maggots are slooww\n    dude.speed = (2 + Math.random() * 2) * 0.2;\n\n    dude.offset = Math.random() * 100;\n\n    // finally we push the dude into the maggots array so it it can be easily accessed later\n    maggots.push(dude);\n\n    sprites.addChild(dude);\n}\n\n// create a bounding box box for the little maggots\nconst dudeBoundsPadding = 100;\nconst dudeBounds = new PIXI.Rectangle(\n    -dudeBoundsPadding,\n    -dudeBoundsPadding,\n    app.screen.width + dudeBoundsPadding * 2,\n    app.screen.height + dudeBoundsPadding * 2,\n);\n\nlet tick = 0;\n\napp.ticker.add(() => {\n    // iterate through the sprites and update their position\n    for (let i = 0; i < maggots.length; i++) {\n        const dude = maggots[i];\n        dude.scale.y = 0.95 + Math.sin(tick + dude.offset) * 0.05;\n        dude.direction += dude.turningSpeed * 0.01;\n        dude.x += Math.sin(dude.direction) * (dude.speed * dude.scale.y);\n        dude.y += Math.cos(dude.direction) * (dude.speed * dude.scale.y);\n        dude.rotation = -dude.direction + Math.PI;\n\n        // wrap the maggots\n        if (dude.x < dudeBounds.x) {\n            dude.x += dudeBounds.width;\n        } else if (dude.x > dudeBounds.x + dudeBounds.width) {\n            dude.x -= dudeBounds.width;\n        }\n\n        if (dude.y < dudeBounds.y) {\n            dude.y += dudeBounds.height;\n        } else if (dude.y > dudeBounds.y + dudeBounds.height) {\n            dude.y -= dudeBounds.height;\n        }\n    }\n\n    // increment the ticker\n    tick += 0.1;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "BlendModes",
          "entry": "blendmodes.js",
          "path": "demos-basic/blendmodes.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// create a new background sprite\nconst background = PIXI.Sprite.from('examples/assets/bg_rotate.jpg');\nbackground.width = app.screen.width;\nbackground.height = app.screen.height;\napp.stage.addChild(background);\n\n// create an array to store a reference to the dudes\nconst dudeArray = [];\n\nconst totaldudes = 20;\n\nfor (let i = 0; i < totaldudes; i++) {\n    // create a new Sprite that uses the image name that we just generated as its source\n    const dude = PIXI.Sprite.from('examples/assets/flowerTop.png');\n\n    dude.anchor.set(0.5);\n\n    // set a random scale for the dude\n    dude.scale.set(0.8 + Math.random() * 0.3);\n\n    // finally let's set the dude to be at a random position...\n    dude.x = Math.floor(Math.random() * app.screen.width);\n    dude.y = Math.floor(Math.random() * app.screen.height);\n\n    // The important bit of this example, this is how you change the default blend mode of the sprite\n    dude.blendMode = PIXI.BLEND_MODES.ADD;\n\n    // create some extra properties that will control movement\n    dude.direction = Math.random() * Math.PI * 2;\n\n    // this number will be used to modify the direction of the dude over time\n    dude.turningSpeed = Math.random() - 0.8;\n\n    // create a random speed for the dude between 0 - 2\n    dude.speed = 2 + Math.random() * 2;\n\n    // finally we push the dude into the dudeArray so it it can be easily accessed later\n    dudeArray.push(dude);\n\n    app.stage.addChild(dude);\n}\n\n// create a bounding box for the little dudes\nconst dudeBoundsPadding = 100;\n\nconst dudeBounds = new PIXI.Rectangle(\n    -dudeBoundsPadding,\n    -dudeBoundsPadding,\n    app.screen.width + dudeBoundsPadding * 2,\n    app.screen.height + dudeBoundsPadding * 2,\n);\n\napp.ticker.add(() => {\n    // iterate through the dudes and update the positions\n    for (let i = 0; i < dudeArray.length; i++) {\n        const dude = dudeArray[i];\n        dude.direction += dude.turningSpeed * 0.01;\n        dude.x += Math.sin(dude.direction) * dude.speed;\n        dude.y += Math.cos(dude.direction) * dude.speed;\n        dude.rotation = -dude.direction - Math.PI / 2;\n\n        // wrap the dudes by testing their bounds...\n        if (dude.x < dudeBounds.x) {\n            dude.x += dudeBounds.width;\n        } else if (dude.x > dudeBounds.x + dudeBounds.width) {\n            dude.x -= dudeBounds.width;\n        }\n\n        if (dude.y < dudeBounds.y) {\n            dude.y += dudeBounds.height;\n        } else if (dude.y > dudeBounds.y + dudeBounds.height) {\n            dude.y -= dudeBounds.height;\n        }\n    }\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "SimplePlane",
          "entry": "simpleplane.js",
          "path": "demos-basic/simpleplane.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('examples/assets/bg_grass.jpg').then((texture) => {\n    const plane = new PIXI.SimplePlane(texture, 10, 10);\n\n    plane.x = 100;\n    plane.y = 100;\n\n    app.stage.addChild(plane);\n\n    // Get the buffer for vertice positions.\n    const buffer = plane.geometry.getBuffer('aVertexPosition');\n\n    // Listen for animate update\n    let timer = 0;\n    app.ticker.add(() => {\n        // Randomize the vertice positions a bit to create movement.\n        for (let i = 0; i < buffer.data.length; i++) {\n            buffer.data[i] += Math.sin((timer / 10) + i) * 0.5;\n        }\n        buffer.update();\n        timer++;\n    });\n});\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "sprite",
      "title": "Sprite",
      "examples": [
        {
          "title": "Basic",
          "entry": "basic.js",
          "path": "sprite/basic.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// create a new Sprite from an image path\nconst bunny = PIXI.Sprite.from('examples/assets/bunny.png');\n\n// center the sprite's anchor point\nbunny.anchor.set(0.5);\n\n// move the sprite to the center of the screen\nbunny.x = app.screen.width / 2;\nbunny.y = app.screen.height / 2;\n\napp.stage.addChild(bunny);\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // just for fun, let's rotate mr rabbit a little\n    // delta is 1 if running at 100% performance\n    // creates frame-independent transformation\n    bunny.rotation += 0.1 * delta;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Z-Index",
          "entry": "z-index.js",
          "path": "sprite/z-index.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// lets add our container\nconst container = new PIXI.Container();\n\n\n// allows for container's children to have a z-Index\n// this is very important, without sortable children, Sprite.zIndex doesnt work!\ncontainer.sortableChildren = true;\napp.stage.addChild(container);\n\n\n// Initiating our monsters/sprites\nconst blue = PIXI.Sprite.from('examples/assets/helmlok.png');\nconst green = PIXI.Sprite.from('examples/assets/flowerTop.png');\nconst pink = PIXI.Sprite.from('examples/assets/eggHead.png');\nconst skully = PIXI.Sprite.from('examples/assets/skully.png');\n\n// looping our sprites to put them in position\nconst monsters = [blue, green, pink, skully];\nmonsters.forEach((sprite, index) => {\n    sprite.anchor.set(0.5);\n    sprite.x = 250 + 50 * index + 1;\n    sprite.y = 250 + 50 * index + 1;\n\n    // allow for our sprites to be interactive (have events such as on mounse over)\n    sprite.interactive = true;\n\n    // when the mouse in on top of them, increase their z index\n    // so they come on top of other sprites\n    sprite.on('pointerover', () => {\n        this.isOver = true;\n        if (this.isdown) {\n            return;\n        }\n        sprite.zIndex = 10;\n        console.log(sprite.zIndex);\n    });\n\n    // when the mouse leaves them, reduce their z-index\n    // so they go back to their original position\n    sprite.on('pointerout', () => {\n        this.isOver = false;\n        if (this.isdown) {\n            return;\n        }\n        sprite.zIndex = 0;\n    });\n    container.addChild(sprite);\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Texture Swap",
          "entry": "texture-swap.js",
          "path": "sprite/texture-swap.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nlet isFlower = true;\n\nconst texture = PIXI.Texture.from('examples/assets/flowerTop.png');\nconst secondTexture = PIXI.Texture.from('examples/assets/eggHead.png');\n\n// create a new Sprite using the texture\nconst character = new PIXI.Sprite(texture);\n\n// center the sprites anchor point\ncharacter.anchor.set(0.5);\n\n// move the sprite to the center of the screen\ncharacter.x = app.screen.width / 2;\ncharacter.y = app.screen.height / 2;\n\napp.stage.addChild(character);\n\n// make the sprite interactive\ncharacter.interactive = true;\ncharacter.cursor = 'pointer';\n\ncharacter.on('pointertap', () => {\n    isFlower = !isFlower;\n    // Dynamically swap the texture\n    character.texture = isFlower ? texture : secondTexture;\n});\n\napp.ticker.add(() => {\n    character.rotation += 0.02;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Animated Sprite - Explosion",
          "entry": "animatedsprite-explosion.js",
          "path": "sprite/animatedsprite-explosion.js",
          "code": "const app = new PIXI.Application({ autoStart: false });\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('examples/assets/spritesheet/mc.json').then(() => {\n    // create an array to store the textures\n    const explosionTextures = [];\n    let i;\n\n    for (i = 0; i < 26; i++) {\n        const texture = PIXI.Texture.from(`Explosion_Sequence_A ${i + 1}.png`);\n        explosionTextures.push(texture);\n    }\n\n    for (i = 0; i < 50; i++) {\n        // create an explosion AnimatedSprite\n        const explosion = new PIXI.AnimatedSprite(explosionTextures);\n\n        explosion.x = Math.random() * app.screen.width;\n        explosion.y = Math.random() * app.screen.height;\n        explosion.anchor.set(0.5);\n        explosion.rotation = Math.random() * Math.PI;\n        explosion.scale.set(0.75 + Math.random() * 0.5);\n        explosion.gotoAndPlay(Math.random() * 26 | 0);\n        app.stage.addChild(explosion);\n    }\n\n    // start animating\n    app.start();\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Animated Sprite - Jet",
          "entry": "animatedsprite-jet.js",
          "path": "sprite/animatedsprite-jet.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('examples/assets/spritesheet/fighter.json').then(() => {\n    // create an array of textures from an image path\n    const frames = [];\n\n    for (let i = 0; i < 30; i++) {\n        const val = i < 10 ? `0${i}` : i;\n\n        // magically works since the spritesheet was loaded with the pixi loader\n        frames.push(PIXI.Texture.from(`rollSequence00${val}.png`));\n    }\n\n    // create an AnimatedSprite (brings back memories from the days of Flash, right ?)\n    const anim = new PIXI.AnimatedSprite(frames);\n\n    /*\n     * An AnimatedSprite inherits all the properties of a PIXI sprite\n     * so you can change its position, its anchor, mask it, etc\n     */\n    anim.x = app.screen.width / 2;\n    anim.y = app.screen.height / 2;\n    anim.anchor.set(0.5);\n    anim.animationSpeed = 0.5;\n    anim.play();\n\n    app.stage.addChild(anim);\n\n    // Animate the rotation\n    app.ticker.add(() => {\n        anim.rotation += 0.01;\n    });\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Animated Sprite Speed",
          "entry": "animatedsprite-animationspeed.js",
          "path": "sprite/animatedsprite-animationspeed.js",
          "code": "const app = new PIXI.Application({ autoStart: false });\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('examples/assets/spritesheet/0123456789.json').then((spritesheet) => {\n    // create an array to store the textures\n    const textures = [];\n    let i;\n\n    for (i = 0; i < 10; i++) {\n        const framekey = `0123456789 ${i}.ase`;\n        const texture = PIXI.Texture.from(framekey);\n        const time = spritesheet.data.frames[framekey].duration;\n        textures.push({ texture, time });\n    }\n\n    const scaling = 4;\n\n    // create a slow AnimatedSprite\n    const slow = new PIXI.AnimatedSprite(textures);\n    slow.anchor.set(0.5);\n    slow.scale.set(scaling);\n    slow.animationSpeed = 0.5;\n    slow.x = (app.screen.width - slow.width) / 2;\n    slow.y = app.screen.height / 2;\n    slow.play();\n    app.stage.addChild(slow);\n\n    // create a fast AnimatedSprite\n    const fast = new PIXI.AnimatedSprite(textures);\n    fast.anchor.set(0.5);\n    fast.scale.set(scaling);\n    fast.x = (app.screen.width + fast.width) / 2;\n    fast.y = app.screen.height / 2;\n    fast.play();\n    app.stage.addChild(fast);\n\n    // start animating\n    app.start();\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Tiling Sprite",
          "entry": "tiling-sprite.js",
          "path": "sprite/tiling-sprite.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// create a texture from an image path\nconst texture = PIXI.Texture.from('examples/assets/p2.jpeg');\n\n/* create a tiling sprite ...\n * requires a texture, a width and a height\n * in WebGL the image size should preferably be a power of two\n */\nconst tilingSprite = new PIXI.TilingSprite(\n    texture,\n    app.screen.width,\n    app.screen.height,\n);\napp.stage.addChild(tilingSprite);\n\nlet count = 0;\n\napp.ticker.add(() => {\n    count += 0.005;\n\n    tilingSprite.tileScale.x = 2 + Math.sin(count);\n    tilingSprite.tileScale.y = 2 + Math.cos(count);\n\n    tilingSprite.tilePosition.x += 1;\n    tilingSprite.tilePosition.y += 1;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Video",
          "entry": "video.js",
          "path": "sprite/video.js",
          "code": "const app = new PIXI.Application({ backgroundAlpha: 0 });\ndocument.body.appendChild(app.view);\n\n// Create play button that can be used to trigger the video\nconst button = new PIXI.Graphics()\n    .beginFill(0x0, 0.5)\n    .drawRoundedRect(0, 0, 100, 100, 10)\n    .endFill()\n    .beginFill(0xffffff)\n    .moveTo(36, 30)\n    .lineTo(36, 70)\n    .lineTo(70, 50);\n\n// Position the button\nbutton.x = (app.screen.width - button.width) / 2;\nbutton.y = (app.screen.height - button.height) / 2;\n\n// Enable interactivity on the button\nbutton.interactive = true;\nbutton.cursor = 'pointer';\n\n// Add to the stage\napp.stage.addChild(button);\n\n// Listen for a click/tap event to start playing the video\n// this is useful for some mobile platforms. For example:\n// ios9 and under cannot render videos in PIXI without a\n// polyfill - https://github.com/bfred-it/iphone-inline-video\n// ios10 and above require a click/tap event to render videos\n// that contain audio in PIXI. Videos with no audio track do\n// not have this requirement\nbutton.on('pointertap', onPlayVideo);\n\nfunction onPlayVideo() {\n    // Don't need the button anymore\n    button.destroy();\n\n    // create a video texture from a path\n    const texture = PIXI.Texture.from('examples/assets/video.mp4');\n\n    // create a new Sprite using the video texture (yes it's that easy)\n    const videoSprite = new PIXI.Sprite(texture);\n\n    // Stetch the fullscreen\n    videoSprite.width = app.screen.width;\n    videoSprite.height = app.screen.height;\n\n    app.stage.addChild(videoSprite);\n}\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "text",
      "title": "Text",
      "examples": [
        {
          "title": "Text",
          "entry": "text.js",
          "path": "text/text.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nconst basicText = new PIXI.Text('Basic text in pixi');\nbasicText.x = 50;\nbasicText.y = 100;\n\napp.stage.addChild(basicText);\n\nconst style = new PIXI.TextStyle({\n    fontFamily: 'Arial',\n    fontSize: 36,\n    fontStyle: 'italic',\n    fontWeight: 'bold',\n    fill: ['#ffffff', '#00ff99'], // gradient\n    stroke: '#4a1850',\n    strokeThickness: 5,\n    dropShadow: true,\n    dropShadowColor: '#000000',\n    dropShadowBlur: 4,\n    dropShadowAngle: Math.PI / 6,\n    dropShadowDistance: 6,\n    wordWrap: true,\n    wordWrapWidth: 440,\n    lineJoin: 'round',\n});\n\nconst richText = new PIXI.Text('Rich text with a lot of options and across multiple lines', style);\nrichText.x = 50;\nrichText.y = 220;\n\napp.stage.addChild(richText);\n\nconst skewStyle = new PIXI.TextStyle({\n    fontFamily: 'Arial',\n    dropShadow: true,\n    dropShadowAlpha: 0.8,\n    dropShadowAngle: 2.1,\n    dropShadowBlur: 4,\n    dropShadowColor: '0x111111',\n    dropShadowDistance: 10,\n    fill: ['#ffffff'],\n    stroke: '#004620',\n    fontSize: 60,\n    fontWeight: 'lighter',\n    lineJoin: 'round',\n    strokeThickness: 12,\n});\n\nconst skewText = new PIXI.Text('SKEW IS COOL', skewStyle);\nskewText.skew.set(0.65, -0.3);\nskewText.anchor.set(0.5, 0.5);\nskewText.x = 300;\nskewText.y = 480;\n\napp.stage.addChild(skewText);\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Bitmap Text",
          "entry": "bitmap-text.js",
          "path": "text/bitmap-text.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('examples/assets/bitmap-font/desyrel.xml').then(() => {\n    const bitmapFontText = new PIXI.BitmapText(\n        'bitmap fonts are supported!\\nWoo yay!', {\n            fontName: 'Desyrel',\n            fontSize: 55,\n            align: 'left',\n        },\n    );\n\n    bitmapFontText.x = 50;\n    bitmapFontText.y = 200;\n\n    app.stage.addChild(bitmapFontText);\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Loading Fonts",
          "entry": "from-font.js",
          "path": "text/from-font.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// Load from any font file!\nPIXI.Assets.addBundle('fonts', {\n    ChaChicle: 'examples/assets/webfont-loader/ChaChicle.ttf',\n    Lineal: 'examples/assets/webfont-loader/Lineal.otf',\n    'Dotrice Regular': 'examples/assets/webfont-loader/Dotrice-Regular.woff',\n    Crosterian: 'examples/assets/webfont-loader/Crosterian.woff2',\n});\nPIXI.Assets.loadBundle('fonts').then(() => {\n    const text1 = new PIXI.Text('ChaChicle.ttf', new PIXI.TextStyle({ fontFamily: 'ChaChicle', fontSize: 50 }));\n    const text2 = new PIXI.Text('Lineal.otf', new PIXI.TextStyle({ fontFamily: 'Lineal', fontSize: 50 }));\n    const text3 = new PIXI.Text('Dotrice Regular.woff', new PIXI.TextStyle({ fontFamily: 'Dotrice Regular', fontSize: 50 }));\n    const text4 = new PIXI.Text('Crosterian.woff2', new PIXI.TextStyle({ fontFamily: 'Crosterian', fontSize: 50 }));\n\n    text2.y = 150;\n    text3.y = 300;\n    text4.y = 450;\n\n    app.stage.addChild(text1);\n    app.stage.addChild(text2);\n    app.stage.addChild(text3);\n    app.stage.addChild(text4);\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Google Webfont",
          "entry": "webfont.js",
          "path": "text/webfont.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// Load them google fonts before starting...\nwindow.WebFontConfig = {\n    google: {\n        families: ['Snippet'],\n    },\n    active() {\n        init();\n    },\n};\n\n/* eslint-disable */\n// include the web-font loader script\n(function() {\n    const wf = document.createElement('script');\n    wf.src = `${document.location.protocol === 'https:' ? 'https' : 'http'\n    }://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js`;\n    wf.type = 'text/javascript';\n    wf.async = 'true';\n    const s = document.getElementsByTagName('script')[0];\n    s.parentNode.insertBefore(wf, s);\n}());\n/* eslint-enabled */\n\nfunction init() {\n    // create some white text using the Snippet webfont\n    const textSample = new PIXI.Text(\n        'PixiJS text using the\\ncustom \"Snippet\" Webfont', {\n            fontFamily: 'Snippet',\n            fontSize: 50,\n            fill: 'white',\n            align: 'left',\n        }\n    );\n    textSample.position.set(50, 200);\n    app.stage.addChild(textSample);\n}\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "graphics",
      "title": "Graphics",
      "examples": [
        {
          "title": "Simple",
          "entry": "simple.js",
          "path": "graphics/simple.js",
          "code": "const app = new PIXI.Application({ antialias: true });\ndocument.body.appendChild(app.view);\n\nconst graphics = new PIXI.Graphics();\n\n// Rectangle\ngraphics.beginFill(0xDE3249);\ngraphics.drawRect(50, 50, 100, 100);\ngraphics.endFill();\n\n// Rectangle + line style 1\ngraphics.lineStyle(2, 0xFEEB77, 1);\ngraphics.beginFill(0x650A5A);\ngraphics.drawRect(200, 50, 100, 100);\ngraphics.endFill();\n\n// Rectangle + line style 2\ngraphics.lineStyle(10, 0xFFBD01, 1);\ngraphics.beginFill(0xC34288);\ngraphics.drawRect(350, 50, 100, 100);\ngraphics.endFill();\n\n// Rectangle 2\ngraphics.lineStyle(2, 0xFFFFFF, 1);\ngraphics.beginFill(0xAA4F08);\ngraphics.drawRect(530, 50, 140, 100);\ngraphics.endFill();\n\n// Circle\ngraphics.lineStyle(0); // draw a circle, set the lineStyle to zero so the circle doesn't have an outline\ngraphics.beginFill(0xDE3249, 1);\ngraphics.drawCircle(100, 250, 50);\ngraphics.endFill();\n\n// Circle + line style 1\ngraphics.lineStyle(2, 0xFEEB77, 1);\ngraphics.beginFill(0x650A5A, 1);\ngraphics.drawCircle(250, 250, 50);\ngraphics.endFill();\n\n// Circle + line style 2\ngraphics.lineStyle(10, 0xFFBD01, 1);\ngraphics.beginFill(0xC34288, 1);\ngraphics.drawCircle(400, 250, 50);\ngraphics.endFill();\n\n// Ellipse + line style 2\ngraphics.lineStyle(2, 0xFFFFFF, 1);\ngraphics.beginFill(0xAA4F08, 1);\ngraphics.drawEllipse(600, 250, 80, 50);\ngraphics.endFill();\n\n// draw a shape\ngraphics.beginFill(0xFF3300);\ngraphics.lineStyle(4, 0xffd900, 1);\ngraphics.moveTo(50, 350);\ngraphics.lineTo(250, 350);\ngraphics.lineTo(100, 400);\ngraphics.lineTo(50, 350);\ngraphics.closePath();\ngraphics.endFill();\n\n// draw a rounded rectangle\ngraphics.lineStyle(2, 0xFF00FF, 1);\ngraphics.beginFill(0x650A5A, 0.25);\ngraphics.drawRoundedRect(50, 440, 100, 100, 16);\ngraphics.endFill();\n\n// draw star\ngraphics.lineStyle(2, 0xFFFFFF);\ngraphics.beginFill(0x35CC5A, 1);\ngraphics.drawStar(360, 370, 5, 50);\ngraphics.endFill();\n\n// draw star 2\ngraphics.lineStyle(2, 0xFFFFFF);\ngraphics.beginFill(0xFFCC5A, 1);\ngraphics.drawStar(280, 510, 7, 50);\ngraphics.endFill();\n\n// draw star 3\ngraphics.lineStyle(4, 0xFFFFFF);\ngraphics.beginFill(0x55335A, 1);\ngraphics.drawStar(470, 450, 4, 50);\ngraphics.endFill();\n\n// draw polygon\nconst path = [600, 370, 700, 460, 780, 420, 730, 570, 590, 520];\n\ngraphics.lineStyle(0);\ngraphics.beginFill(0x3500FA, 1);\ngraphics.drawPolygon(path);\ngraphics.endFill();\n\napp.stage.addChild(graphics);\n",
          "exists": true,
          "plugins": [
            "@pixi/graphics-extras"
          ]
        },
        {
          "title": "Advanced",
          "entry": "advanced.js",
          "path": "graphics/advanced.js",
          "code": "const app = new PIXI.Application({ antialias: true });\ndocument.body.appendChild(app.view);\n\nconst sprite = PIXI.Sprite.from('examples/assets/bg_rotate.jpg');\n\n// // BEZIER CURVE ////\n// information: https://en.wikipedia.org/wiki/BÃ©zier_curve\n\nconst realPath = new PIXI.Graphics();\n\nrealPath.lineStyle(2, 0xFFFFFF, 1);\nrealPath.moveTo(0, 0);\nrealPath.lineTo(100, 200);\nrealPath.lineTo(200, 200);\nrealPath.lineTo(240, 100);\n\nrealPath.position.x = 50;\nrealPath.position.y = 50;\n\napp.stage.addChild(realPath);\n\nconst bezier = new PIXI.Graphics();\n\nbezier.lineStyle(5, 0xAA0000, 1);\nbezier.bezierCurveTo(100, 200, 200, 200, 240, 100);\n\nbezier.position.x = 50;\nbezier.position.y = 50;\n\napp.stage.addChild(bezier);\n\n// // BEZIER CURVE 2 ////\nconst realPath2 = new PIXI.Graphics();\n\nrealPath2.lineStyle(2, 0xFFFFFF, 1);\nrealPath2.moveTo(0, 0);\nrealPath2.lineTo(0, -100);\nrealPath2.lineTo(150, 150);\nrealPath2.lineTo(240, 100);\n\nrealPath2.position.x = 320;\nrealPath2.position.y = 150;\n\napp.stage.addChild(realPath2);\n\nconst bezier2 = new PIXI.Graphics();\n\nbezier2.lineTextureStyle({ width: 10, texture: sprite.texture });\nbezier2.bezierCurveTo(0, -100, 150, 150, 240, 100);\n\nbezier2.position.x = 320;\nbezier2.position.y = 150;\n\napp.stage.addChild(bezier2);\n\n// // ARC ////\nconst arc = new PIXI.Graphics();\n\narc.lineStyle(5, 0xAA00BB, 1);\narc.arc(600, 100, 50, Math.PI, 2 * Math.PI);\n\napp.stage.addChild(arc);\n\n// // ARC 2 ////\nconst arc2 = new PIXI.Graphics();\n\narc2.lineStyle(6, 0x3333DD, 1);\narc2.arc(650, 270, 60, 2 * Math.PI, 3 * Math.PI / 2);\n\napp.stage.addChild(arc2);\n\n// // ARC 3 ////\nconst arc3 = new PIXI.Graphics();\n\narc3.lineTextureStyle({ width: 20, texture: sprite.texture });\narc3.arc(650, 420, 60, 2 * Math.PI, 2.5 * Math.PI / 2);\n\napp.stage.addChild(arc3);\n\n// / Hole ////\nconst rectAndHole = new PIXI.Graphics();\n\nrectAndHole.beginFill(0x00FF00);\nrectAndHole.drawRect(350, 350, 150, 150);\nrectAndHole.beginHole();\nrectAndHole.drawCircle(375, 375, 25);\nrectAndHole.drawCircle(425, 425, 25);\nrectAndHole.drawCircle(475, 475, 25);\nrectAndHole.endHole();\nrectAndHole.endFill();\n\napp.stage.addChild(rectAndHole);\n\n// // Line Texture Style ////\nconst beatifulRect = new PIXI.Graphics();\n\nbeatifulRect.lineTextureStyle({ width: 20, texture: sprite.texture });\nbeatifulRect.beginFill(0xFF0000);\nbeatifulRect.drawRect(80, 350, 150, 150);\nbeatifulRect.endFill();\n\napp.stage.addChild(beatifulRect);\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Dynamic",
          "entry": "dynamic.js",
          "path": "graphics/dynamic.js",
          "code": "const app = new PIXI.Application({ antialias: true });\ndocument.body.appendChild(app.view);\n\napp.stage.interactive = true;\napp.stage.hitArea = app.screen;\n\nconst graphics = new PIXI.Graphics();\n\n// set a fill and line style\ngraphics.beginFill(0xFF3300);\ngraphics.lineStyle(10, 0xffd900, 1);\n\n// draw a shape\ngraphics.moveTo(50, 50);\ngraphics.lineTo(250, 50);\ngraphics.lineTo(100, 100);\ngraphics.lineTo(250, 220);\ngraphics.lineTo(50, 220);\ngraphics.lineTo(50, 50);\ngraphics.closePath();\ngraphics.endFill();\n\n// set a fill and line style again\ngraphics.lineStyle(10, 0xFF0000, 0.8);\ngraphics.beginFill(0xFF700B, 1);\n\n// draw a second shape\ngraphics.moveTo(210, 300);\ngraphics.lineTo(450, 320);\ngraphics.lineTo(570, 350);\ngraphics.quadraticCurveTo(600, 0, 480, 100);\ngraphics.lineTo(330, 120);\ngraphics.lineTo(410, 200);\ngraphics.lineTo(210, 300);\ngraphics.closePath();\ngraphics.endFill();\n\n// draw a rectangle\ngraphics.lineStyle(2, 0x0000FF, 1);\ngraphics.drawRect(50, 250, 100, 100);\n\n// draw a circle\ngraphics.lineStyle(0);\ngraphics.beginFill(0xFFFF0B, 0.5);\ngraphics.drawCircle(470, 200, 100);\ngraphics.endFill();\n\ngraphics.lineStyle(20, 0x33FF00);\ngraphics.moveTo(30, 30);\ngraphics.lineTo(600, 300);\n\napp.stage.addChild(graphics);\n\n// let's create a moving shape\nconst thing = new PIXI.Graphics();\napp.stage.addChild(thing);\nthing.x = 800 / 2;\nthing.y = 600 / 2;\n\nlet count = 0;\n\n// Just click on the stage to draw random lines\nwindow.app = app;\napp.stage.on('pointerdown', () => {\n    graphics.lineStyle(Math.random() * 30, Math.random() * 0xFFFFFF, 1);\n    graphics.moveTo(Math.random() * 800, Math.random() * 600);\n    graphics.bezierCurveTo(\n        Math.random() * 800, Math.random() * 600,\n        Math.random() * 800, Math.random() * 600,\n        Math.random() * 800, Math.random() * 600,\n    );\n});\n\napp.ticker.add(() => {\n    count += 0.1;\n\n    thing.clear();\n    thing.lineStyle(10, 0xff0000, 1);\n    thing.beginFill(0xffFF00, 0.5);\n\n    thing.moveTo(-120 + Math.sin(count) * 20, -100 + Math.cos(count) * 20);\n    thing.lineTo(120 + Math.cos(count) * 20, -100 + Math.sin(count) * 20);\n    thing.lineTo(120 + Math.sin(count) * 20, 100 + Math.cos(count) * 20);\n    thing.lineTo(-120 + Math.cos(count) * 20, 100 + Math.sin(count) * 20);\n    thing.lineTo(-120 + Math.sin(count) * 20, -100 + Math.cos(count) * 20);\n    thing.closePath();\n\n    thing.rotation = count * 0.1;\n});\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "events",
      "title": "Events",
      "examples": [
        {
          "title": "Click",
          "entry": "click.js",
          "path": "events/click.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// Scale mode for all textures, will retain pixelation\nPIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;\n\nconst sprite = PIXI.Sprite.from('examples/assets/bunny.png');\n\n// Set the initial position\nsprite.anchor.set(0.5);\nsprite.x = app.screen.width / 2;\nsprite.y = app.screen.height / 2;\n\n// Opt-in to interactivity\nsprite.interactive = true;\n\n// Shows hand cursor\nsprite.cursor = 'pointer';\n\n// Pointers normalize touch and mouse\nsprite.on('pointerdown', onClick);\n\n// Alternatively, use the mouse & touch events:\n// sprite.on('click', onClick); // mouse-only\n// sprite.on('tap', onClick); // touch-only\n\napp.stage.addChild(sprite);\n\nfunction onClick() {\n    sprite.scale.x *= 1.25;\n    sprite.scale.y *= 1.25;\n}\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Interactivity",
          "entry": "interactivity.js",
          "path": "events/interactivity.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// create a background...\nconst background = PIXI.Sprite.from('examples/assets/bg_button.jpg');\nbackground.width = app.screen.width;\nbackground.height = app.screen.height;\n\n// add background to stage...\napp.stage.addChild(background);\n\n// create some textures from an image path\nconst textureButton = PIXI.Texture.from('examples/assets/button.png');\nconst textureButtonDown = PIXI.Texture.from('examples/assets/button_down.png');\nconst textureButtonOver = PIXI.Texture.from('examples/assets/button_over.png');\n\nconst buttons = [];\n\nconst buttonPositions = [\n    175, 75,\n    655, 75,\n    410, 325,\n    150, 465,\n    685, 445,\n];\n\nfor (let i = 0; i < 5; i++) {\n    const button = new PIXI.Sprite(textureButton);\n\n    button.anchor.set(0.5);\n    button.x = buttonPositions[i * 2];\n    button.y = buttonPositions[i * 2 + 1];\n\n    // make the button interactive...\n    button.interactive = true;\n    button.cursor = 'pointer';\n\n    button\n    // Mouse & touch events are normalized into\n    // the pointer* events for handling different\n    // button events.\n        .on('pointerdown', onButtonDown)\n        .on('pointerup', onButtonUp)\n        .on('pointerupoutside', onButtonUp)\n        .on('pointerover', onButtonOver)\n        .on('pointerout', onButtonOut);\n\n    // Use mouse-only events\n    // .on('mousedown', onButtonDown)\n    // .on('mouseup', onButtonUp)\n    // .on('mouseupoutside', onButtonUp)\n    // .on('mouseover', onButtonOver)\n    // .on('mouseout', onButtonOut)\n\n    // Use touch-only events\n    // .on('touchstart', onButtonDown)\n    // .on('touchend', onButtonUp)\n    // .on('touchendoutside', onButtonUp)\n\n    // add it to the stage\n    app.stage.addChild(button);\n\n    // add button to array\n    buttons.push(button);\n}\n\n// set some silly values...\nbuttons[0].scale.set(1.2);\nbuttons[2].rotation = Math.PI / 10;\nbuttons[3].scale.set(0.8);\nbuttons[4].scale.set(0.8, 1.2);\nbuttons[4].rotation = Math.PI;\n\nfunction onButtonDown() {\n    this.isdown = true;\n    this.texture = textureButtonDown;\n    this.alpha = 1;\n}\n\nfunction onButtonUp() {\n    this.isdown = false;\n    if (this.isOver) {\n        this.texture = textureButtonOver;\n    } else {\n        this.texture = textureButton;\n    }\n}\n\nfunction onButtonOver() {\n    this.isOver = true;\n    if (this.isdown) {\n        return;\n    }\n    this.texture = textureButtonOver;\n}\n\nfunction onButtonOut() {\n    this.isOver = false;\n    if (this.isdown) {\n        return;\n    }\n    this.texture = textureButton;\n}\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Dragging",
          "entry": "dragging.js",
          "path": "events/dragging.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// create a texture from an image path\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\n\n// Scale mode for pixelation\ntexture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\n\nfor (let i = 0; i < 10; i++) {\n    createBunny(\n        Math.floor(Math.random() * app.screen.width),\n        Math.floor(Math.random() * app.screen.height),\n    );\n}\n\nfunction createBunny(x, y) {\n    // create our little bunny friend..\n    const bunny = new PIXI.Sprite(texture);\n\n    // enable the bunny to be interactive... this will allow it to respond to mouse and touch events\n    bunny.interactive = true;\n\n    // this button mode will mean the hand cursor appears when you roll over the bunny with your mouse\n    bunny.cursor = 'pointer';\n\n    // center the bunny's anchor point\n    bunny.anchor.set(0.5);\n\n    // make it a bit bigger, so it's easier to grab\n    bunny.scale.set(3);\n\n    // setup events for mouse + touch using\n    // the pointer events\n    bunny.on('pointerdown', onDragStart, bunny);\n\n    // move the sprite to its designated position\n    bunny.x = x;\n    bunny.y = y;\n\n    // add it to the stage\n    app.stage.addChild(bunny);\n}\n\nlet dragTarget = null;\n\napp.stage.interactive = true;\napp.stage.hitArea = app.screen;\napp.stage.on('pointerup', onDragEnd);\napp.stage.on('pointerupoutside', onDragEnd);\n\nfunction onDragMove(event) {\n    if (dragTarget) {\n        dragTarget.parent.toLocal(event.global, null, dragTarget.position);\n    }\n}\n\nfunction onDragStart() {\n    // store a reference to the data\n    // the reason for this is because of multitouch\n    // we want to track the movement of this particular touch\n    // this.data = event.data;\n    this.alpha = 0.5;\n    dragTarget = this;\n    app.stage.on('pointermove', onDragMove);\n}\n\nfunction onDragEnd() {\n    if (dragTarget) {\n        app.stage.off('pointermove', onDragMove);\n        dragTarget.alpha = 1;\n        dragTarget = null;\n    }\n}\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Custom Mouse Cursor",
          "entry": "custom-mouse-icon.js",
          "path": "events/custom-mouse-icon.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// Css style for icons\nconst defaultIcon = \"url('examples/assets/bunny.png'),auto\";\nconst hoverIcon = \"url('examples/assets/bunny_saturated.png'),auto\";\n\n// Add custom cursor styles\napp.renderer.events.cursorStyles.default = defaultIcon;\napp.renderer.events.cursorStyles.hover = hoverIcon;\n\n// create a background...\nconst background = PIXI.Sprite.from('examples/assets/bg_button.jpg');\nbackground.width = app.screen.width;\nbackground.height = app.screen.height;\n// add background to stage...\napp.stage.addChild(background);\n\n// create some textures from an image path\nconst textureButton = PIXI.Texture.from('examples/assets/button.png');\nconst textureButtonDown = PIXI.Texture.from('examples/assets/button_down.png');\nconst textureButtonOver = PIXI.Texture.from('examples/assets/button_over.png');\n\nconst buttons = [];\n\nconst buttonPositions = [\n    175, 75,\n    655, 75,\n    410, 325,\n    150, 465,\n    685, 445,\n];\n\nfor (let i = 0; i < 5; i++) {\n    const button = new PIXI.Sprite(textureButton);\n    button.cursor = 'hover';\n\n    button.anchor.set(0.5);\n    button.x = buttonPositions[i * 2];\n    button.y = buttonPositions[i * 2 + 1];\n\n    // make the button interactive...\n    button.interactive = true;\n\n    button\n        .on('pointerdown', onButtonDown)\n        .on('pointerup', onButtonUp)\n        .on('pointerupoutside', onButtonUp)\n        .on('pointerover', onButtonOver)\n        .on('pointerout', onButtonOut);\n\n    // add it to the stage\n    app.stage.addChild(button);\n\n    // add button to array\n    buttons.push(button);\n}\n\n// set some silly values...\nbuttons[0].scale.set(1.2);\nbuttons[2].rotation = Math.PI / 10;\nbuttons[3].scale.set(0.8);\nbuttons[4].scale.set(0.8, 1.2);\nbuttons[4].rotation = Math.PI;\n\nfunction onButtonDown() {\n    this.isdown = true;\n    this.texture = textureButtonDown;\n    this.alpha = 1;\n}\n\nfunction onButtonUp() {\n    this.isdown = false;\n    if (this.isOver) {\n        this.texture = textureButtonOver;\n    } else {\n        this.texture = textureButton;\n    }\n}\n\nfunction onButtonOver() {\n    this.isOver = true;\n    if (this.isdown) {\n        return;\n    }\n    this.texture = textureButtonOver;\n}\n\nfunction onButtonOut() {\n    this.isOver = false;\n    if (this.isdown) {\n        return;\n    }\n    this.texture = textureButton;\n}\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Custom Hitarea",
          "entry": "custom-hitarea.js",
          "path": "events/custom-hitarea.js",
          "code": "const app = new PIXI.Application(800, 600, { background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nconst yellowStar = PIXI.Texture.from('examples/assets/yellowstar.png');\n\n// Standard Sprite Button\nconst starButton1 = new PIXI.Sprite(yellowStar);\n\nstarButton1.position.set(50, 200);\nstarButton1.cursor = 'pointer';\nstarButton1.interactive = true;\n\nstarButton1\n    .on('pointerdown', onClick, starButton1)\n    .on('pointerover', onPointerOver, starButton1)\n    .on('pointerout', onPointerOut, starButton1);\n\n// Custom Hitarea Button\nconst starButton2 = new PIXI.Sprite(yellowStar);\nstarButton2.position.set(250, 200);\n\n// Create a hitarea that matches the sprite, which will be used for point\n// intersection\nstarButton2.hitArea = new PIXI.Polygon([\n    80, 0,\n    100, 50,\n    160, 55,\n    115, 95,\n    130, 150,\n    80, 120,\n    30, 150,\n    45, 95,\n    0, 55,\n    60, 50,\n]);\nstarButton2.cursor = 'pointer';\nstarButton2.interactive = true;\n\nstarButton2\n    .on('pointerdown', onClick, starButton2)\n    .on('pointerover', onPointerOver, starButton2)\n    .on('pointerout', onPointerOut, starButton2);\n\n// With Mask, No Hit Area\nconst starButton3 = new PIXI.Sprite(yellowStar);\n\nstarButton3.position.set(450, 200);\nstarButton3.cursor = 'pointer';\nstarButton3.interactive = true;\n\nconst squareMask = new PIXI.Graphics()\n    .beginFill(0xFFFFFF)\n    .drawRect(starButton3.x, starButton3.y, 75, 200)\n    .endFill();\n\nstarButton3.mask = squareMask;\n\nstarButton3\n    .on('pointerdown', onClick, starButton3)\n    .on('pointerover', onPointerOver, starButton3)\n    .on('pointerout', onPointerOut, starButton3);\n\n// With a Mask and Hit Area\n// Hitareas ignore masks. You can still click on a button made in this way,\n// even from areas covered by a mask\nconst starButton4 = new PIXI.Sprite(yellowStar);\nstarButton4.position.set(600, 200);\n\nconst squareMask2 = new PIXI.Graphics()\n    .beginFill(0xFFFFFF)\n    .drawRect(starButton4.x, starButton4.y, 75, 200)\n    .endFill();\n\nstarButton4.mask = squareMask2;\n\n// Again, hitarea for intersection checks\nstarButton4.hitArea = new PIXI.Polygon([\n    80, 0,\n    100, 50,\n    160, 55,\n    115, 95,\n    130, 150,\n    80, 120,\n    30, 150,\n    45, 95,\n    0, 55,\n    60, 50,\n]);\nstarButton4.cursor = 'pointer';\nstarButton4.interactive = true;\n\nstarButton4\n    .on('pointerdown', onClick, starButton4)\n    .on('pointerover', onPointerOver, starButton4)\n    .on('pointerout', onPointerOut, starButton4);\n\nconst style = new PIXI.TextStyle({ fill: '#ffffff' });\n\nconst text1 = new PIXI.Text('Standard', style);\ntext1.x = starButton1.x + 25;\ntext1.y = starButton1.y + 170;\n\nconst text2 = new PIXI.Text('Hit Area', style);\ntext2.x = starButton2.x + 35;\ntext2.y = starButton2.y + 170;\n\nconst text3 = new PIXI.Text('Mask', style);\ntext3.x = starButton3.x + 10;\ntext3.y = starButton3.y + 170;\n\nconst text4 = new PIXI.Text('Mask + Hit Area', style);\ntext4.x = starButton4.x - 10;\ntext4.y = starButton4.y + 170;\n\n// Add to stage\napp.stage.addChild(\n    starButton2,\n    starButton1,\n    starButton3,\n    starButton4,\n    squareMask,\n    squareMask2,\n    text1,\n    text2,\n    text3,\n    text4,\n);\n\nfunction onClick() {\n    this.tint = 0x333333;\n}\n\nfunction onPointerOver() {\n    this.tint = 0x666666;\n}\n\nfunction onPointerOut() {\n    this.tint = 0xFFFFFF;\n}\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Pointer Tracker",
          "entry": "pointer-tracker.js",
          "path": "events/pointer-tracker.js",
          "code": "// In this a example, a circle will follow the pointer wherever it\n// moves over the canvas.\n\nconst app = new PIXI.Application({\n    antialias: true,\n    background: '#1099bb',\n});\ndocument.body.appendChild(app.view);\n\n// Create the circle\nconst circle = app.stage.addChild(new PIXI.Graphics()\n    .beginFill(0xffffff)\n    .lineStyle({ color: 0x111111, alpha: 0.87, width: 1 })\n    .drawCircle(0, 0, 8)\n    .endFill());\ncircle.position.set(app.screen.width / 2, app.screen.height / 2);\n\n// Enable interactivity!\napp.stage.interactive = true;\n\n// Make sure the whole canvas area is interactive, not just the circle.\napp.stage.hitArea = app.screen;\n\n// Follow the pointer\napp.stage.addEventListener('pointermove', (e) => {\n    circle.position.copyFrom(e.global);\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Slider",
          "entry": "slider.js",
          "path": "events/slider.js",
          "code": "const app = new PIXI.Application({\n    antialias: true,\n    background: '#1099bb',\n});\ndocument.body.appendChild(app.view);\n\nconst stageHeight = app.screen.height;\nconst stageWidth = app.screen.width;\n\n// Make sure stage covers the whole scene\napp.stage.hitArea = app.screen;\n\n// Make the slider\nconst sliderWidth = 320;\nconst slider = new PIXI.Graphics()\n    .beginFill(0x272d37)\n    .drawRect(0, 0, sliderWidth, 4);\n\nslider.x = (stageWidth - sliderWidth) / 2;\nslider.y = stageHeight * 0.75;\n\n// Draw the handle\nconst handle = new PIXI.Graphics()\n    .beginFill(0xffffff)\n    .drawCircle(0, 0, 8);\nhandle.y = slider.height / 2;\nhandle.x = sliderWidth / 2;\nhandle.interactive = true;\nhandle.cursor = 'pointer';\n\nhandle\n    .on('pointerdown', onDragStart)\n    .on('pointerup', onDragEnd)\n    .on('pointerupoutside', onDragEnd);\n\napp.stage.addChild(slider);\nslider.addChild(handle);\n\n// Add bunny whose scale can be changed by user using slider\nconst bunny = app.stage.addChild(PIXI.Sprite.from('examples/assets/bunny.png'));\nbunny.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\nbunny.scale.set(3);\nbunny.anchor.set(0.5);\nbunny.x = stageWidth / 2;\nbunny.y = stageHeight / 2;\n\n// Add title\nconst title = new PIXI.Text('Drag the handle to change the scale of bunny.', {\n    fill: '#272d37',\n    fontFamily: 'Roboto',\n    fontSize: 20,\n    align: 'center',\n});\ntitle.roundPixels = true;\ntitle.x = stageWidth / 2;\ntitle.y = 40;\ntitle.anchor.set(0.5, 0);\napp.stage.addChild(title);\n\n// Listen to pointermove on stage once handle is pressed.\nfunction onDragStart() {\n    app.stage.interactive = true;\n    app.stage.addEventListener('pointermove', onDrag);\n}\n\n// Stop dragging feedback once the handle is released.\nfunction onDragEnd(e) {\n    app.stage.interactive = false;\n    app.stage.removeEventListener('pointermove', onDrag);\n}\n\n// Update the handle's position & bunny's scale when the handle is moved.\nfunction onDrag(e) {\n    const halfHandleWidth = handle.width / 2;\n    // Set handle y-position to match pointer, clamped to (4, screen.height - 4).\n    handle.x = Math.max(halfHandleWidth, Math.min(\n        slider.toLocal(e.global).x,\n        sliderWidth - halfHandleWidth,\n    ));\n    // Normalize handle position between -1 and 1.\n    const t = 2 * ((handle.x / sliderWidth) - 0.5);\n    bunny.scale.set(3 * (1.1 + t));\n}\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Hit-Testing (spatial hash)",
          "entry": "hit-testing-with-spatial-hash.js",
          "path": "events/hit-testing-with-spatial-hash.js",
          "code": "// This example shows how you can create your own EventBoundary to accelerate\n// hit-testing using spatial hashes. This can be used to optimize relatively\n// \"flat\" scene graphs, where  a container contains so many objects that it\n// covers the whole scene.\n\n// This special event boundary overrides the hit-testing implementation to use\n// HashingContainer's own childHash to find children near the pointer\n// location.\nclass HashingEventBoundary extends PIXI.EventBoundary {\n    constructor(...args) {\n        super(...args);\n        // Create reusable temp rectangle for hit-testing!\n        this.tempRect = new PIXI.Rectangle();\n    }\n\n    hitTestRecursive(\n        currentTarget,\n        interactive,\n        location,\n        testFn,\n        pruneFn,\n    ) {\n        // If currentTarget isn't a HashingContainer, then default to the\n        // regular hit-testing implementation provided by PixiJS.\n        if (!currentTarget\n                || !currentTarget.visible\n                || !currentTarget.childHash) {\n            return super.hitTestRecursive(\n                currentTarget,\n                interactive,\n                location,\n                testFn,\n                pruneFn,\n            );\n        }\n\n        // Check if the location is outside of the entire container\n        if (pruneFn(currentTarget, location)) return null;\n\n        // Time to get recursive and find the next child in the propagation\n        // path of the event, accelerated using the childHash.\n        if (currentTarget.interactiveChildren) {\n            /* This is where the magic happens! */\n            const tempRect = this.tempRect;\n\n            // Store the location as a 0x0 rectangle. SpatialHash requires a\n            // rectangle for searching.\n            tempRect.x = location.x;\n            tempRect.y = location.y;\n\n            // Find all the children overlapping with tempRect a.k.a location,\n            // and then sort them by their index in the HashingContainer's\n            // children array.\n            const children = Array\n                .from(currentTarget.childHash.search(tempRect))\n                .sort((a, b) => a.refIndex - b.refIndex);\n\n            /* The following is copied from EventBoundary's code. */\n            for (let i = children.length - 1; i >= 0; i--) {\n                const child = children[i];\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    interactive || child.interactive,\n                    location,\n                    testFn,\n                    pruneFn,\n                );\n\n                if (nestedHit) {\n                    // Its a good idea to check if a child has lost its\n                    // parent. this means it has been removed whilst looping\n                    // so its best\n                    if (nestedHit.length > 0\n                            && !nestedHit[nestedHit.length - 1].parent) {\n                        // eslint-disable-next-line no-continue\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test\n                    // chain if the chain has already started (i.e. the event\n                    // target has been found) or if the current target is\n                    // interactive (i.e. it becomes the event target).\n                    if (nestedHit.length > 0 || currentTarget.interactive) {\n                        nestedHit.push(currentTarget);\n                    }\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        /* The following is copied from EventBoundary's own implementation. */\n\n        // Finally, hit test this DisplayObject itself.\n        if (interactive && testFn(currentTarget, location)) {\n            // The current hit-test target is the event's target only if it\n            // is interactive. Otherwise, the first interactive ancestor will\n            // be the event's target.\n            return currentTarget.interactive ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n}\n\n// HashingContainer is a special kind of container that organizes its children\n// in a spatial hash. It also sets each child's refIndex property to its index\n// in the hashing container's children array.\nclass HashingContainer extends PIXI.Container {\n    constructor() {\n        super();\n        this.childHash = new PIXI.SpatialHash();\n    }\n\n    // Override updateTransform to update this.childHash!\n    updateTransform() {\n        super.updateTransform();\n\n        // Reset childHash & re-add all the children. This will\n        // make the spatial hash re-evaluate the coverage of each child.\n        this.childHash.reset();\n        for (let i = 0; i < this.children.length; i++) {\n            const child = this.children[i];\n\n            this.childHash.put(child);\n            child.refIndex = i;\n        }\n    }\n}\n\n// This is the actual program using HashingEventBoundary, HashingContainer.\nfunction main() {\n    // Create app. autoStart = false so that the app doesn't render until\n    // something changes - this prevents redundant spatial-hash updates.\n    const app = new PIXI.Application({\n        antialias: true,\n        autoStart: false,\n        background: '#1099bb',\n    });\n    document.body.appendChild(app.view);\n\n    // Install our own EventBoundary!\n    app.renderer.events.rootBoundary = new HashingEventBoundary(app.stage);\n\n    // Make the hashing container\n    const container = app.stage.addChild(new HashingContainer());\n    // Textures to choose from for each random character\n    const textures = [\n        PIXI.Texture.from('examples/assets/skully.png'),\n        PIXI.Texture.from('examples/assets/eggHead.png'),\n        PIXI.Texture.from('examples/assets/flowerTop.png'),\n        PIXI.Texture.from('examples/assets/helmlok.png'),\n    ];\n    // Rerender scene when each texture loads\n    textures.forEach(\n        (tex) => tex.baseTexture.once('loaded', () => app.render()),\n    );\n\n    // Populate the hashing container!\n    function makeMonster(x, y) {\n        const texture = textures[Math.floor(Math.random() * textures.length)];\n        const sprite = new PIXI.Sprite(texture);\n\n        // Randomly place the character\n        sprite.position.set(\n            x || Math.random() * (app.screen.width - 64),\n            y || (64 + Math.random() * (app.screen.height - 128)),\n        );\n\n        // Make character smaller so we can have a bunch of 'em\n        sprite.scale.set(0.34);\n\n        // Make the character interactive!\n        sprite.interactive = true;\n\n        // Explode on clicks!\n        sprite.addEventListener('click', onMonsterClicked);\n\n        container.addChild(sprite);\n\n        return sprite;\n    }\n    function onMonsterClicked(e) {\n        const monster = this;\n        const pos = monster.position;\n        const radius = Math.max(monster.width, monster.height) * 2;\n\n        // Remove monster from scene once the event finishes propagating.\n        e.manager.dispatch.once('click', () => {\n            // TODO: Fix PixiJS throwing errors since the monster is removed\n            // from scene graph while was under hover.\n\n            monster.parent.removeChild(monster);\n            PIXI.Ticker.shared.addOnce(() => app.render());\n        });\n\n        for (let i = 0; i < 8; i++) {\n            const x = pos.x + radius * Math.cos(i * Math.PI / 4);\n            const y = pos.y + radius * Math.sin(i * Math.PI / 4);\n\n            makeMonster(x, y);\n        }\n    }\n    // Make initial set of monsters\n    for (let i = 0; i < 100; i++) makeMonster();\n\n    // Add a descriptive title\n    const title = app.stage.addChild(\n        new PIXI.Text(\n            'Click on a monster and see it explode into more!',\n            {\n                fontSize: 12,\n            },\n        ),\n    );\n    title.position.set(12, 12);\n\n    // Render the stage once\n    app.render();\n}\n\n// Run our program!\nmain();\n",
          "exists": true,
          "plugins": [
            "@pixi/spatial-hash"
          ]
        },
        {
          "title": "Nested Boundary",
          "entry": "nested-boundary-with-projection.js",
          "path": "events/nested-boundary-with-projection.js",
          "code": "// This example shows how you can setup a nested boundary to propagate events\n// into a disjoint scene graph. Here, a camera is used to project an different\n// world onto the canvas.\n\nconst app = new PIXI.Application({\n    antialias: true,\n    background: '#1099bb',\n});\ndocument.body.appendChild(app.view);\n\n// A projector renders it's content using projection. The transforms in\n// the contents scene graph don't change if you move the camera. To achieve\n// this, the content is not added as a \"child\" to the projector; however, this\n// means events won't propagate into the content by default.\n//\n// To solve this, we nest our own EventBoundary, and connect it using\n// addEventListener!\nclass Projector extends PIXI.DisplayObject {\n    constructor() {\n        super();\n\n        // The content root to be rendered by this camera.\n        this.content = new PIXI.Container();\n\n        // Temporary matrix to store the original projection transform.\n        this.originalTransform = new PIXI.Matrix();\n\n        // The event boundary that'll map events downstream into the content\n        // scene.\n        this.boundary = new PIXI.EventBoundary(this.content);\n\n        // Override copyMouseData to apply inverse worldTransform on\n        // global coords\n        this.boundary.copyMouseData = (from, to) => {\n            // Apply default implementation first\n            PIXI.EventBoundary.prototype.copyMouseData.call(this.boundary, from, to);\n\n            // Then bring global coords into content's world\n            this.worldTransform.applyInverse(to.global, to.global);\n            // TODO: Remove after https://github.com/pixijs/pixi.js/pull/7381\n            // is merged!\n            to.target = this.boundary.hitTest(to.global.x, to.global.y);\n        };\n\n        // Propagate these events down into the content's scene graph!\n        [\n            'pointerdown',\n            'pointerup',\n            'pointermove',\n            'pointerover',\n            'pointerout',\n            'wheel',\n        ].forEach((event) => {\n            this.addEventListener(event, (e) => this.boundary.mapEvent(e));\n        });\n\n        this.interactive = true;\n    }\n\n    // Pass through cursor\n    get cursor() {\n        return this.boundary.cursor;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    set cursor(value) {\n        throw new Error('The camera\\'s cursor is derived from its content!');\n    }\n\n    // Pass through calculateBounds\n    calculateBounds() {\n        const contentBounds = this.content.getBounds();\n\n        this._bounds.addFrameMatrix(\n            this.worldTransform,\n            contentBounds.x,\n            contentBounds.y,\n            contentBounds.width,\n            contentBounds.height,\n        );\n    }\n\n    // Pass through containsPoint\n    containsPoint(point) {\n        return !!this.boundary.hitTest(point.x, point.y);\n    }\n\n    // Render content with projection\n    render(renderer) {\n        renderer.batch.flush();\n\n        const projectionSystem = renderer.projection;\n        const renderTextureSystem = renderer.renderTexture;\n\n        projectionSystem.transform = projectionSystem.transform\n            || new PIXI.Matrix();\n        projectionSystem.transform.copyTo(this.originalTransform);\n        projectionSystem.transform.append(this.worldTransform);\n        projectionSystem.update(null, null, 1, !renderTextureSystem.current);\n\n        this.content.render(renderer);\n\n        renderer.batch.flush();\n\n        projectionSystem.transform.copyFrom(this.originalTransform);\n        projectionSystem.update(null, null, 1, !renderTextureSystem.current);\n    }\n\n    // updateTransform also updates content's transform\n    updateTransform() {\n        super.updateTransform();\n\n        this.content.enableTempParent();\n        this.content.updateTransform();\n        this.content.disableTempParent(null);\n    }\n}\n\n// The projector\nconst projector = app.stage.addChild(new Projector());\n\n// Add coordinate axes!\nprojector.content.addChild(\n    new PIXI.Graphics()\n        .lineStyle({ color: 0, alpha: 0.2, width: 2 })\n        .moveTo(0, -300)\n        .lineTo(0, 600)\n        .moveTo(-100, 0)\n        .lineTo(700, 0),\n);\n\n// Construct the star Graphics\nconst stars = [1, 2, 3].map((i) => new PIXI.Graphics()\n    .beginFill(0xffffff, 0.75)\n    .drawStar(0, 0, 18 / i, 100 * i / 2));\n\n// Place the stars\nstars[0].x = 0;\nstars[1].x = 200;\nstars[2].x = 500;\n\n// Add stars to the projector\nprojector.content.addChild(...stars);\n\n// Make projection x+100, y+300\nprojector.x = 100;\nprojector.y = 300;\nprojector.content.hitArea = new PIXI.Rectangle(-100, -300, app.screen.width, app.screen.height);\n// Make hit-area cover the whole screen so we can capture\n// pointermove everywhere!\nprojector.hitArea = projector.content.hitArea;\nprojector.content.interactive = true;\n\n// Make stars interactive & add wheel handlers\nstars.forEach((star) => {\n    // Make star interactive\n    star.interactive = true;\n\n    // Set initial cursor\n    star.cursor = 'zoom-in';\n\n    // Add wheel rotation feedback\n    star.addEventListener('wheel', (e) => {\n        const scroll = Math.sign(e.deltaY) * Math.min(15, Math.abs(e.deltaY));\n\n        star.rotation += scroll / 100;\n    });\n\n    // Add click zoom-in/zoom-out handler\n    star.addEventListener('click', (e) => {\n        if (star.scale.x === 1) {\n            star.scale.set(1.33);\n            star.cursor = 'zoom-out';\n        } else {\n            star.scale.set(1);\n            star.cursor = 'zoom-in';\n        }\n    });\n});\n\nPIXI.BitmapFont.from('coordinates', {\n    fontFamily: 'Roboto',\n    fontSize: 16,\n    fill: '#272d37',\n}, { chars: ['Global:() Screen-.,', ['0', '9']] });\n\nconst coordinates = new PIXI.BitmapText('Global: (0, 0)\\nScreen: (0, 0)', {\n    fontName: 'coordinates',\n});\ncoordinates.x = 110;\ncoordinates.y = 550;\n\napp.stage.addChild(coordinates);\n\nprojector.content.addEventListener('pointermove', (e) => {\n    const global = `(${e.global.x | 0}, ${e.global.y | 0})`;\n    const screen = `(${e.screen.x | 0}, ${e.screen.y | 0})`;\n    coordinates.text = `Global: ${global}\\nScreen: ${screen}`;\n});\n\nconst description = new PIXI.Text(\n    'The (0, 0) world coordinates for the content is located at the center of the first star!'\n    + '\\n  * Mouse wheel over stars to rotate them'\n    + '\\n  * Click to zoom in or out', {\n        fontSize: 16,\n        fontFamily: 'Roboto',\n        fill: '#272d37',\n    },\n);\n\ndescription.position.set(110, 12);\n\napp.stage.addChild(description);\n",
          "exists": true,
          "plugins": [
            "@pixi/graphics-extras"
          ]
        },
        {
          "title": "Logger",
          "entry": "logger.js",
          "path": "events/logger.js",
          "code": "// This example logs the order of events hover-related events in the scene.\nconst app = new PIXI.Application({\n    antialias: true,\n    background: '#1099bb',\n});\ndocument.body.appendChild(app.view);\n\nconst title = app.stage.addChild(new PIXI.Text(\n    `Move your mouse slowly over the boxes to\n    see the order of pointerenter, pointerleave,\n    pointerover, pointerout events on each target!`, {\n        fontSize: 16,\n    },\n));\n\ntitle.x = 2;\n\nconst logs = [];\nconst logText = app.stage.addChild(new PIXI.Text('', {\n    fontSize: 14,\n}));\n\nlogText.y = 80;\nlogText.x = 2;\n\napp.stage.name = 'stage';\n\n// Mount outer black box\nconst blackBox = app.stage.addChild(new PIXI.Graphics()\n    .beginFill(0)\n    .drawRect(0, 0, 400, 400)\n    .endFill());\nblackBox.name = 'black box';\nblackBox.x = 400;\n\n// Mount white box inside the white one\nconst whiteBox = blackBox.addChild(new PIXI.Graphics()\n    .beginFill(0xffffff)\n    .drawRect(100, 100, 200, 200)\n    .endFill());\nwhiteBox.name = 'white box';\n\n// Enable interactivity everywhere!\napp.stage.interactive = true;\napp.stage.hitArea = app.screen;\nwhiteBox.interactive = true;\nblackBox.interactive = true;\n\nfunction onEvent(e) {\n    const type = e.type;\n    const targetName = e.target.name;\n    const currentTargetName = e.currentTarget.name;\n\n    // Add event to top of logs\n    logs.push(`${currentTargetName} received ${type} event (target is ${targetName})`);\n\n    if (currentTargetName === 'stage'\n        || type === 'pointerenter'\n        || type === 'pointerleave') {\n        logs.push('-----------------------------------------', '');\n    }\n\n    // Prevent logs from growing too long\n    if (logs.length > 30) {\n        while (logs.length > 30) {\n            logs.shift();\n        }\n    }\n\n    // Update logText\n    logText.text = logs.join('\\n');\n}\n\n[app.stage, whiteBox, blackBox].forEach((object) => {\n    object.addEventListener('pointerenter', onEvent);\n    object.addEventListener('pointerleave', onEvent);\n    object.addEventListener('pointerover', onEvent);\n    object.addEventListener('pointerout', onEvent);\n});\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "masks",
      "title": "Masks",
      "examples": [
        {
          "title": "Graphics",
          "entry": "graphics.js",
          "path": "masks/graphics.js",
          "code": "const app = new PIXI.Application({ antialias: true });\ndocument.body.appendChild(app.view);\n\napp.stage.interactive = true;\n\nconst bg = PIXI.Sprite.from('examples/assets/bg_rotate.jpg');\n\nbg.anchor.set(0.5);\n\nbg.x = app.screen.width / 2;\nbg.y = app.screen.height / 2;\n\napp.stage.addChild(bg);\n\nconst container = new PIXI.Container();\ncontainer.x = app.screen.width / 2;\ncontainer.y = app.screen.height / 2;\n\n// add a bunch of sprites\nconst bgFront = PIXI.Sprite.from('examples/assets/bg_scene_rotate.jpg');\nbgFront.anchor.set(0.5);\n\nconst light2 = PIXI.Sprite.from('examples/assets/light_rotate_2.png');\nlight2.anchor.set(0.5);\n\nconst light1 = PIXI.Sprite.from('examples/assets/light_rotate_1.png');\nlight1.anchor.set(0.5);\n\nconst panda = PIXI.Sprite.from('examples/assets/panda.png');\npanda.anchor.set(0.5);\n\ncontainer.addChild(bgFront, light2, light1, panda);\n\napp.stage.addChild(container);\n\n// let's create a moving shape\nconst thing = new PIXI.Graphics();\napp.stage.addChild(thing);\nthing.x = app.screen.width / 2;\nthing.y = app.screen.height / 2;\nthing.lineStyle(0);\n\ncontainer.mask = thing;\n\nlet count = 0;\n\napp.stage.on('pointertap', () => {\n    if (!container.mask) {\n        container.mask = thing;\n    } else {\n        container.mask = null;\n    }\n});\n\nconst help = new PIXI.Text('Click or tap to turn masking on / off.', {\n    fontFamily: 'Arial',\n    fontSize: 12,\n    fontWeight: 'bold',\n    fill: 'white',\n});\nhelp.y = app.screen.height - 26;\nhelp.x = 10;\napp.stage.addChild(help);\n\napp.ticker.add(() => {\n    bg.rotation += 0.01;\n    bgFront.rotation -= 0.01;\n\n    light1.rotation += 0.02;\n    light2.rotation += 0.01;\n\n    panda.scale.x = 1 + Math.sin(count) * 0.04;\n    panda.scale.y = 1 + Math.cos(count) * 0.04;\n\n    count += 0.1;\n\n    thing.clear();\n\n    thing.beginFill(0x8bc5ff, 0.4);\n    thing.moveTo(-120 + Math.sin(count) * 20, -100 + Math.cos(count) * 20);\n    thing.lineTo(120 + Math.cos(count) * 20, -100 + Math.sin(count) * 20);\n    thing.lineTo(120 + Math.sin(count) * 20, 100 + Math.cos(count) * 20);\n    thing.lineTo(-120 + Math.cos(count) * 20, 100 + Math.sin(count) * 20);\n    thing.rotation = count * 0.1;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Sprite",
          "entry": "sprite.js",
          "path": "masks/sprite.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\napp.stage.interactive = true;\n\nconst bg = PIXI.Sprite.from('examples/assets/bg_plane.jpg');\n\napp.stage.addChild(bg);\n\nconst cells = PIXI.Sprite.from('examples/assets/cells.png');\n\ncells.scale.set(1.5);\n\nconst mask = PIXI.Sprite.from('examples/assets/flowerTop.png');\nmask.anchor.set(0.5);\nmask.x = 310;\nmask.y = 190;\n\ncells.mask = mask;\n\napp.stage.addChild(mask, cells);\n\nconst target = new PIXI.Point();\n\nreset();\n\nfunction reset() {\n    target.x = Math.floor(Math.random() * 550);\n    target.y = Math.floor(Math.random() * 300);\n}\n\napp.ticker.add(() => {\n    mask.x += (target.x - mask.x) * 0.1;\n    mask.y += (target.y - mask.y) * 0.1;\n\n    if (Math.abs(mask.x - target.x) < 1) {\n        reset();\n    }\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Filter",
          "entry": "filter.js",
          "path": "masks/filter.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// Inner radius of the circle\nconst radius = 100;\n\n// The blur amount\nconst blurSize = 32;\n\nPIXI.Assets.load('examples/assets/bg_grass.jpg').then((grassTexture) => {\n    const background = new PIXI.Sprite(grassTexture);\n    app.stage.addChild(background);\n    background.width = app.screen.width;\n    background.height = app.screen.height;\n\n    const circle = new PIXI.Graphics()\n        .beginFill(0xFF0000)\n        .drawCircle(radius + blurSize, radius + blurSize, radius)\n        .endFill();\n    circle.filters = [new PIXI.filters.BlurFilter(blurSize)];\n\n    const bounds = new PIXI.Rectangle(0, 0, (radius + blurSize) * 2, (radius + blurSize) * 2);\n    const texture = app.renderer.generateTexture(circle, PIXI.SCALE_MODES.NEAREST, 1, bounds);\n    const focus = new PIXI.Sprite(texture);\n\n    app.stage.addChild(focus);\n    background.mask = focus;\n\n    app.stage.interactive = true;\n    app.stage.hitArea = app.screen;\n    app.stage.on('pointermove', (event) => {\n        focus.position.x = event.global.x - focus.width / 2;\n        focus.position.y = event.global.y - focus.height / 2;\n    });\n});\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "textures",
      "title": "Textures",
      "examples": [
        {
          "title": "Texture Rotate",
          "entry": "texture-rotate.js",
          "path": "textures/texture-rotate.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('examples/assets/flowerTop.png').then((texture) => {\n    // create rotated textures\n    const textures = [texture];\n    const D8 = PIXI.groupD8;\n    for (let rotate = 1; rotate < 16; rotate++) {\n        const h = D8.isVertical(rotate) ? texture.frame.width : texture.frame.height;\n        const w = D8.isVertical(rotate) ? texture.frame.height : texture.frame.width;\n\n        const { frame } = texture;\n        const crop = new PIXI.Rectangle(texture.frame.x, texture.frame.y, w, h);\n        const trim = crop;\n        let rotatedTexture;\n        if (rotate % 2 === 0) {\n            rotatedTexture = new PIXI.Texture(texture.baseTexture, frame, crop, trim, rotate);\n        } else {\n            // HACK to avoid exception\n            // PIXI doesnt like diamond-shaped UVs, because they are different in canvas and webgl\n            rotatedTexture = new PIXI.Texture(texture.baseTexture, frame, crop, trim, rotate - 1);\n            rotatedTexture.rotate++;\n        }\n        textures.push(rotatedTexture);\n    }\n\n    const offsetX = app.screen.width / 16 | 0;\n    const offsetY = app.screen.height / 8 | 0;\n    const gridW = app.screen.width / 4 | 0;\n    const gridH = app.screen.height / 5 | 0;\n\n    // normal rotations and mirrors\n    for (let i = 0; i < 16; i++) {\n        // create a new Sprite using rotated texture\n        const dude = new PIXI.Sprite(textures[i < 8 ? i * 2 : (i - 8) * 2 + 1]);\n        dude.scale.x = 0.5;\n        dude.scale.y = 0.5;\n        // show it in grid\n        dude.x = offsetX + gridW * (i % 4);\n        dude.y = offsetY + gridH * (i / 4 | 0);\n        app.stage.addChild(dude);\n        const text = new PIXI.Text(`rotate = ${dude.texture.rotate}`, {\n            fontFamily: 'Courier New', fontSize: '12px', fill: 'white', align: 'left',\n        });\n        text.x = dude.x;\n        text.y = dude.y - 20;\n        app.stage.addChild(text);\n    }\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Render Texture Basic",
          "entry": "render-texture-basic.js",
          "path": "textures/render-texture-basic.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nconst container = new PIXI.Container();\napp.stage.addChild(container);\n\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\n\nfor (let i = 0; i < 25; i++) {\n    const bunny = new PIXI.Sprite(texture);\n    bunny.x = (i % 5) * 30;\n    bunny.y = Math.floor(i / 5) * 30;\n    bunny.rotation = Math.random() * (Math.PI * 2);\n    container.addChild(bunny);\n}\n\nconst brt = new PIXI.BaseRenderTexture({\n    width: 300,\n    height: 300,\n    scaleMode: PIXI.SCALE_MODES.LINEAR,\n    resolution: 1,\n});\nconst rt = new PIXI.RenderTexture(brt);\n\nconst sprite = new PIXI.Sprite(rt);\n\nsprite.x = 450;\nsprite.y = 60;\napp.stage.addChild(sprite);\n\n/*\n * All the bunnies are added to the container with the addChild method\n * when you do this, all the bunnies become children of the container, and when a container moves,\n * so do all its children.\n * This gives you a lot of flexibility and makes it easier to position elements on the screen\n */\ncontainer.x = 100;\ncontainer.y = 60;\n\napp.ticker.add(() => {\n    app.renderer.render(container, { renderTexture: rt });\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Render Texture Advanced",
          "entry": "render-texture-advanced.js",
          "path": "textures/render-texture-advanced.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst stageSize = {\n    width: app.screen.width,\n    height: app.screen.height,\n};\n\n// create two render textures... these dynamic textures will be used to draw the scene into itself\nlet renderTexture = PIXI.RenderTexture.create(stageSize);\nlet renderTexture2 = PIXI.RenderTexture.create(stageSize);\nconst currentTexture = renderTexture;\n\n// create a new sprite that uses the render texture we created above\nconst outputSprite = new PIXI.Sprite(currentTexture);\n\n// align the sprite\noutputSprite.x = 400;\noutputSprite.y = 300;\noutputSprite.anchor.set(0.5);\n\n// add to stage\napp.stage.addChild(outputSprite);\n\nconst stuffContainer = new PIXI.Container();\n\nstuffContainer.x = 400;\nstuffContainer.y = 300;\n\napp.stage.addChild(stuffContainer);\n\n// create an array of image ids..\nconst fruits = [\n    'examples/assets/rt_object_01.png',\n    'examples/assets/rt_object_02.png',\n    'examples/assets/rt_object_03.png',\n    'examples/assets/rt_object_04.png',\n    'examples/assets/rt_object_05.png',\n    'examples/assets/rt_object_06.png',\n    'examples/assets/rt_object_07.png',\n    'examples/assets/rt_object_08.png',\n];\n\n// create an array of items\nconst items = [];\n\n// now create some items and randomly position them in the stuff container\nfor (let i = 0; i < 20; i++) {\n    const item = PIXI.Sprite.from(fruits[i % fruits.length]);\n    item.x = Math.random() * 400 - 200;\n    item.y = Math.random() * 400 - 200;\n    item.anchor.set(0.5);\n    stuffContainer.addChild(item);\n    items.push(item);\n}\n\n// used for spinning!\nlet count = 0;\n\napp.ticker.add(() => {\n    for (let i = 0; i < items.length; i++) {\n    // rotate each item\n        const item = items[i];\n        item.rotation += 0.1;\n    }\n\n    count += 0.01;\n\n    // swap the buffers ...\n    const temp = renderTexture;\n    renderTexture = renderTexture2;\n    renderTexture2 = temp;\n\n    // set the new texture\n    outputSprite.texture = renderTexture;\n\n    // twist this up!\n    stuffContainer.rotation -= 0.01;\n    outputSprite.scale.set(1 + Math.sin(count) * 0.2);\n\n    // render the stage to the texture\n    // the 'true' clears the texture before the content is rendered\n    app.renderer.render(app.stage, {\n        renderTexture: renderTexture2,\n        clear: false,\n    });\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Gradient Basic",
          "entry": "gradient-basic.js",
          "path": "textures/gradient-basic.js",
          "code": "// This demo uses canvas2d gradient API\n// https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createLinearGradient\n\nconst app = new PIXI.Application({ antialias: true });\ndocument.body.appendChild(app.view);\n\nfunction createGradTexture() {\n    // adjust it if somehow you need better quality for very very big images\n    const quality = 256;\n    const canvas = document.createElement('canvas');\n    canvas.width = quality;\n    canvas.height = 1;\n\n    const ctx = canvas.getContext('2d');\n\n    // use canvas2d API to create gradient\n    const grd = ctx.createLinearGradient(0, 0, quality, 0);\n    grd.addColorStop(0, 'rgba(255, 255, 255, 0.0)');\n    grd.addColorStop(0.3, 'cyan');\n    grd.addColorStop(0.7, 'red');\n    grd.addColorStop(1, 'green');\n\n    ctx.fillStyle = grd;\n    ctx.fillRect(0, 0, quality, 1);\n\n    return PIXI.Texture.from(canvas);\n}\n\nconst gradTexture = createGradTexture();\n\nconst sprite = new PIXI.Sprite(gradTexture);\nsprite.position.set(100, 100);\nsprite.rotation = Math.PI / 8;\nsprite.width = 500;\nsprite.height = 50;\napp.stage.addChild(sprite);\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Gradient Resource",
          "entry": "gradient-resource.js",
          "path": "textures/gradient-resource.js",
          "code": "// PixiJS V5 Texture-Resource API + canvas2d gradient API + WebGL texImage2D\n// Look here for advanced upload function:\n// https://github.com/pixijs/pixi.js/blob/dev/packages/core/src/textures/resources/BaseImageResource.js#L54\n\nclass GradientResource extends PIXI.Resource {\n    constructor() {\n    // pass width and height. (0,0) if we dont know yet\n    // gradient needs only 1 pixel height\n        super(256, 1);\n    }\n\n    upload(renderer, baseTexture, glTexture) {\n        const { width } = this; // default size or from baseTexture?\n        const { height } = this; // your choice.\n\n        // temporary canvas, we dont need it after texture is uploaded to GPU\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n\n        const ctx = canvas.getContext('2d');\n\n        const grd = ctx.createLinearGradient(0, 0, width, 0);\n        grd.addColorStop(0, 'rgba(255, 255, 255, 0.0)');\n        grd.addColorStop(0.3, 'cyan');\n        grd.addColorStop(0.7, 'red');\n        grd.addColorStop(1, 'green');\n\n        ctx.fillStyle = grd;\n        ctx.fillRect(0, 0, width, height);\n\n        // This info ios usseful if upload happens second time\n        // Some people use that to track used memory\n        glTexture.width = width;\n        glTexture.height = height;\n\n        // PURE WEBGL CALLS - that's what its all about.\n        // PixiJS cant wrap all that API, we give you acceess to it!\n        const { gl } = renderer;\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);\n        gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, canvas);\n\n        return true;\n    }\n}\n\nconst app = new PIXI.Application({ antialias: true });\ndocument.body.appendChild(app.view);\n\nconst gradBaseTexture = new PIXI.BaseTexture(new GradientResource());\n// Here you can fake baseTexture size to avoid resizing all sprites\n// There can be multiple baseTextures per gradient, but be careful:\n// resource will spawn more glTextures!\ngradBaseTexture.setSize(500, 50);\n\nconst gradTexture = new PIXI.Texture(gradBaseTexture);\n\nconst sprite = new PIXI.Sprite(gradTexture);\nsprite.position.set(100, 100);\nsprite.rotation = Math.PI / 8;\napp.stage.addChild(sprite);\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "assets",
      "title": "Assets",
      "examples": [
        {
          "title": "Promise",
          "entry": "promise.js",
          "path": "assets/promise.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\r\ndocument.body.appendChild(app.view);\r\n\r\n// Start loading right away and create a promise\r\nconst texturePromise = PIXI.Assets.load('examples/assets/bunny.png');\r\n\r\n// When the promise resolves, we have the texture!\r\ntexturePromise.then((resolvedTexture) => {\r\n    // create a new Sprite from the resolved loaded Texture\r\n    const bunny = PIXI.Sprite.from(resolvedTexture);\r\n\r\n    // center the sprite's anchor point\r\n    bunny.anchor.set(0.5);\r\n\r\n    // move the sprite to the center of the screen\r\n    bunny.x = app.screen.width / 2;\r\n    bunny.y = app.screen.height / 2;\r\n\r\n    app.stage.addChild(bunny);\r\n});\r\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Async/Await",
          "entry": "async.js",
          "path": "assets/async.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\r\ndocument.body.appendChild(app.view);\r\n\r\n// await can only be used inside an async function\r\nasync function init() {\r\n    const texture = await PIXI.Assets.load('examples/assets/bunny.png');\r\n\r\n    // create a new Sprite from the awaited loaded Texture\r\n    const bunny = PIXI.Sprite.from(texture);\r\n\r\n    // center the sprite's anchor point\r\n    bunny.anchor.set(0.5);\r\n\r\n    // move the sprite to the center of the screen\r\n    bunny.x = app.screen.width / 2;\r\n    bunny.y = app.screen.height / 2;\r\n\r\n    app.stage.addChild(bunny);\r\n}\r\n\r\n// Call that async function\r\ninit();\r\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Load Multiple",
          "entry": "multiple.js",
          "path": "assets/multiple.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\r\ndocument.body.appendChild(app.view);\r\n\r\n// Add the assets to load\r\nPIXI.Assets.add('flowerTop', 'examples/assets/flowerTop.png');\r\nPIXI.Assets.add('eggHead', 'examples/assets/eggHead.png');\r\n\r\n// Load the assets and get a resolved promise once both are loaded\r\nconst texturesPromise = PIXI.Assets.load(['flowerTop', 'eggHead']); // => Promise<{flowerTop: Texture, eggHead: Texture}>\r\n\r\n// When the promise resolves, we have the texture!\r\ntexturesPromise.then((textures) => {\r\n    // create a new Sprite from the resolved loaded Textures\r\n\r\n    const flower = PIXI.Sprite.from(textures.flowerTop);\r\n    flower.anchor.set(0.5);\r\n    flower.x = app.screen.width * 0.25;\r\n    flower.y = app.screen.height / 2;\r\n    app.stage.addChild(flower);\r\n\r\n    const egg = PIXI.Sprite.from(textures.eggHead);\r\n    egg.anchor.set(0.5);\r\n    egg.x = app.screen.width * 0.75;\r\n    egg.y = app.screen.height / 2;\r\n    app.stage.addChild(egg);\r\n});\r\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Background Load",
          "entry": "background.js",
          "path": "assets/background.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\r\ndocument.body.appendChild(app.view);\r\n\r\n// Add the assets to load\r\nPIXI.Assets.add('flowerTop', 'examples/assets/flowerTop.png');\r\nPIXI.Assets.add('eggHead', 'examples/assets/eggHead.png');\r\n\r\n// Allow the assets to load in the background\r\nPIXI.Assets.backgroundLoad(['flowerTop', 'eggHead']);\r\n\r\n// If the background load hasn't loaded this asset yet, calling load forces this asset to load now.\r\nPIXI.Assets.load('eggHead').then((texture) => {\r\n    // auxiliar flag for toggling the texture\r\n    let isEggHead = true;\r\n\r\n    // create a new Sprite from the resolved loaded texture\r\n    const character = new PIXI.Sprite(texture);\r\n    character.anchor.set(0.5);\r\n    character.x = app.screen.width / 2;\r\n    character.y = app.screen.height / 2;\r\n    character.interactive = true;\r\n    character.cursor = 'pointer';\r\n\r\n    app.stage.addChild(character);\r\n\r\n    character.on('pointertap', async () => {\r\n        isEggHead = !isEggHead;\r\n        // These promise are already resolved in the cache.\r\n        character.texture = await PIXI.Assets.load(isEggHead ? 'eggHead' : 'flowerTop');\r\n    });\r\n});\r\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Bundles",
          "entry": "bundle.js",
          "path": "assets/bundle.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\r\ndocument.body.appendChild(app.view);\r\n\r\nasync function init() {\r\n    // manifest example\r\n    const manifestExample = {\r\n        bundles: [{\r\n            name: 'load-screen',\r\n            assets: [\r\n                {\r\n                    name: 'flowerTop',\r\n                    srcs: 'examples/assets/flowerTop.png',\r\n                },\r\n            ],\r\n        },\r\n        {\r\n            name: 'game-screen',\r\n            assets: [\r\n                {\r\n                    name: 'eggHead',\r\n                    srcs: 'examples/assets/eggHead.png',\r\n                },\r\n            ],\r\n        }],\r\n    };\r\n\r\n    await PIXI.Assets.init({ manifest: manifestExample });\r\n\r\n    // bundles can be loaded in the background too!\r\n    PIXI.Assets.backgroundLoadBundle(['load-screen', 'game-screen']);\r\n\r\n    makeLoadScreen();\r\n}\r\n\r\nasync function makeLoadScreen() {\r\n    // get the assets from the load screen bundle.\r\n    // If the bundle was already downloaded the promise resolves instantly!\r\n    const loadScreenAssets = await PIXI.Assets.loadBundle('load-screen');\r\n\r\n    // create a new Sprite from the resolved loaded texture\r\n    const goNext = new PIXI.Sprite(loadScreenAssets.flowerTop);\r\n    goNext.anchor.set(0.5);\r\n    goNext.x = app.screen.width / 2;\r\n    goNext.y = app.screen.height / 2;\r\n    app.stage.addChild(goNext);\r\n\r\n    goNext.interactive = true;\r\n    goNext.cursor = 'pointer';\r\n\r\n    goNext.on('pointertap', async () => {\r\n        goNext.destroy();\r\n        makeGameScreen();\r\n    });\r\n}\r\n\r\nasync function makeGameScreen() {\r\n    // Wait here until you get the assets\r\n    // If the user spends enough time in the load screen by the time they reach the game screen\r\n    // the assets are completely loaded and the promise resolves instantly!\r\n    const loadScreenAssets = await PIXI.Assets.loadBundle('game-screen');\r\n\r\n    // create a new Sprite from the resolved loaded texture\r\n    const goBack = new PIXI.Sprite(loadScreenAssets.eggHead);\r\n    goBack.anchor.set(0.5);\r\n    goBack.x = app.screen.width / 2;\r\n    goBack.y = app.screen.height / 2;\r\n    app.stage.addChild(goBack);\r\n\r\n    goBack.interactive = true;\r\n    goBack.cursor = 'pointer';\r\n\r\n    goBack.on('pointertap', async () => {\r\n        goBack.destroy();\r\n        // The user can go back and the files are already downloaded\r\n        makeLoadScreen();\r\n    });\r\n}\r\n\r\ninit();\r\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "offscreen-canvas",
      "title": "Offscreen Canvas",
      "examples": [
        {
          "title": "Basic",
          "entry": "basic.js",
          "path": "offscreen-canvas/basic.js",
          "code": "// This example is the based on demos-basic/container, but using OffscreenCanvas.\n\nconst canvas = document.createElement('canvas');\ndocument.body.appendChild(canvas);\nconst view = canvas.transferControlToOffscreen();\n\nconst app = new PIXI.Application({ view, background: 0x1099bb });\n\nconst container = new PIXI.Container();\n\napp.stage.addChild(container);\n\n// Create a new texture\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\n\n// Create a 5x5 grid of bunnies\nfor (let i = 0; i < 25; i++) {\n    const bunny = new PIXI.Sprite(texture);\n    bunny.anchor.set(0.5);\n    bunny.x = (i % 5) * 40;\n    bunny.y = Math.floor(i / 5) * 40;\n    container.addChild(bunny);\n}\n\n// Move container to the center\ncontainer.x = app.screen.width / 2;\ncontainer.y = app.screen.height / 2;\n\n// Center bunny sprite in local container coordinates\ncontainer.pivot.x = container.width / 2;\ncontainer.pivot.y = container.height / 2;\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // rotate the container!\n    // use delta to create frame-independent transform\n    container.rotation -= 0.01 * delta;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Web Worker",
          "entry": "web-worker.js",
          "path": "offscreen-canvas/web-worker.js",
          "code": "// This example is the based on demos-basic/container, but running in Web Worker.\n\nfunction workerSource(self) {\n    self.onmessage = async ({\n        data: { baseUrl, pixiWebWorkerUrl, options },\n    }) => {\n        self.importScripts(new URL(pixiWebWorkerUrl, baseUrl));\n\n        const app = new PIXI.Application(options);\n\n        const container = new PIXI.Container();\n\n        app.stage.addChild(container);\n\n        // Create a new texture\n        const textureUrl = new URL('examples/assets/bunny.png', baseUrl).toString();\n        const texture = PIXI.Texture.from(textureUrl);\n\n        // Create a 5x5 grid of bunnies\n        for (let i = 0; i < 25; i++) {\n            const bunny = new PIXI.Sprite(texture);\n            bunny.anchor.set(0.5);\n            bunny.x = (i % 5) * 40;\n            bunny.y = Math.floor(i / 5) * 40;\n            container.addChild(bunny);\n        }\n\n        // Move container to the center\n        container.x = app.screen.width / 2;\n        container.y = app.screen.height / 2;\n\n        // Center bunny sprite in local container coordinates\n        container.pivot.x = container.width / 2;\n        container.pivot.y = container.height / 2;\n\n        // Listen for animate update\n        app.ticker.add((delta) => {\n            // rotate the container!\n            // use delta to create frame-independent transform\n            container.rotation -= 0.01 * delta;\n        });\n    };\n}\nconst blob = new Blob(['(', workerSource, ')(self);'], { type: 'application/javascript' });\nconst url = URL.createObjectURL(blob);\nconst worker = new Worker(url);\nURL.revokeObjectURL(url);\n\nconst width = 800;\nconst height = 600;\nconst resolution = window.devicePixelRatio;\nconst canvas = document.createElement('canvas');\ncanvas.style.width = `${width}px`;\ncanvas.style.height = `${height}px`;\ndocument.body.appendChild(canvas);\nconst view = canvas.transferControlToOffscreen();\n\nconst baseUrl = window.location.href;\nconst pixiWebWorkerUrl = window.PIXI_WEBWORKER_URL;\nworker.postMessage({\n    baseUrl,\n    pixiWebWorkerUrl,\n    options: {\n        width, height, resolution, view, background: 0x1099bb,\n    },\n}, [view]);\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "filters-basic",
      "title": "Filters - Basic",
      "examples": [
        {
          "title": "Blur",
          "entry": "blur.js",
          "path": "filters-basic/blur.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst bg = PIXI.Sprite.from('examples/assets/pixi-filters/bg_depth_blur.jpg');\nbg.width = app.screen.width;\nbg.height = app.screen.height;\napp.stage.addChild(bg);\n\nconst littleDudes = PIXI.Sprite.from('examples/assets/pixi-filters/depth_blur_dudes.jpg');\nlittleDudes.x = (app.screen.width / 2) - 315;\nlittleDudes.y = 200;\napp.stage.addChild(littleDudes);\n\nconst littleRobot = PIXI.Sprite.from('examples/assets/pixi-filters/depth_blur_moby.jpg');\nlittleRobot.x = (app.screen.width / 2) - 200;\nlittleRobot.y = 100;\napp.stage.addChild(littleRobot);\n\nconst blurFilter1 = new PIXI.filters.BlurFilter();\nconst blurFilter2 = new PIXI.filters.BlurFilter();\n\nlittleDudes.filters = [blurFilter1];\nlittleRobot.filters = [blurFilter2];\n\nlet count = 0;\n\napp.ticker.add(() => {\n    count += 0.005;\n\n    const blurAmount = Math.cos(count);\n    const blurAmount2 = Math.sin(count);\n\n    blurFilter1.blur = 20 * (blurAmount);\n    blurFilter2.blur = 20 * (blurAmount2);\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Color Matrix",
          "entry": "color-matrix.js",
          "path": "filters-basic/color-matrix.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\napp.stage.interactive = true;\n\nconst bg = PIXI.Sprite.from('examples/assets/bg_rotate.jpg');\nbg.anchor.set(0.5);\n\nbg.x = app.screen.width / 2;\nbg.y = app.screen.height / 2;\n\nconst filter = new PIXI.filters.ColorMatrixFilter();\n\nconst container = new PIXI.Container();\ncontainer.x = app.screen.width / 2;\ncontainer.y = app.screen.height / 2;\n\nconst bgFront = PIXI.Sprite.from('examples/assets/bg_scene_rotate.jpg');\nbgFront.anchor.set(0.5);\n\ncontainer.addChild(bgFront);\n\nconst light2 = PIXI.Sprite.from('examples/assets/light_rotate_2.png');\nlight2.anchor.set(0.5);\ncontainer.addChild(light2);\n\nconst light1 = PIXI.Sprite.from('examples/assets/light_rotate_1.png');\nlight1.anchor.set(0.5);\ncontainer.addChild(light1);\n\nconst panda = PIXI.Sprite.from('examples/assets/panda.png');\npanda.anchor.set(0.5);\n\ncontainer.addChild(panda);\n\napp.stage.addChild(container);\n\napp.stage.filters = [filter];\n\nlet count = 0;\nlet enabled = true;\n\napp.stage.on('pointertap', () => {\n    enabled = !enabled;\n    app.stage.filters = enabled ? [filter] : null;\n});\n\nconst help = new PIXI.Text('Click or tap to turn filters on / off.', {\n    fontFamily: 'Arial',\n    fontSize: 12,\n    fontWeight: 'bold',\n    fill: 'white',\n});\nhelp.y = app.screen.height - 25;\nhelp.x = 10;\n\napp.stage.addChild(help);\n\napp.ticker.add((delta) => {\n    bg.rotation += 0.01;\n    bgFront.rotation -= 0.01;\n    light1.rotation += 0.02;\n    light2.rotation += 0.01;\n\n    panda.scale.x = 1 + Math.sin(count) * 0.04;\n    panda.scale.y = 1 + Math.cos(count) * 0.04;\n\n    count += 0.1;\n\n    const { matrix } = filter;\n\n    matrix[1] = Math.sin(count) * 3;\n    matrix[2] = Math.cos(count);\n    matrix[3] = Math.cos(count) * 1.5;\n    matrix[4] = Math.sin(count / 3) * 2;\n    matrix[5] = Math.sin(count / 2);\n    matrix[6] = Math.sin(count / 4);\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Displacement Map - Crawlies",
          "entry": "displacement-map-crawlies.js",
          "path": "filters-basic/displacement-map-crawlies.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\napp.stage.interactive = true;\n\nconst container = new PIXI.Container();\napp.stage.addChild(container);\n\nconst padding = 100;\nconst bounds = new PIXI.Rectangle(\n    -padding,\n    -padding,\n    app.screen.width + padding * 2,\n    app.screen.height + padding * 2,\n);\nconst maggots = [];\n\nfor (let i = 0; i < 20; i++) {\n    const maggot = PIXI.Sprite.from('examples/assets/maggot.png');\n    maggot.anchor.set(0.5);\n    container.addChild(maggot);\n\n    maggot.direction = Math.random() * Math.PI * 2;\n    maggot.speed = 1;\n    maggot.turnSpeed = Math.random() - 0.8;\n\n    maggot.x = Math.random() * bounds.width;\n    maggot.y = Math.random() * bounds.height;\n\n    maggot.scale.set(1 + Math.random() * 0.3);\n    maggot.original = new PIXI.Point();\n    maggot.original.copyFrom(maggot.scale);\n    maggots.push(maggot);\n}\n\nconst displacementSprite = PIXI.Sprite.from('examples/assets/pixi-filters/displace.png');\nconst displacementFilter = new PIXI.filters.DisplacementFilter(displacementSprite);\n\napp.stage.addChild(displacementSprite);\n\ncontainer.filters = [displacementFilter];\n\ndisplacementFilter.scale.x = 110;\ndisplacementFilter.scale.y = 110;\ndisplacementSprite.anchor.set(0.5);\n\nconst ring = PIXI.Sprite.from('examples/assets/pixi-filters/ring.png');\n\nring.anchor.set(0.5);\n\nring.visible = false;\n\napp.stage.addChild(ring);\n\nconst bg = PIXI.Sprite.from('examples/assets/bg_grass.jpg');\nbg.width = app.screen.width;\nbg.height = app.screen.height;\n\nbg.alpha = 0.4;\n\ncontainer.addChild(bg);\n\napp.stage\n    .on('mousemove', onPointerMove)\n    .on('touchmove', onPointerMove);\n\nfunction onPointerMove(eventData) {\n    ring.visible = true;\n\n    displacementSprite.position.set(eventData.data.global.x - 25, eventData.data.global.y);\n    ring.position.copyFrom(displacementSprite.position);\n}\n\nlet count = 0;\n\napp.ticker.add(() => {\n    count += 0.05;\n\n    for (let i = 0; i < maggots.length; i++) {\n        const maggot = maggots[i];\n\n        maggot.direction += maggot.turnSpeed * 0.01;\n        maggot.x += Math.sin(maggot.direction) * maggot.speed;\n        maggot.y += Math.cos(maggot.direction) * maggot.speed;\n\n        maggot.rotation = -maggot.direction - Math.PI / 2;\n        maggot.scale.x = maggot.original.x + Math.sin(count) * 0.2;\n\n        // wrap the maggots around as the crawl\n        if (maggot.x < bounds.x) {\n            maggot.x += bounds.width;\n        } else if (maggot.x > bounds.x + bounds.width) {\n            maggot.x -= bounds.width;\n        }\n\n        if (maggot.y < bounds.y) {\n            maggot.y += bounds.height;\n        } else if (maggot.y > bounds.y + bounds.height) {\n            maggot.y -= bounds.height;\n        }\n    }\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Displacement Map - Flag",
          "entry": "displacement-map-flag.js",
          "path": "filters-basic/displacement-map-flag.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\napp.stage.interactive = true;\n\nconst container = new PIXI.Container();\napp.stage.addChild(container);\n\nconst flag = PIXI.Sprite.from('examples/assets/pixi-filters/flag.png');\ncontainer.addChild(flag);\nflag.x = 100;\nflag.y = 100;\n\nconst displacementSprite = PIXI.Sprite.from('examples/assets/pixi-filters/displacement_map_repeat.jpg');\n// Make sure the sprite is wrapping.\ndisplacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;\nconst displacementFilter = new PIXI.filters.DisplacementFilter(displacementSprite);\ndisplacementFilter.padding = 10;\n\ndisplacementSprite.position = flag.position;\n\napp.stage.addChild(displacementSprite);\n\nflag.filters = [displacementFilter];\n\ndisplacementFilter.scale.x = 30;\ndisplacementFilter.scale.y = 60;\n\napp.ticker.add(() => {\n    // Offset the sprite position to make vFilterCoord update to larger value. Repeat wrapping makes sure there's still pixels on the coordinates.\n    displacementSprite.x++;\n    // Reset x to 0 when it's over width to keep values from going to very huge numbers.\n    if (displacementSprite.x > displacementSprite.width) { displacementSprite.x = 0; }\n});\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "filters-advanced",
      "title": "Filters - Advanced",
      "examples": [
        {
          "title": "Mouse Blending",
          "entry": "mouse-blending.js",
          "path": "filters-advanced/mouse-blending.js",
          "code": "/**\n * https://github.com/pixijs/pixi.js/wiki/v5-Creating-Filters\n */\n\nconst app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// Create background image\nconst background = PIXI.Sprite.from('examples/assets/bg_grass.jpg');\nbackground.width = app.screen.width;\nbackground.height = app.screen.height;\napp.stage.addChild(background);\n\n// NOTE: this shader wont work on old devices where mediump precision is forced in fragment shader\n// because v5 default vertex shader uses `inputSize` in it. Same uniform in fragment and vertex shader\n// cant have different precision :(\n\nconst shaderFrag = `\nprecision highp float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 mouse;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform float time;\n\nvoid main() {\n  vec2 screenPos = vTextureCoord * inputSize.xy + outputFrame.xy;\n  if (length(mouse - screenPos) < 25.0) {\n      gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0) * 0.7; //yellow circle, alpha=0.7\n  } else {\n      gl_FragColor = vec4( sin(time), (mouse.xy - outputFrame.xy) / outputFrame.zw, 1.0) * 0.5; // blend with underlying image, alpha=0.5\n  }\n}\n`;\n\nconst container = new PIXI.Container();\ncontainer.filterArea = new PIXI.Rectangle(100, 100, app.screen.width - 200, app.screen.height - 200);\napp.stage.addChild(container);\nconst filter = new PIXI.Filter(null, shaderFrag, {\n    mouse: new PIXI.Point(),\n});\ncontainer.filters = [filter];\n\napp.stage.hitArea = app.screen;\napp.stage.interactive = true;\napp.stage.on('pointermove', (event) => {\n    filter.uniforms.mouse.copyFrom(event.global);\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Custom Filter",
          "entry": "custom.js",
          "path": "filters-advanced/custom.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// Create background image\nconst background = PIXI.Sprite.from('examples/assets/bg_grass.jpg');\nbackground.width = app.screen.width;\nbackground.height = app.screen.height;\napp.stage.addChild(background);\n\n// Stop application wait for load to finish\napp.stop();\n\nfetch('examples/assets/pixi-filters/shader.frag')\n    .then((res) => res.text())\n    .then(onLoaded);\n\nlet filter;\n\n// Handle the load completed\nfunction onLoaded(data) {\n    // Create the new filter, arguments: (vertexShader, framentSource)\n    filter = new PIXI.Filter(null, data, {\n        customUniform: 0.0,\n    });\n\n    // === WARNING ===\n    // specify uniforms in filter constructor\n    // or set them BEFORE first use\n    // filter.uniforms.customUniform = 0.0\n\n    // Add the filter\n    background.filters = [filter];\n\n    // Resume application update\n    app.start();\n}\n\n// Animate the filter\napp.ticker.add((delta) => {\n    filter.uniforms.customUniform += 0.04 * delta;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Pixie Shadow",
          "entry": "pixie-shadow-filter.js",
          "path": "filters-advanced/pixie-shadow-filter.js",
          "code": "const app = new PIXI.Application({\n    autoStart: false,\n    background: '#1099bb',\n});\ndocument.body.appendChild(app.view);\n\napp.stage.hitArea = app.screen;\napp.stage.interactive = true;\n\nPIXI.Assets.load('examples/assets/pixi-spine/pixie.json').then(onAssetsLoaded);\n\nfunction onAssetsLoaded(spritesheet) {\n    const pixie = new PIXI.spine.Spine(spritesheet.spineData);\n\n    const scale = 0.3;\n\n    pixie.x = 1024 / 3;\n    pixie.y = 500;\n\n    pixie.scale.x = pixie.scale.y = scale;\n\n    app.stage.addChild(pixie);\n\n    pixie.stateData.setMix('running', 'jump', 0.2);\n    pixie.stateData.setMix('jump', 'running', 0.4);\n\n    pixie.state.setAnimation(0, 'running', true);\n\n    app.stage.on('pointerdown', onTouchStart);\n\n    function onTouchStart() {\n        pixie.state.setAnimation(0, 'jump', false);\n        pixie.state.addAnimation(0, 'running', true, 0);\n    }\n\n    const filter = new PIXI.Filter(myVertex, myFragment);\n    // first is the horizontal shift, positive is to the right\n    // second is the same as scaleY\n    filter.uniforms.shadowDirection = [0.4, 0.5];\n    filter.uniforms.floorY = 0.0;\n    // how big is max shadow shift to the side?\n    // try to switch that off ;)\n    filter.padding = 100;\n\n    pixie.filters = [filter];\n\n    app.ticker.add(() => {\n        // take ground Y in screen coords to uniforms\n        filter.uniforms.floorY = pixie.toGlobal(new PIXI.Point(0, 0)).y;\n    });\n\n    app.start();\n}\n\n// That's default v4 vertex shader, just in case\nconst myVertex = `\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}\n`;\n\nconst myFragment = `\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform vec2 shadowDirection;\nuniform float floorY;\n\nvoid main(void) {\n    //1. get the screen coordinate\n    vec2 screenCoord = vTextureCoord * inputSize.xy + outputFrame.xy;\n    //2. calculate Y shift of our dimension vector\n    vec2 shadow;\n    //shadow coordinate system is a bit skewed, but it has to be the same for screenCoord.y = floorY\n    float paramY = (screenCoord.y - floorY) / shadowDirection.y;\n    shadow.y = paramY + floorY;\n    shadow.x = screenCoord.x + paramY * shadowDirection.x;\n    vec2 bodyFilterCoord = (shadow - outputFrame.xy) * inputSize.zw; // same as / inputSize.xy\n\n    vec4 originalColor = texture2D(uSampler, vTextureCoord);\n    vec4 shadowColor = texture2D(uSampler, bodyFilterCoord);\n    shadowColor.rgb = vec3(0.0);\n    shadowColor.a *= 0.5;\n\n    // normal blend mode coefficients (1, 1-src_alpha)\n    // shadow is destination (backdrop), original is source\n    gl_FragColor = originalColor + shadowColor * (1.0 - originalColor.a);\n}\n`;\n",
          "exists": true,
          "plugins": [
            "pixi-spine"
          ]
        },
        {
          "title": "Shadertoy filter",
          "entry": "shadertoy-filter-rendertexture.js",
          "path": "filters-advanced/shadertoy-filter-rendertexture.js",
          "code": "/**\nPlease note that this is not the most optimal way of doing pure shader generated rendering and should be used when scene is wanted as input texture.\nCheck the mesh version of example for more performant version if you need only shader generated content.\n* */\n\nconst app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('examples/assets/perlin.jpg').then(onAssetsLoaded);\n\nlet filter = null;\n\nconst text = new PIXI.Text('PixiJS', { fill: 0xFFFFFF, fontSize: 80 });\ntext.anchor.set(0.5, 0.5);\ntext.position.set(app.renderer.screen.width / 2, app.renderer.screen.height / 2);\n\napp.stage.addChild(text);\n\nlet totalTime = 0;\n\n// Fragment shader, in real use this would be much cleaner when loaded from a file/embedded into the application as data resource.\nconst fragment = `//Based on this: https://www.shadertoy.com/view/wtlSWX\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D noise;\nuniform float time;\n//Distance function. Just calculates the height (z) from x,y plane with really simple length check. Its not exact as there could be shorter distances.\nvec2 dist(vec3 p)\n{\n  float id = floor(p.x)+floor(p.y);\n  id = mod(id, 2.);\n  float h = texture2D(noise, vec2(p.x, p.y)*0.04).r*5.1;\n  float h2 = texture2D(uSampler, vTextureCoord).r;\n  return vec2(h+h2-p.z,id);\n}\n//Light calculation.\nvec3 calclight(vec3 p, vec3 rd)\n{\n  vec2 eps = vec2( 0., 0.001);\n  vec3 n = normalize( vec3(\n    dist(p+eps.yxx).x - dist(p-eps.yxx).x,\n    dist(p+eps.xyx).x - dist(p-eps.xyx).x,\n    dist(p+eps.xxy).x - dist(p-eps.xxy).x\n  ));\n  \n  vec3 d = vec3( max( 0., dot( -rd ,n)));\n  \n  return d;\n}\n\nvoid main()\n{\n  vec2 uv = vec2(vTextureCoord.x, 1.-vTextureCoord.y);\n  uv *=2.;\n  uv-=1.;\n  \n  vec3 cam = vec3(0.,time -2., -3.);\n  vec3 target = vec3(sin(time)*0.1, time+cos(time)+2., 0. );\n  float fov = 2.2;\n  vec3 forward = normalize( target - cam);\n  vec3 up = normalize(cross( forward, vec3(0., 1.,0.)));\n  vec3 right = normalize( cross( up, forward));\n  vec3 raydir = normalize(vec3( uv.x *up + uv.y * right + fov*forward));\n  \n  //Do the raymarch\n  vec3 col = vec3(0.);\n  float t = 0.;\n  for( int i = 0; i < 100; i++)\n  {\n    vec3 p = t * raydir + cam;\n    vec2 d = dist(p);\n    t+=d.x*0.5;//Jump only half of the distance as height function used is not really the best for heightmaps.\n    if(d.x < 0.001)\n    {\n      vec3 bc = d.y < 0.5 ? vec3(1.0, .8, 0.) :\n                vec3(0.8,0.0, 1.0);\n      col = vec3( 1.) * calclight(p, raydir) * (1. - t/150.) *bc;\n      break;\n    }\n    if(t > 1000.)\n    {\n      break;\n    }\n  }\n  gl_FragColor = vec4(col, 1.);\n}\n`;\n\nfunction onAssetsLoaded(perlin) {\n    // Add perlin noise for filter, make sure it's wrapping and does not have mipmap.\n    perlin.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;\n    perlin.baseTexture.mipmap = false;\n    perlin.width = perlin.height = 200;\n\n    // Build the filter\n    filter = new PIXI.Filter(null, fragment, {\n        time: 0.0,\n        noise: perlin,\n    });\n    app.stage.filterArea = app.renderer.screen;\n    app.stage.filters = [filter];\n\n    // Listen for animate update.\n    app.ticker.add((delta) => {\n        filter.uniforms.time = totalTime;\n        totalTime += delta / 60;\n    });\n}\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "plugin-filters",
      "title": "Plugin Filters",
      "examples": [
        {
          "title": "Outline",
          "entry": "outline.js",
          "path": "plugin-filters/outline.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\napp.stage.position.set(400, 300);\n\nconst outlineFilterGreen = new PIXI.filters.OutlineFilter(2, 0x99ff99);\nconst outlineFilterRed = new PIXI.filters.GlowFilter(15, 2, 1, 0xff9999, 0.5);\n\nfunction filterOn() {\n    this.filters = [outlineFilterRed];\n}\n\nfunction filterOff() {\n    this.filters = [outlineFilterGreen];\n}\n\nfor (let i = 0; i < 20; i++) {\n    const bunny = PIXI.Sprite.from('examples/assets/bunny.png');\n    bunny.interactive = true;\n    bunny.position.set((Math.random() * 2 - 1) * 300 | 0, (Math.random() * 2 - 1) * 200 | 0);\n    bunny.scale.x = (Math.random() * 3 | 0 * 0.1) + 1;\n    bunny.on('pointerover', filterOn)\n        .on('pointerout', filterOff);\n    filterOff.call(bunny);\n    app.stage.addChild(bunny);\n}\n",
          "exists": true,
          "plugins": [
            "pixi-filters"
          ]
        }
      ]
    },
    {
      "id": "demos-advanced",
      "title": "Advanced Demos",
      "examples": [
        {
          "title": "Slots",
          "entry": "slots.js",
          "path": "demos-advanced/slots.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load([\n    'examples/assets/eggHead.png',\n    'examples/assets/flowerTop.png',\n    'examples/assets/helmlok.png',\n    'examples/assets/skully.png',\n]).then(onAssetsLoaded);\n\nconst REEL_WIDTH = 160;\nconst SYMBOL_SIZE = 150;\n\n// onAssetsLoaded handler builds the example.\nfunction onAssetsLoaded() {\n    // Create different slot symbols.\n    const slotTextures = [\n        PIXI.Texture.from('examples/assets/eggHead.png'),\n        PIXI.Texture.from('examples/assets/flowerTop.png'),\n        PIXI.Texture.from('examples/assets/helmlok.png'),\n        PIXI.Texture.from('examples/assets/skully.png'),\n    ];\n\n    // Build the reels\n    const reels = [];\n    const reelContainer = new PIXI.Container();\n    for (let i = 0; i < 5; i++) {\n        const rc = new PIXI.Container();\n        rc.x = i * REEL_WIDTH;\n        reelContainer.addChild(rc);\n\n        const reel = {\n            container: rc,\n            symbols: [],\n            position: 0,\n            previousPosition: 0,\n            blur: new PIXI.filters.BlurFilter(),\n        };\n        reel.blur.blurX = 0;\n        reel.blur.blurY = 0;\n        rc.filters = [reel.blur];\n\n        // Build the symbols\n        for (let j = 0; j < 4; j++) {\n            const symbol = new PIXI.Sprite(slotTextures[Math.floor(Math.random() * slotTextures.length)]);\n            // Scale the symbol to fit symbol area.\n            symbol.y = j * SYMBOL_SIZE;\n            symbol.scale.x = symbol.scale.y = Math.min(SYMBOL_SIZE / symbol.width, SYMBOL_SIZE / symbol.height);\n            symbol.x = Math.round((SYMBOL_SIZE - symbol.width) / 2);\n            reel.symbols.push(symbol);\n            rc.addChild(symbol);\n        }\n        reels.push(reel);\n    }\n    app.stage.addChild(reelContainer);\n\n    // Build top & bottom covers and position reelContainer\n    const margin = (app.screen.height - SYMBOL_SIZE * 3) / 2;\n    reelContainer.y = margin;\n    reelContainer.x = Math.round(app.screen.width - REEL_WIDTH * 5);\n    const top = new PIXI.Graphics();\n    top.beginFill(0, 1);\n    top.drawRect(0, 0, app.screen.width, margin);\n    const bottom = new PIXI.Graphics();\n    bottom.beginFill(0, 1);\n    bottom.drawRect(0, SYMBOL_SIZE * 3 + margin, app.screen.width, margin);\n\n    // Add play text\n    const style = new PIXI.TextStyle({\n        fontFamily: 'Arial',\n        fontSize: 36,\n        fontStyle: 'italic',\n        fontWeight: 'bold',\n        fill: ['#ffffff', '#00ff99'], // gradient\n        stroke: '#4a1850',\n        strokeThickness: 5,\n        dropShadow: true,\n        dropShadowColor: '#000000',\n        dropShadowBlur: 4,\n        dropShadowAngle: Math.PI / 6,\n        dropShadowDistance: 6,\n        wordWrap: true,\n        wordWrapWidth: 440,\n    });\n\n    const playText = new PIXI.Text('Spin the wheels!', style);\n    playText.x = Math.round((bottom.width - playText.width) / 2);\n    playText.y = app.screen.height - margin + Math.round((margin - playText.height) / 2);\n    bottom.addChild(playText);\n\n    // Add header text\n    const headerText = new PIXI.Text('PIXI MONSTER SLOTS!', style);\n    headerText.x = Math.round((top.width - headerText.width) / 2);\n    headerText.y = Math.round((margin - headerText.height) / 2);\n    top.addChild(headerText);\n\n    app.stage.addChild(top);\n    app.stage.addChild(bottom);\n\n    // Set the interactivity.\n    bottom.interactive = true;\n    bottom.cursor = 'pointer';\n    bottom.addListener('pointerdown', () => {\n        startPlay();\n    });\n\n    let running = false;\n\n    // Function to start playing.\n    function startPlay() {\n        if (running) return;\n        running = true;\n\n        for (let i = 0; i < reels.length; i++) {\n            const r = reels[i];\n            const extra = Math.floor(Math.random() * 3);\n            const target = r.position + 10 + i * 5 + extra;\n            const time = 2500 + i * 600 + extra * 600;\n            tweenTo(r, 'position', target, time, backout(0.5), null, i === reels.length - 1 ? reelsComplete : null);\n        }\n    }\n\n    // Reels done handler.\n    function reelsComplete() {\n        running = false;\n    }\n\n    // Listen for animate update.\n    app.ticker.add((delta) => {\n    // Update the slots.\n        for (let i = 0; i < reels.length; i++) {\n            const r = reels[i];\n            // Update blur filter y amount based on speed.\n            // This would be better if calculated with time in mind also. Now blur depends on frame rate.\n            r.blur.blurY = (r.position - r.previousPosition) * 8;\n            r.previousPosition = r.position;\n\n            // Update symbol positions on reel.\n            for (let j = 0; j < r.symbols.length; j++) {\n                const s = r.symbols[j];\n                const prevy = s.y;\n                s.y = ((r.position + j) % r.symbols.length) * SYMBOL_SIZE - SYMBOL_SIZE;\n                if (s.y < 0 && prevy > SYMBOL_SIZE) {\n                    // Detect going over and swap a texture.\n                    // This should in proper product be determined from some logical reel.\n                    s.texture = slotTextures[Math.floor(Math.random() * slotTextures.length)];\n                    s.scale.x = s.scale.y = Math.min(SYMBOL_SIZE / s.texture.width, SYMBOL_SIZE / s.texture.height);\n                    s.x = Math.round((SYMBOL_SIZE - s.width) / 2);\n                }\n            }\n        }\n    });\n}\n\n// Very simple tweening utility function. This should be replaced with a proper tweening library in a real product.\nconst tweening = [];\nfunction tweenTo(object, property, target, time, easing, onchange, oncomplete) {\n    const tween = {\n        object,\n        property,\n        propertyBeginValue: object[property],\n        target,\n        easing,\n        time,\n        change: onchange,\n        complete: oncomplete,\n        start: Date.now(),\n    };\n\n    tweening.push(tween);\n    return tween;\n}\n// Listen for animate update.\napp.ticker.add((delta) => {\n    const now = Date.now();\n    const remove = [];\n    for (let i = 0; i < tweening.length; i++) {\n        const t = tweening[i];\n        const phase = Math.min(1, (now - t.start) / t.time);\n\n        t.object[t.property] = lerp(t.propertyBeginValue, t.target, t.easing(phase));\n        if (t.change) t.change(t);\n        if (phase === 1) {\n            t.object[t.property] = t.target;\n            if (t.complete) t.complete(t);\n            remove.push(t);\n        }\n    }\n    for (let i = 0; i < remove.length; i++) {\n        tweening.splice(tweening.indexOf(remove[i]), 1);\n    }\n});\n\n// Basic lerp funtion.\nfunction lerp(a1, a2, t) {\n    return a1 * (1 - t) + a2 * t;\n}\n\n// Backout function from tweenjs.\n// https://github.com/CreateJS/TweenJS/blob/master/src/tweenjs/Ease.js\nfunction backout(amount) {\n    return (t) => (--t * t * ((amount + 1) * t + amount) + 1);\n}\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Scratchcard",
          "entry": "scratchcard.js",
          "path": "demos-advanced/scratchcard.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// prepare circle texture, that will be our brush\nconst brush = new PIXI.Graphics()\n    .beginFill(0xffffff)\n    .drawCircle(0, 0, 50);\n\n// Create a line that will interpolate the drawn points\nconst line = new PIXI.Graphics();\n\nPIXI.Assets.add('t1', 'examples/assets/bg_grass.jpg');\nPIXI.Assets.add('t2', 'examples/assets/bg_rotate.jpg');\nPIXI.Assets.load(['t1', 't2']).then(setup);\n\nfunction setup() {\n    const { width, height } = app.screen;\n    const stageSize = { width, height };\n\n    const background = Object.assign(PIXI.Sprite.from('t1'), stageSize);\n    const imageToReveal = Object.assign(PIXI.Sprite.from('t2'), stageSize);\n    const renderTexture = PIXI.RenderTexture.create(stageSize);\n    const renderTextureSprite = new PIXI.Sprite(renderTexture);\n\n    imageToReveal.mask = renderTextureSprite;\n\n    app.stage.addChild(\n        background,\n        imageToReveal,\n        renderTextureSprite,\n    );\n\n    app.stage.interactive = true;\n    app.stage.hitArea = app.screen;\n    app.stage\n        .on('pointerdown', pointerDown)\n        .on('pointerup', pointerUp)\n        .on('pointerupoutside', pointerUp)\n        .on('pointermove', pointerMove);\n\n    let dragging = false;\n    let lastDrawnPoint = null;\n    function pointerMove({ global: { x, y } }) {\n        if (dragging) {\n            brush.position.set(x, y);\n            app.renderer.render(brush, {\n                renderTexture,\n                clear: false,\n                skipUpdateTransform: false,\n            });\n            // Smooth out the drawing a little bit to make it look nicer\n            // this connects the previous drawn point to the current one\n            // using a line\n            if (lastDrawnPoint) {\n                line\n                    .clear()\n                    .lineStyle({ width: 100, color: 0xffffff })\n                    .moveTo(lastDrawnPoint.x, lastDrawnPoint.y)\n                    .lineTo(x, y);\n                app.renderer.render(line, {\n                    renderTexture,\n                    clear: false,\n                    skipUpdateTransform: false,\n                });\n            }\n            lastDrawnPoint = lastDrawnPoint || new PIXI.Point();\n            lastDrawnPoint.set(x, y);\n        }\n    }\n\n    function pointerDown(event) {\n        dragging = true;\n        pointerMove(event);\n    }\n\n    function pointerUp(event) {\n        dragging = false;\n        lastDrawnPoint = null;\n    }\n}\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Mouse Trail",
          "entry": "mouse-trail.js",
          "path": "demos-advanced/mouse-trail.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// Get the texture for rope.\nconst trailTexture = PIXI.Texture.from('examples/assets/trail.png');\nconst historyX = [];\nconst historyY = [];\n// historySize determines how long the trail will be.\nconst historySize = 20;\n// ropeSize determines how smooth the trail will be.\nconst ropeSize = 100;\nconst points = [];\n\n// Create history array.\nfor (let i = 0; i < historySize; i++) {\n    historyX.push(0);\n    historyY.push(0);\n}\n// Create rope points.\nfor (let i = 0; i < ropeSize; i++) {\n    points.push(new PIXI.Point(0, 0));\n}\n\n// Create the rope\nconst rope = new PIXI.SimpleRope(trailTexture, points);\n\n// Set the blendmode\nrope.blendmode = PIXI.BLEND_MODES.ADD;\n\napp.stage.addChild(rope);\n\nconsole.log('HELLO!');\n\nlet mouseposition = null;\napp.stage.interactive = true;\napp.stage.hitArea = app.screen;\napp.stage.on('mousemove', (event) => {\n    mouseposition = mouseposition || { x: 0, y: 0 };\n    mouseposition.x = event.global.x;\n    mouseposition.y = event.global.y;\n});\n\n// Listen for animate update\napp.ticker.add(() => {\n    if (!mouseposition) return;\n\n    // Update the mouse values to history\n    historyX.pop();\n    historyX.unshift(mouseposition.x);\n    historyY.pop();\n    historyY.unshift(mouseposition.y);\n    // Update the points to correspond with history.\n    for (let i = 0; i < ropeSize; i++) {\n        const p = points[i];\n\n        // Smooth the curve with cubic interpolation to prevent sharp edges.\n        const ix = cubicInterpolation(historyX, i / ropeSize * historySize);\n        const iy = cubicInterpolation(historyY, i / ropeSize * historySize);\n\n        p.x = ix;\n        p.y = iy;\n    }\n});\n\n/**\n * Cubic interpolation based on https://github.com/osuushi/Smooth.js\n */\nfunction clipInput(k, arr) {\n    if (k < 0) k = 0;\n    if (k > arr.length - 1) k = arr.length - 1;\n    return arr[k];\n}\n\nfunction getTangent(k, factor, array) {\n    return factor * (clipInput(k + 1, array) - clipInput(k - 1, array)) / 2;\n}\n\nfunction cubicInterpolation(array, t, tangentFactor) {\n    if (tangentFactor == null) tangentFactor = 1;\n\n    const k = Math.floor(t);\n    const m = [getTangent(k, tangentFactor, array), getTangent(k + 1, tangentFactor, array)];\n    const p = [clipInput(k, array), clipInput(k + 1, array)];\n    t -= k;\n    const t2 = t * t;\n    const t3 = t * t2;\n    return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];\n}\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Star Warp",
          "entry": "star-warp.js",
          "path": "demos-advanced/star-warp.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// Get the texture for star.\nconst starTexture = PIXI.Texture.from('examples/assets/star.png');\n\nconst starAmount = 1000;\nlet cameraZ = 0;\nconst fov = 20;\nconst baseSpeed = 0.025;\nlet speed = 0;\nlet warpSpeed = 0;\nconst starStretch = 5;\nconst starBaseSize = 0.05;\n\n// Create the stars\nconst stars = [];\nfor (let i = 0; i < starAmount; i++) {\n    const star = {\n        sprite: new PIXI.Sprite(starTexture),\n        z: 0,\n        x: 0,\n        y: 0,\n    };\n    star.sprite.anchor.x = 0.5;\n    star.sprite.anchor.y = 0.7;\n    randomizeStar(star, true);\n    app.stage.addChild(star.sprite);\n    stars.push(star);\n}\n\nfunction randomizeStar(star, initial) {\n    star.z = initial ? Math.random() * 2000 : cameraZ + Math.random() * 1000 + 2000;\n\n    // Calculate star positions with radial random coordinate so no star hits the camera.\n    const deg = Math.random() * Math.PI * 2;\n    const distance = Math.random() * 50 + 1;\n    star.x = Math.cos(deg) * distance;\n    star.y = Math.sin(deg) * distance;\n}\n\n// Change flight speed every 5 seconds\nsetInterval(() => {\n    warpSpeed = warpSpeed > 0 ? 0 : 1;\n}, 5000);\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // Simple easing. This should be changed to proper easing function when used for real.\n    speed += (warpSpeed - speed) / 20;\n    cameraZ += delta * 10 * (speed + baseSpeed);\n    for (let i = 0; i < starAmount; i++) {\n        const star = stars[i];\n        if (star.z < cameraZ) randomizeStar(star);\n\n        // Map star 3d position to 2d with really simple projection\n        const z = star.z - cameraZ;\n        star.sprite.x = star.x * (fov / z) * app.renderer.screen.width + app.renderer.screen.width / 2;\n        star.sprite.y = star.y * (fov / z) * app.renderer.screen.width + app.renderer.screen.height / 2;\n\n        // Calculate star scale & rotation.\n        const dxCenter = star.sprite.x - app.renderer.screen.width / 2;\n        const dyCenter = star.sprite.y - app.renderer.screen.height / 2;\n        const distanceCenter = Math.sqrt(dxCenter * dxCenter + dyCenter * dyCenter);\n        const distanceScale = Math.max(0, (2000 - z) / 2000);\n        star.sprite.scale.x = distanceScale * starBaseSize;\n        // Star is looking towards center so that y axis is towards center.\n        // Scale the star depending on how fast we are moving, what the stretchfactor is and depending on how far away it is from the center.\n        star.sprite.scale.y = distanceScale * starBaseSize + distanceScale * speed * starStretch * distanceCenter / app.renderer.screen.width;\n        star.sprite.rotation = Math.atan2(dyCenter, dxCenter) + Math.PI / 2;\n    }\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Screenshot",
          "entry": "screenshot.js",
          "path": "demos-advanced/screenshot.js",
          "code": "const app = new PIXI.Application({ backgroundColor: '#111' });\ndocument.body.appendChild(app.view);\n\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\nconst bunnyContainer = new PIXI.Container();\n\nasync function takeScreenshot() {\n    app.stop();\n    const url = await app.renderer.extract.base64(bunnyContainer);\n    const a = document.createElement('a');\n    document.body.append(a);\n    a.download = 'screenshot';\n    a.href = url;\n    a.click();\n    a.remove();\n    app.start();\n}\n\napp.stage.interactive = true;\napp.stage.hitArea = app.screen;\napp.stage.on('pointerdown', takeScreenshot);\n\nfor (let i = 0; i < 25; i++) {\n    const bunny = new PIXI.Sprite(texture);\n    bunny.anchor.set(0.5);\n    bunny.x = (i % 5) * 40;\n    bunny.y = Math.floor(i / 5) * 40;\n    bunnyContainer.addChild(bunny);\n}\n\nbunnyContainer.x = 400;\nbunnyContainer.y = 300;\nbunnyContainer.pivot.x = bunnyContainer.width / 2;\nbunnyContainer.pivot.y = bunnyContainer.height / 2;\n\napp.ticker.add((delta) => {\n    bunnyContainer.rotation += 0.01 * delta;\n});\n\nconst style = new PIXI.TextStyle({\n    fontFamily: 'Roboto',\n    fill: '#999',\n});\n\nconst screenshotText = new PIXI.Text('Click To Take Screenshot', style);\nscreenshotText.x = Math.round((app.screen.width - screenshotText.width) / 2);\nscreenshotText.y = Math.round(screenshotText.height / 2);\n\napp.stage.addChild(screenshotText, bunnyContainer);\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Collision",
          "entry": "collision-detection.js",
          "path": "demos-advanced/collision-detection.js",
          "code": "// Based somewhat on this article by Spicy Yoghurt\n// URL for further reading: https://spicyyoghurt.com/tutorials/html5-javascript-game-development/collision-detection-physics\nconst app = new PIXI.Application({ background: '#111' });\ndocument.body.appendChild(app.view);\n\n// Options for how objects interact\n// How fast the red square moves\nconst movementSpeed = 0.05;\n\n// Strength of the impulse push between two objects\nconst impulsePower = 5;\n\n// Test For Hit\n// A basic AABB check between two different squares\nfunction testForAABB(object1, object2) {\n    const bounds1 = object1.getBounds();\n    const bounds2 = object2.getBounds();\n\n    return bounds1.x < bounds2.x + bounds2.width\n        && bounds1.x + bounds1.width > bounds2.x\n        && bounds1.y < bounds2.y + bounds2.height\n        && bounds1.y + bounds1.height > bounds2.y;\n}\n\n// Calculates the results of a collision, allowing us to give an impulse that\n// shoves objects apart\nfunction collisionResponse(object1, object2) {\n    if (!object1 || !object2) {\n        return new PIXI.Point(0);\n    }\n\n    const vCollision = new PIXI.Point(\n        object2.x - object1.x,\n        object2.y - object1.y,\n    );\n\n    const distance = Math.sqrt(\n        (object2.x - object1.x) * (object2.x - object1.x)\n        + (object2.y - object1.y) * (object2.y - object1.y),\n    );\n\n    const vCollisionNorm = new PIXI.Point(\n        vCollision.x / distance,\n        vCollision.y / distance,\n    );\n\n    const vRelativeVelocity = new PIXI.Point(\n        object1.acceleration.x - object2.acceleration.x,\n        object1.acceleration.y - object2.acceleration.y,\n    );\n\n    const speed = vRelativeVelocity.x * vCollisionNorm.x\n        + vRelativeVelocity.y * vCollisionNorm.y;\n\n    const impulse = impulsePower * speed / (object1.mass + object2.mass);\n\n    return new PIXI.Point(\n        impulse * vCollisionNorm.x,\n        impulse * vCollisionNorm.y,\n    );\n}\n\n// Calculate the distance between two given points\nfunction distanceBetweenTwoPoints(p1, p2) {\n    const a = p1.x - p2.x;\n    const b = p1.y - p2.y;\n\n    return Math.hypot(a, b);\n}\n\n// The green square we will knock about\nconst greenSquare = new PIXI.Sprite(PIXI.Texture.WHITE);\ngreenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\ngreenSquare.width = 100;\ngreenSquare.height = 100;\ngreenSquare.tint = 0x00FF00;\ngreenSquare.acceleration = new PIXI.Point(0);\ngreenSquare.mass = 3;\n\n// The square you move around\nconst redSquare = new PIXI.Sprite(PIXI.Texture.WHITE);\nredSquare.position.set(0, 0);\nredSquare.width = 100;\nredSquare.height = 100;\nredSquare.tint = 0xFF0000;\nredSquare.acceleration = new PIXI.Point(0);\nredSquare.mass = 1;\n\nconst mouseCoords = { x: 0, y: 0 };\napp.stage.interactive = true;\napp.stage.hitArea = app.screen;\napp.stage.on('mousemove', (event) => {\n    mouseCoords.x = event.global.x;\n    mouseCoords.y = event.global.y;\n});\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // Applied deacceleration for both squares, done by reducing the\n    // acceleration by 0.01% of the acceleration every loop\n    redSquare.acceleration.set(redSquare.acceleration.x * 0.99, redSquare.acceleration.y * 0.99);\n    greenSquare.acceleration.set(greenSquare.acceleration.x * 0.99, greenSquare.acceleration.y * 0.99);\n\n    // Check whether the green square ever moves off the screen\n    // If so, reverse acceleration in that direction\n    if (greenSquare.x < 0 || greenSquare.x > (app.screen.width - 100)) {\n        greenSquare.acceleration.x = -greenSquare.acceleration.x;\n    }\n\n    if (greenSquare.y < 0 || greenSquare.y > (app.screen.height - 100)) {\n        greenSquare.acceleration.y = -greenSquare.acceleration.y;\n    }\n\n    // If the green square pops out of the cordon, it pops back into the\n    // middle\n    if ((greenSquare.x < -30 || greenSquare.x > (app.screen.width + 30))\n        || greenSquare.y < -30 || greenSquare.y > (app.screen.height + 30)) {\n        greenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\n    }\n\n    // If the mouse is off screen, then don't update any further\n    if (app.screen.width > mouseCoords.x || mouseCoords.x > 0\n        || app.screen.height > mouseCoords.y || mouseCoords.y > 0) {\n        // Get the red square's center point\n        const redSquareCenterPosition = new PIXI.Point(\n            redSquare.x + (redSquare.width * 0.5),\n            redSquare.y + (redSquare.height * 0.5),\n        );\n\n        // Calculate the direction vector between the mouse pointer and\n        // the red square\n        const toMouseDirection = new PIXI.Point(\n            mouseCoords.x - redSquareCenterPosition.x,\n            mouseCoords.y - redSquareCenterPosition.y,\n        );\n\n        // Use the above to figure out the angle that direction has\n        const angleToMouse = Math.atan2(\n            toMouseDirection.y,\n            toMouseDirection.x,\n        );\n\n        // Figure out the speed the square should be travelling by, as a\n        // function of how far away from the mouse pointer the red square is\n        const distMouseRedSquare = distanceBetweenTwoPoints(\n            mouseCoords,\n            redSquareCenterPosition,\n        );\n        const redSpeed = distMouseRedSquare * movementSpeed;\n\n        // Calculate the acceleration of the red square\n        redSquare.acceleration.set(\n            Math.cos(angleToMouse) * redSpeed,\n            Math.sin(angleToMouse) * redSpeed,\n        );\n    }\n\n    // If the two squares are colliding\n    if (testForAABB(greenSquare, redSquare)) {\n        // Calculate the changes in acceleration that should be made between\n        // each square as a result of the collision\n        const collisionPush = collisionResponse(greenSquare, redSquare);\n        // Set the changes in acceleration for both squares\n        redSquare.acceleration.set(\n            (collisionPush.x * greenSquare.mass),\n            (collisionPush.y * greenSquare.mass),\n        );\n        greenSquare.acceleration.set(\n            -(collisionPush.x * redSquare.mass),\n            -(collisionPush.y * redSquare.mass),\n        );\n    }\n\n    greenSquare.x += greenSquare.acceleration.x * delta;\n    greenSquare.y += greenSquare.acceleration.y * delta;\n\n    redSquare.x += redSquare.acceleration.x * delta;\n    redSquare.y += redSquare.acceleration.y * delta;\n});\n\n// Add to stage\napp.stage.addChild(redSquare, greenSquare);\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Spinners",
          "entry": "spinners.js",
          "path": "demos-advanced/spinners.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n/* ---------------------------------------\n Spinner 1. Square with radial completion.\n -------------------------------------- */\nconst generateSpinner1 = (position) => {\n    const container = new PIXI.Container();\n    container.position = position;\n    app.stage.addChild(container);\n\n    const base = PIXI.Sprite.from('examples/assets/bg_scene_rotate.jpg');\n    const size = 100;\n    base.width = size;\n    base.height = size;\n\n    const bottom = PIXI.Sprite.from('examples/assets/bg_rotate.jpg');\n    bottom.width = size;\n    bottom.height = size;\n\n    const mask = new PIXI.Graphics();\n    mask.position.set(size / 2, size / 2);\n    base.mask = mask;\n    window.mask = mask;\n\n    container.addChild(bottom);\n    container.addChild(base);\n    container.addChild(mask);\n\n    let phase = 0;\n    return (delta) => {\n        // Update phase\n        phase += delta / 60;\n        phase %= (Math.PI * 2);\n\n        // Calculate target point.\n        const x = Math.cos(phase - Math.PI / 2) * size;\n        const y = Math.sin(phase - Math.PI / 2) * size;\n\n        const segments = [\n            [-size / 2, -size / 2, size / 2, -size / 2], // top segment\n            [size / 2, -size / 2, size / 2, size / 2], // right\n            [-size / 2, size / 2, size / 2, size / 2], // bottom\n            [-size / 2, -size / 2, -size / 2, size / 2], // left\n        ];\n\n        // Find the intersecting segment.\n        let intersection = null;\n        let winding = 0;\n        for (let i = 0; i < segments.length; i++) {\n            const segment = segments[i];\n            const hit = intersect(0, 0, x, y, segment[0], segment[1], segment[2], segment[3]);\n            if (hit) {\n                intersection = hit;\n                if (i === 0) winding = hit.x > 0 ? 0 : 4;\n                else winding = i;\n                break;\n            }\n        }\n\n        const corners = [\n            size / 2, -size / 2, // Top right\n            size / 2, size / 2, // Bottom right\n            -size / 2, size / 2, // Bottom left\n            -size / 2, -size / 2, // Top left,\n            0, -size / 2, // End point\n        ];\n\n        // Redraw mask\n        mask.clear();\n        mask.lineStyle(2, 0xff0000, 1);\n        mask.beginFill(0xff0000, 1);\n        mask.moveTo(0, -size / 2);\n        mask.lineTo(0, 0);\n\n        mask.lineTo(intersection.x, intersection.y);\n\n        // fill the corners\n        for (let i = winding; i < corners.length / 2; i++) {\n            mask.lineTo(corners[i * 2], corners[i * 2 + 1]);\n        }\n        mask.endFill();\n    };\n};\n\n/* -----------------------\n Spinner 2. Scaling balls.\n ---------------------- */\nconst generateSpinner2 = (position) => {\n    const container = new PIXI.Container();\n    container.position = position;\n    app.stage.addChild(container);\n\n    const size = 100;\n    const ballAmount = 7;\n    const balls = [];\n    for (let i = 0; i < ballAmount; i++) {\n        const ball = PIXI.Sprite.from('examples/assets/circle.png');\n        ball.anchor.set(0.5);\n        container.addChild(ball);\n        ball.position.set(\n            size / 2 + Math.cos(i / ballAmount * Math.PI * 2) * size / 3,\n            size / 2 + Math.sin(i / ballAmount * Math.PI * 2) * size / 3,\n        );\n        balls.push(ball);\n    }\n\n    let phase = 0;\n    return (delta) => {\n        // Update phase\n        phase += delta / 60;\n        phase %= (Math.PI * 2);\n\n        // Update ball scales\n        balls.forEach((b, i) => {\n            const sin = Math.sin(i / ballAmount * Math.PI - phase);\n            // Multiply sin with itself to get more steeper edge.\n            b.scale.set(Math.abs(sin * sin * sin * 0.5) + 0.5);\n        });\n    };\n};\n\n/* ---------------------\n Spinner 3. Radial mask.\n -------------------- */\nconst generateSpinner3 = (position) => {\n    const container = new PIXI.Container();\n    container.position = position;\n    app.stage.addChild(container);\n\n    const base = PIXI.Sprite.from('examples/assets/bg_scene_rotate.jpg');\n    const size = 100;\n    base.width = size;\n    base.height = size;\n\n    const mask = new PIXI.Graphics();\n    mask.position.set(size / 2, size / 2);\n    base.mask = mask;\n    window.mask = mask;\n\n    container.addChild(base);\n    container.addChild(mask);\n\n    let phase = 0;\n    return (delta) => {\n        // Update phase\n        phase += delta / 60;\n        phase %= (Math.PI * 2);\n\n        const angleStart = 0 - Math.PI / 2;\n        const angle = phase + angleStart;\n        const radius = 50;\n\n        const x1 = Math.cos(angleStart) * radius;\n        const y1 = Math.sin(angleStart) * radius;\n\n        // Redraw mask\n        mask.clear();\n        mask.lineStyle(2, 0xff0000, 1);\n        mask.beginFill(0xff0000, 1);\n        mask.moveTo(0, 0);\n        mask.lineTo(x1, y1);\n        mask.arc(0, 0, radius, angleStart, angle, false);\n        mask.lineTo(0, 0);\n        mask.endFill();\n    };\n};\n\n/* ---------------------------------\n Spinner 4. Rounded rectangle edges.\n ------------------------------- */\nconst generateSpinner4 = (position) => {\n    const container = new PIXI.Container();\n    container.position = position;\n    app.stage.addChild(container);\n\n    const size = 100;\n    const arcRadius = 15;\n\n    const base = PIXI.Sprite.from('examples/assets/bg_scene_rotate.jpg');\n    base.width = size;\n    base.height = size;\n\n    // For better performance having assets prerounded would be better than masking.\n    const roundingMask = new PIXI.Graphics();\n    roundingMask.beginFill(0, 1);\n    roundingMask.lineStyle(1, 0xff0000, 1);\n    roundingMask.drawRoundedRect(0, 0, size, size, arcRadius);\n    roundingMask.endFill();\n    base.mask = roundingMask;\n\n    // The edge could be replaced with image as well.\n    const lineSize = 5;\n    const edge = new PIXI.Graphics();\n    edge.lineStyle(lineSize, 0xff0000, 1);\n    edge.drawRoundedRect(0, 0, size, size, arcRadius);\n    edge.endFill();\n\n    // Mask in this example works basically the same way as in example 1. Except it is reversed and calculates the mask in straight lines in edges.\n    const mask = new PIXI.Graphics();\n    mask.position.set(size / 2, size / 2);\n    edge.mask = mask;\n\n    container.addChild(base);\n    container.addChild(roundingMask);\n    container.addChild(edge);\n    container.addChild(mask);\n\n    let phase = 0;\n    return (delta) => {\n        // Update phase\n        phase += delta / 160;\n        phase %= (Math.PI * 2);\n\n        // Calculate target point.\n        const x = Math.cos(phase - Math.PI / 2) * size;\n        const y = Math.sin(phase - Math.PI / 2) * size;\n        // Line segments\n        const segments = [\n            [-size / 2 + lineSize, -size / 2 + lineSize, size / 2 - lineSize, -size / 2 + lineSize], // top segment\n            [size / 2 - lineSize, -size / 2 + lineSize, size / 2 - lineSize, size / 2 - lineSize], // right\n            [-size / 2 + lineSize, size / 2 - lineSize, size / 2 - lineSize, size / 2 - lineSize], // bottom\n            [-size / 2 + lineSize, -size / 2 + lineSize, -size / 2 + lineSize, size / 2 - lineSize], // left\n        ];\n        // To which dir should mask continue at each segment\n        let outDir = [\n            [0, -1],\n            [1, 0],\n            [0, 1],\n            [-1, 0],\n        ];\n\n        // Find the intersecting segment.\n        let intersection = null;\n        let winding = 0;\n        // What direction should the line continue after hit has been found before hitting the line size\n        for (let i = 0; i < segments.length; i++) {\n            const segment = segments[i];\n            const hit = intersect(0, 0, x, y, segment[0], segment[1], segment[2], segment[3]);\n            if (hit) {\n                intersection = hit;\n                if (i === 0) winding = hit.x < 0 ? 0 : 4;\n                else winding = 4 - i;\n                outDir = outDir[i];\n                break;\n            }\n        }\n\n        const corners = [\n            -size / 2 - lineSize, -size / 2 - lineSize, // Top left,\n            -size / 2 - lineSize, size / 2 + lineSize, // Bottom left\n            size / 2 + lineSize, size / 2 + lineSize, // Bottom right\n            size / 2 + lineSize, -size / 2 - lineSize, // Top right\n        ];\n\n        // Redraw mask\n        mask.clear();\n        mask.lineStyle(2, 0x00ff00, 1);\n        mask.beginFill(0xff0000, 1);\n\n        mask.moveTo(0, 0);\n        mask.moveTo(0, -size / 2 - lineSize);\n\n        // fill the corners\n        for (let i = 0; i < winding; i++) {\n            mask.lineTo(corners[i * 2], corners[i * 2 + 1]);\n        }\n\n        mask.lineTo(intersection.x + outDir[0] * lineSize * 2, intersection.y + outDir[1] * lineSize * 2);\n        mask.lineTo(intersection.x, intersection.y);\n        mask.lineTo(0, 0);\n\n        mask.endFill();\n    };\n};\n\n/* ---------------------\n Spinner 5. Rounded rectangle fixed length spinner by jonlepage\n -------------------- */\nconst generateSpinner5 = (position) => {\n    const container = new PIXI.Container();\n    container.position = position;\n    app.stage.addChild(container);\n\n    const halfCircle = new PIXI.Graphics();\n    halfCircle.beginFill(0xff0000);\n    halfCircle.lineStyle(2, 0xffffff);\n    halfCircle.arc(0, 0, 100, 0, Math.PI);\n    halfCircle.endFill();\n    halfCircle.position.set(50, 50);\n\n    const rectangle = new PIXI.Graphics();\n    rectangle.lineStyle(2, 0xffffff, 1);\n    rectangle.drawRoundedRect(0, 0, 100, 100, 16);\n    rectangle.endFill();\n    rectangle.mask = halfCircle;\n\n    container.addChild(rectangle);\n    container.addChild(halfCircle);\n\n    let phase = 0;\n    return (delta) => {\n        // Update phase\n        phase += delta / 6;\n        phase %= (Math.PI * 2);\n\n        halfCircle.rotation = phase;\n    };\n};\n\nconst onTick = [\n    generateSpinner1(new PIXI.Point(50, 50)),\n    generateSpinner2(new PIXI.Point(160, 50)),\n    generateSpinner3(new PIXI.Point(270, 50)),\n    generateSpinner4(new PIXI.Point(380, 50)),\n    generateSpinner5(new PIXI.Point(490, 50)),\n];\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // Call tick handling for each spinner.\n    onTick.forEach((cb) => {\n        cb(delta);\n    });\n});\n\n/**\n * Helper functions\n\n    line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/\n    Determine the intersection point of two line segments\n    Return FALSE if the lines don't intersect\n\n    Code modified from original to match pixi examples linting rules.\n*/\nfunction intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n    // Check if none of the lines are of length 0\n    if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n        return false;\n    }\n\n    const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n\n    // Lines are parallel\n    if (denominator === 0) {\n        return false;\n    }\n\n    const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n    const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;\n\n    // is the intersection along the segments\n    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n        return false;\n    }\n\n    // Return a object with the x and y coordinates of the intersection\n    const x = x1 + ua * (x2 - x1);\n    const y = y1 + ua * (y2 - y1);\n\n    return { x, y };\n}\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "mesh-and-shaders",
      "title": "Mesh and Shaders",
      "examples": [
        {
          "title": "Textured Mesh - Basic",
          "entry": "textured-mesh-basic.js",
          "path": "mesh-and-shaders/textured-mesh-basic.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nlet count = 0;\n\n// build a rope!\nconst ropeLength = 918 / 20;\n\nconst points = [];\n\nfor (let i = 0; i < 20; i++) {\n    points.push(new PIXI.Point(i * ropeLength, 0));\n}\n\nconst strip = new PIXI.SimpleRope(PIXI.Texture.from('examples/assets/snake.png'), points);\n\nstrip.x = -459;\n\nconst snakeContainer = new PIXI.Container();\nsnakeContainer.x = 400;\nsnakeContainer.y = 300;\n\nsnakeContainer.scale.set(800 / 1100);\napp.stage.addChild(snakeContainer);\n\nsnakeContainer.addChild(strip);\n\napp.ticker.add(() => {\n    count += 0.1;\n\n    // make the snake\n    for (let i = 0; i < points.length; i++) {\n        points[i].y = Math.sin((i * 0.5) + count) * 30;\n        points[i].x = i * ropeLength + Math.cos((i * 0.3) + count) * 20;\n    }\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Textured Mesh - Advanced",
          "entry": "textured-mesh-advanced.js",
          "path": "mesh-and-shaders/textured-mesh-advanced.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nlet count = 0;\n\n// build a rope!\nconst ropeLength = 45;\n\nconst points = [];\n\nfor (let i = 0; i < 25; i++) {\n    points.push(new PIXI.Point(i * ropeLength, 0));\n}\n\nconst strip = new PIXI.SimpleRope(PIXI.Texture.from('examples/assets/snake.png'), points);\n\nstrip.x = -40;\nstrip.y = 300;\n\napp.stage.addChild(strip);\n\nconst g = new PIXI.Graphics();\ng.x = strip.x;\ng.y = strip.y;\napp.stage.addChild(g);\n\n// start animating\napp.ticker.add(() => {\n    count += 0.1;\n\n    // make the snake\n    for (let i = 0; i < points.length; i++) {\n        points[i].y = Math.sin((i * 0.5) + count) * 30;\n        points[i].x = i * ropeLength + Math.cos((i * 0.3) + count) * 20;\n    }\n    renderPoints();\n});\n\nfunction renderPoints() {\n    g.clear();\n\n    g.lineStyle(2, 0xffc2c2);\n    g.moveTo(points[0].x, points[0].y);\n\n    for (let i = 1; i < points.length; i++) {\n        g.lineTo(points[i].x, points[i].y);\n    }\n\n    for (let i = 1; i < points.length; i++) {\n        g.beginFill(0xff0022);\n        g.drawCircle(points[i].x, points[i].y, 10);\n        g.endFill();\n    }\n}\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Triangle",
          "entry": "triangle.js",
          "path": "mesh-and-shaders/triangle.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', [-100, -50, 100, -50, 0, 100]);\n\nconst shader = PIXI.Shader.from(`\n\n    precision mediump float;\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    void main() {\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }`,\n\n`precision mediump float;\n\n    void main() {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n\n`);\n\nconst triangle = new PIXI.Mesh(geometry, shader);\n\ntriangle.position.set(400, 300);\n\napp.stage.addChild(triangle);\n\napp.ticker.add((delta) => {\n    triangle.rotation += 0.01;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Colored Triangle",
          "entry": "triangle-color.js",
          "path": "mesh-and-shaders/triangle-color.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -50, // x, y\n            100, -50, // x, y\n            0.0, 100.0], // x, y\n        2) // the size of the attribute\n\n    .addAttribute('aColor', // the attribute name\n        [1, 0, 0, // r, g, b\n            0, 1, 0, // r, g, b\n            0, 0, 1], // r, g, b\n        3); // the size of the attribute\n\nconst shader = PIXI.Shader.from(`\n\n    precision mediump float;\n    attribute vec2 aVertexPosition;\n    attribute vec3 aColor;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec3 vColor;\n\n    void main() {\n\n        vColor = aColor;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`,\n\n`precision mediump float;\n\n    varying vec3 vColor;\n\n    void main() {\n        gl_FragColor = vec4(vColor, 1.0);\n    }\n\n`);\n\nconst triangle = new PIXI.Mesh(geometry, shader);\n\ntriangle.position.set(400, 300);\ntriangle.scale.set(2);\n\napp.stage.addChild(triangle);\n\napp.ticker.add((delta) => {\n    triangle.rotation += 0.01;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Textured Triangle",
          "entry": "triangle-textured.js",
          "path": "mesh-and-shaders/triangle-textured.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100], // x, y\n        2) // the size of the attribute\n\n    .addAttribute('aColor', // the attribute name\n        [1, 0, 0, // r, g, b\n            0, 1, 0, // r, g, b\n            0, 0, 1], // r, g, b\n        3) // the size of the attribute\n\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1], // u, v\n        2); // the size of the attribute\n\nconst vertexSrc = `\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec3 aColor;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n    varying vec3 vColor;\n\n    void main() {\n\n        vUvs = aUvs;\n        vColor = aColor;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`;\n\nconst fragmentSrc = `\n\n    precision mediump float;\n\n    varying vec3 vColor;\n    varying vec2 vUvs;\n\n    uniform sampler2D uSampler2;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSampler2, vUvs) * vec4(vColor, 1.0);\n    }`;\n\nconst uniforms = { uSampler2: PIXI.Texture.from('examples/assets/bg_scene_rotate.jpg') };\n\nconst shader = PIXI.Shader.from(vertexSrc, fragmentSrc, uniforms);\n\nconst triangle = new PIXI.Mesh(geometry, shader);\n\ntriangle.position.set(400, 300);\ntriangle.scale.set(2);\n\napp.stage.addChild(triangle);\n\napp.ticker.add((delta) => {\n    triangle.rotation += 0.01;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Uniforms",
          "entry": "uniforms.js",
          "path": "mesh-and-shaders/uniforms.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100,\n            -100, 100], // x, y\n        2) // the size of the attribute\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1,\n            0, 1], // u, v\n        2) // the size of the attribute\n    .addIndex([0, 1, 2, 0, 2, 3]);\n\nconst vertexSrc = `\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`;\n\nconst fragmentSrc = `\n\n    precision mediump float;\n\n    varying vec2 vUvs;\n\n    uniform sampler2D uSampler2;\n    uniform float time;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSampler2, vUvs + sin( (time + (vUvs.x) * 14.) ) * 0.1 );\n    }`;\n\nconst uniforms = {\n    uSampler2: PIXI.Texture.from('examples/assets/bg_scene_rotate.jpg'),\n    time: 0,\n};\n\nconst shader = PIXI.Shader.from(vertexSrc, fragmentSrc, uniforms);\n\nconst quad = new PIXI.Mesh(geometry, shader);\n\nquad.position.set(400, 300);\nquad.scale.set(2);\n\napp.stage.addChild(quad);\n\n// start the animation..\n// requestAnimationFrame(animate);\n\napp.ticker.add((delta) => {\n    quad.rotation += 0.01;\n    quad.shader.uniforms.time += 0.1;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Sharing Geometry",
          "entry": "sharing-geometry.js",
          "path": "mesh-and-shaders/sharing-geometry.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100], // x, y\n        2) // the size of the attribute\n\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1], // u, v\n        2); // the size of the attribute\n\nconst program = PIXI.Program.from(`\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`,\n\n`precision mediump float;\n\n    varying vec2 vUvs;\n\n    uniform sampler2D uSamplerTexture;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSamplerTexture, vUvs);\n    }\n\n`);\n\nconst triangle = new PIXI.Mesh(geometry, new PIXI.Shader(program, {\n    uSamplerTexture: PIXI.Texture.from('examples/assets/bg_scene_rotate.jpg'),\n}));\n\nconst triangle2 = new PIXI.Mesh(geometry, new PIXI.Shader(program, {\n    uSamplerTexture: PIXI.Texture.from('examples/assets/bg_rotate.jpg'),\n}));\n\nconst triangle3 = new PIXI.Mesh(geometry, new PIXI.Shader(program, {\n    uSamplerTexture: PIXI.Texture.from('examples/assets/bg_displacement.jpg'),\n}));\n\ntriangle.position.set(400, 300);\ntriangle.scale.set(2);\n\ntriangle2.position.set(200, 100);\n\ntriangle3.position.set(500, 400);\ntriangle3.scale.set(3);\n\napp.stage.addChild(triangle3, triangle2, triangle);\n\napp.ticker.add((delta) => {\n    triangle.rotation += 0.01;\n    triangle2.rotation -= 0.01;\n    triangle3.rotation -= 0.005;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Sharing Shader",
          "entry": "shared-shader.js",
          "path": "mesh-and-shaders/shared-shader.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100]) // x, y\n\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1]); // u, v\n\nconst shader = PIXI.Shader.from(`\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`,\n\n`precision mediump float;\n\n    varying vec2 vUvs;\n\n    uniform sampler2D uSampler2;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSampler2, vUvs);\n    }\n\n`,\n{\n    uSampler2: PIXI.Texture.from('examples/assets/bg_scene_rotate.jpg'),\n});\n\nconst shader2 = PIXI.Shader.from(`\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`,\n\n`precision mediump float;\n\n    varying vec2 vUvs;\n\n    uniform sampler2D uSampler2;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSampler2, vUvs);\n        gl_FragColor.r += (abs(sin(gl_FragCoord.x * 0.06)) * 0.5) * 2.;\n        gl_FragColor.g += (abs(cos(gl_FragCoord.y * 0.06)) * 0.5) * 2.;\n    }\n\n`,\n{\n    uSampler2: PIXI.Texture.from('examples/assets/bg_scene_rotate.jpg'),\n});\n\nconst triangle = new PIXI.Mesh(geometry, shader);\n\nconst triangle2 = new PIXI.Mesh(geometry, shader2);\n\ntriangle.position.set(400, 300);\ntriangle.scale.set(2);\n\ntriangle2.position.set(500, 400);\ntriangle2.scale.set(3);\n\napp.stage.addChild(triangle2, triangle);\n\napp.ticker.add((delta) => {\n    triangle.rotation += 0.01;\n    triangle2.rotation -= 0.005;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Merging Geometry",
          "entry": "merging-geometry.js",
          "path": "mesh-and-shaders/merging-geometry.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100,\n            -100, 100], // x, y\n        2) // the size of the attribute\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1,\n            0, 1], // u, v\n        2) // the size of the attribute\n    .addIndex([0, 1, 2, 0, 2, 3]);\n\nconst geometry2 = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100 + 100, -100, // x, y\n            100 + 100, -100, // x, y\n            100 + 100, 100], // x, y\n        2) // the size of the attribute\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1], // u, v\n        2) // the size of the attribute\n    .addIndex([0, 1, 2]);\n\nconst geometry3 = PIXI.Geometry.merge([geometry, geometry2]);\n\nconst shader = PIXI.Shader.from(`\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`,\n\n`precision mediump float;\n\n    varying vec2 vUvs;\n\n    uniform sampler2D uSampler2;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSampler2, vUvs );\n    }\n\n`,\n{\n    uSampler2: PIXI.Texture.from('examples/assets/bg_scene_rotate.jpg'),\n});\n\nconst quad = new PIXI.Mesh(geometry3, shader);\n\nquad.position.set(400, 300);\nquad.scale.set(2);\n\napp.stage.addChild(quad);\n\napp.ticker.add((delta) => {\n    quad.rotation += 0.01;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Interleaving Geometry",
          "entry": "interleaving-geometry.js",
          "path": "mesh-and-shaders/interleaving-geometry.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100,\n            -100, 100], // x, y\n        2) // the size of the attribute\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1,\n            0, 1], // u, v\n        2) // the size of the attribute\n    .addIndex([0, 1, 2, 0, 2, 3])\n    .interleave();\n\nconst shader = PIXI.Shader.from(`\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`,\n\n`precision mediump float;\n\n    varying vec2 vUvs;\n\n    uniform sampler2D uSampler2;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSampler2, vUvs );\n    }\n\n`,\n{\n    uSampler2: PIXI.Texture.from('examples/assets/bg_scene_rotate.jpg'),\n});\n\nconst quad = new PIXI.Mesh(geometry, shader);\n\nquad.position.set(400, 300);\nquad.scale.set(2);\n\napp.stage.addChild(quad);\n\napp.ticker.add((delta) => {\n    quad.rotation += 0.01;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Instanced Geometry",
          "entry": "instanced-geometry.js",
          "path": "mesh-and-shaders/instanced-geometry.js",
          "code": "const app = new PIXI.Application();\n\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVPos', [-100, 0, 100, 0, 0, -150]);\n\ngeometry.instanced = true;\ngeometry.instanceCount = 5;\n\nconst positionSize = 2;\nconst colorSize = 3;\nconst buffer = new PIXI.Buffer(new Float32Array(geometry.instanceCount * (positionSize + colorSize)));\n\ngeometry.addAttribute('aIPos', buffer, positionSize, false, PIXI.TYPES.FLOAT, 4 * (positionSize + colorSize), 0, true);\ngeometry.addAttribute('aICol', buffer, colorSize, false, PIXI.TYPES.FLOAT, 4 * (positionSize + colorSize), 4 * positionSize, true);\n\nfor (let i = 0; i < geometry.instanceCount; i++) {\n    const instanceOffset = i * (positionSize + colorSize);\n\n    buffer.data[instanceOffset + 0] = i * 80;\n    buffer.data[instanceOffset + 2] = Math.random();\n    buffer.data[instanceOffset + 3] = Math.random();\n    buffer.data[instanceOffset + 4] = Math.random();\n}\n\nconst shader = PIXI.Shader.from(`\n    precision mediump float;\n    attribute vec2 aVPos;\n    attribute vec2 aIPos;\n    attribute vec3 aICol;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec3 vCol;\n\n    void main() {\n        vCol = aICol;\n\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVPos + aIPos, 1.0)).xy, 0.0, 1.0);\n    }`,\n\n`precision mediump float;\n\n    varying vec3 vCol;\n\n    void main() {\n        gl_FragColor = vec4(vCol, 1.0);\n    }\n\n`);\n\nconst triangles = new PIXI.Mesh(geometry, shader);\n\ntriangles.position.set(400, 300);\n\napp.stage.addChild(triangles);\n\napp.ticker.add((delta) => {\n    triangles.rotation += 0.01;\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Shadertoy",
          "entry": "shadertoy-mesh.js",
          "path": "mesh-and-shaders/shadertoy-mesh.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// Build geometry.\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100,\n            -100, 100], // x, y\n        2) // the size of the attribute\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1,\n            0, 1], // u, v\n        2) // the size of the attribute\n    .addIndex([0, 1, 2, 0, 2, 3]);\n\nconst vertexSrc = `\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`;\n\nconst fragmentSrc = `\n//Based on this: https://www.shadertoy.com/view/wtlSWX\nprecision mediump float;\n\nvarying vec2 vUvs;\n\nuniform sampler2D noise;\nuniform float time;\n\n//Distance function. Just calculates the height (z) from x,y plane with really simple length check. Its not exact as there could be shorter distances.\nvec2 dist(vec3 p)\n{\n    float id = floor(p.x)+floor(p.y);\n    id = mod(id, 2.);\n    float h = texture2D(noise, vec2(p.x, p.y)*0.04).r*5.1;\n    return vec2(h-p.z,id);\n}\n\n//Light calculation.\nvec3 calclight(vec3 p, vec3 rd)\n{\n    vec2 eps = vec2( 0., 0.001);\n    vec3 n = normalize( vec3(\n    dist(p+eps.yxx).x - dist(p-eps.yxx).x,\n    dist(p+eps.xyx).x - dist(p-eps.xyx).x,\n    dist(p+eps.xxy).x - dist(p-eps.xxy).x\n    ));\n\n    vec3 d = vec3( max( 0., dot( -rd ,n)));\n\n    return d;\n}\n\nvoid main()\n{\n    vec2 uv = vec2(vUvs.x,1.-vUvs.y);\n    uv *=2.;\n    uv-=1.;\n\n    vec3 cam = vec3(0.,time -2., -3.);\n    vec3 target = vec3(sin(time)*0.1, time+cos(time)+2., 0. );\n    float fov = 2.2;\n    vec3 forward = normalize( target - cam);\n    vec3 up = normalize(cross( forward, vec3(0., 1.,0.)));\n    vec3 right = normalize( cross( up, forward));\n    vec3 raydir = normalize(vec3( uv.x *up + uv.y * right + fov*forward));\n\n    //Do the raymarch\n    vec3 col = vec3(0.);\n    float t = 0.;\n    for( int i = 0; i < 100; i++)\n    {\n    vec3 p = t * raydir + cam;\n    vec2 d = dist(p);\n    t+=d.x*0.5;//Jump only half of the distance as height function used is not really the best for heightmaps.\n    if(d.x < 0.001)\n    {\n        vec3 bc = d.y < 0.5 ? vec3(1.0, .8, 0.) :\n                vec3(0.8,0.0, 1.0);\n        col = vec3( 1.) * calclight(p, raydir) * (1. - t/150.) *bc;\n        break;\n    }\n    if(t > 1000.)\n    {\n        break;\n    }\n    }\n    gl_FragColor = vec4(col, 1.);\n}`;\n\nconst uniforms = {\n    noise: PIXI.Texture.from('examples/assets/perlin.jpg'),\n    time: 0,\n};\n// Make sure repeat wrap is used and no mipmapping.\nuniforms.noise.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;\nuniforms.noise.baseTexture.mipmap = false;\n\n// Build the shader and the quad.\nconst shader = PIXI.Shader.from(vertexSrc, fragmentSrc, uniforms);\nconst quad = new PIXI.Mesh(geometry, shader);\n\nquad.position.set(400, 300);\nquad.scale.set(2);\n\napp.stage.addChild(quad);\n\n// start the animation..\nlet time = 0;\napp.ticker.add((delta) => {\n    time += 1 / 60;\n    quad.shader.uniforms.time = time;\n    quad.scale.set(Math.cos(time) * 1 + 2, Math.sin(time * 0.7) * 1 + 2);\n});\n",
          "exists": true,
          "plugins": []
        },
        {
          "title": "Multipass Shader Mesh",
          "entry": "multipass-shader-generated-mesh.js",
          "path": "mesh-and-shaders/multipass-shader-generated-mesh.js",
          "code": "const app = new PIXI.Application({ height: 640 });\ndocument.body.appendChild(app.view);\n\n// Build geometry.\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [0, 0, // x, y\n            200, 0, // x, y\n            200, 200,\n            0, 200], // x, y\n        2) // the size of the attribute\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1,\n            0, 1], // u, v\n        2) // the size of the attribute\n    .addIndex([0, 1, 2, 0, 2, 3]);\n\n// Vertex shader. Use same shader for all passes.\nconst vertexSrc = `\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`;\n\n// Load a perlinnoise texture for one of the shaders.\nconst perlinTexture = PIXI.Texture.from('examples/assets/perlin.jpg');\n\n// First pass, generates a grid.\nconst fragmentGridSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\nuniform float zoom;\n\nvoid main()\n{\n    //Generate a simple grid.\n    //Offset uv so that center is 0,0 and edges are -1,1\n    vec2 uv = (vUvs-vec2(0.5))*2.0;\n    vec2 gUv = floor(uv*zoom);\n    vec4 color1 = vec4(0.8, 0.8, 0.8, 1.0);\n    vec4 color2 = vec4(0.4, 0.4, 0.4, 1.0);\n    vec4 outColor = mod(gUv.x + gUv.y, 2.) < 0.5 ? color1 : color2;\n    gl_FragColor = outColor;\n    \n}`;\n\nconst gridUniforms = {\n    zoom: 10,\n};\nconst gridShader = PIXI.Shader.from(vertexSrc, fragmentGridSrc, gridUniforms);\n// Sharing textures and meshes is possible. But for simplicity each pass has it's own output texture and mesh in this example.\nconst gridTexture = PIXI.RenderTexture.create({ width: 200, height: 200 });\nconst gridQuad = new PIXI.Mesh(geometry, gridShader);\nconst gridContainer = new PIXI.Container();\ngridContainer.addChild(gridQuad);\n\n// Second pass. Takes grid as input and makes it ripple.\nconst fragmentRippleSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\nuniform float amount;\nuniform float phase;\nuniform sampler2D texIn;\n\nvoid main()\n{\n    //Generate a simple grid.\n    vec2 uv = vUvs;\n    //Calculate distance from center\n    float distance = length( uv - vec2(0.5));\n    vec4 color = texture2D(texIn, uv);\n    color.rgb *= sin(distance*25.0+phase) * amount+1.;\n    gl_FragColor = color;\n}`;\nconst rippleUniforms = {\n    amount: 0.5,\n    phase: 0,\n    texIn: gridTexture,\n};\nconst rippleShader = PIXI.Shader.from(vertexSrc, fragmentRippleSrc, rippleUniforms);\nconst rippleTexture = PIXI.RenderTexture.create({ width: 200, height: 200 });\nconst rippleQuad = new PIXI.Mesh(geometry, rippleShader);\nconst rippleContainer = new PIXI.Container();\nrippleContainer.addChild(rippleQuad);\n\n// Second effect. Generates a filtered noise.\nconst fragmentNoiseSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\nuniform float limit;\nuniform sampler2D noise;\n\nvoid main()\n{\n    float color = texture2D(noise, vUvs).r;\n    color = step(limit, color);\n    gl_FragColor = vec4(color);\n}`;\nconst noiseUniforms = {\n    limit: 0.5,\n    noise: perlinTexture,\n};\nconst noiseShader = PIXI.Shader.from(vertexSrc, fragmentNoiseSrc, noiseUniforms);\nconst noiseTexture = PIXI.RenderTexture.create({ width: 200, height: 200 });\nconst noiseQuad = new PIXI.Mesh(geometry, noiseShader);\nconst noiseContainer = new PIXI.Container();\nnoiseContainer.addChild(noiseQuad);\n\n// Third effect\nconst fragmentWaveSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\nuniform float amplitude;\nuniform float time;\n\nvoid main()\n{\n    //Offset uv so that center is 0,0 and edges are -1,1\n    vec2 uv = (vUvs-vec2(0.5))*2.0;\n    \n    vec3 outColor = vec3(0.);\n    \n    //Simple wavefunctions inversed and with small offsets.\n    outColor += 5./length(uv.y*200. - 50.0*sin( uv.x*0.25+ time*0.25)*amplitude);\n    outColor += 4./length(uv.y*300. - 100.0*sin(uv.x*0.5+time*0.5)*amplitude*1.2);\n    outColor += 3./length(uv.y*400. - 150.0*sin(uv.x*0.75+time*0.75)*amplitude*1.4);\n    outColor += 2./length(uv.y*500. - 200.0*sin(uv.x+time)*amplitude*1.6);\n    \n    gl_FragColor = vec4(outColor,1.0);\n}`;\nconst waveUniforms = {\n    amplitude: 0.75,\n    time: 0,\n};\nconst waveShader = PIXI.Shader.from(vertexSrc, fragmentWaveSrc, waveUniforms);\nconst waveTexture = PIXI.RenderTexture.create({ width: 200, height: 200 });\nconst waveQuad = new PIXI.Mesh(geometry, waveShader);\nconst waveContainer = new PIXI.Container();\nwaveContainer.addChild(waveQuad);\n\n// Final combination pass\nconst fragmentCombineSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\n\nuniform sampler2D texRipple;\nuniform sampler2D texNoise;\nuniform sampler2D texWave;\n\nvoid main()\n{\n    //Read color from all\n    vec4 ripple = texture2D(texRipple, vUvs);\n    vec4 noise = texture2D(texNoise, vUvs);\n    vec4 wave = texture2D(texWave, vUvs);\n    \n    gl_FragColor = mix(ripple, wave,noise.r);\n}`;\nconst combineUniforms = {\n    texRipple: rippleTexture,\n    texNoise: noiseTexture,\n    texWave: waveTexture,\n};\nconst combineShader = PIXI.Shader.from(vertexSrc, fragmentCombineSrc, combineUniforms);\nconst combineQuad = new PIXI.Mesh(geometry, combineShader);\n\ngridContainer.position.set(10, 10);\nrippleContainer.position.set(220, 10);\nnoiseContainer.position.set(10, 220);\nwaveContainer.position.set(10, 430);\ncombineQuad.position.set(430, 220);\n\n// Add all phases to stage so all the phases can be seen separately.\napp.stage.addChild(gridContainer);\napp.stage.addChild(rippleContainer);\napp.stage.addChild(noiseContainer);\napp.stage.addChild(waveContainer);\napp.stage.addChild(combineQuad);\n\n// start the animation..\nlet time = 0;\napp.ticker.add((delta) => {\n    time += 1 / 60;\n    // gridQuad.shader.uniforms.zoom = Math.sin(time)*5+10;\n    rippleQuad.shader.uniforms.phase = -time;\n    waveQuad.shader.uniforms.time = time;\n    noiseQuad.shader.uniforms.limit = Math.sin(time * 0.5) * 0.35 + 0.5;\n\n    // Render the passes to get textures.\n    app.renderer.render(gridQuad, { renderTexture: gridTexture });\n    app.renderer.render(rippleQuad, { renderTexture: rippleTexture });\n    app.renderer.render(noiseQuad, { renderTexture: noiseTexture });\n    app.renderer.render(waveQuad, { renderTexture: waveTexture });\n});\n",
          "exists": true,
          "plugins": []
        }
      ]
    },
    {
      "id": "plugin-spine",
      "title": "Plugin Spine",
      "examples": [
        {
          "title": "Dragon",
          "entry": "dragon.js",
          "path": "plugin-spine/dragon.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('examples/assets/pixi-spine/dragon.json').then(onAssetsLoaded);\n\nfunction onAssetsLoaded(dragonAsset) {\n    // instantiate the spine animation\n    const dragon = new PIXI.spine.Spine(dragonAsset.spineData);\n    dragon.skeleton.setToSetupPose();\n    dragon.update(0);\n    dragon.autoUpdate = false;\n\n    // create a container for the spine animation and add the animation to it\n    const dragonCage = new PIXI.Container();\n    dragonCage.addChild(dragon);\n\n    // measure the spine animation and position it inside its container to align it to the origin\n    const localRect = dragon.getLocalBounds();\n    dragon.position.set(-localRect.x, -localRect.y);\n\n    // now we can scale, position and rotate the container as any other display object\n    const scale = Math.min(\n        (app.screen.width * 0.7) / dragonCage.width,\n        (app.screen.height * 0.7) / dragonCage.height,\n    );\n    dragonCage.scale.set(scale, scale);\n    dragonCage.position.set(\n        (app.screen.width - dragonCage.width) * 0.5,\n        (app.screen.height - dragonCage.height) * 0.5,\n    );\n\n    // add the container to the stage\n    app.stage.addChild(dragonCage);\n\n    // once position and scaled, set the animation to play\n    dragon.state.setAnimation(0, 'flying', true);\n\n\n    app.ticker.add(() => {\n        // update the spine animation, only needed if dragon.autoupdate is set to false\n        dragon.update(app.ticker.deltaMS / 1000); // IN SECONDS!\n    });\n}\n",
          "exists": true,
          "plugins": [
            "pixi-spine"
          ]
        },
        {
          "title": "Goblin",
          "entry": "goblins.js",
          "path": "plugin-spine/goblins.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// load spine data\nPIXI.Assets.load('examples/assets/pixi-spine/goblins.json').then(onAssetsLoaded);\n\n\nfunction onAssetsLoaded(goblinAsset) {\n    app.stage.interactive = true;\n    app.stage.cursor = 'pointer';\n\n    const goblin = new PIXI.spine.Spine(goblinAsset.spineData);\n\n    // set current skin\n    goblin.skeleton.setSkinByName('goblin');\n    goblin.skeleton.setSlotsToSetupPose();\n\n    // set the position\n    goblin.x = 400;\n    goblin.y = 600;\n\n    goblin.scale.set(1.5);\n\n    // play animation\n    goblin.state.setAnimation(0, 'walk', true);\n\n    app.stage.addChild(goblin);\n\n    app.stage.on('pointertap', () => {\n    // change current skin\n        const currentSkinName = goblin.skeleton.skin.name;\n        const newSkinName = (currentSkinName === 'goblin' ? 'goblingirl' : 'goblin');\n        goblin.skeleton.setSkinByName(newSkinName);\n        goblin.skeleton.setSlotsToSetupPose();\n    });\n}\n",
          "exists": true,
          "plugins": [
            "pixi-spine"
          ]
        },
        {
          "title": "Pixie",
          "entry": "pixie.js",
          "path": "plugin-spine/pixie.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// load spine data\nPIXI.Assets.load('examples/assets/pixi-spine/pixie.json').then(onAssetsLoaded);\n\n\nfunction onAssetsLoaded(pixieAsset) {\n    app.stage.interactive = true;\n    let postition = 0;\n\n    const background = PIXI.Sprite.from('examples/assets/pixi-spine/iP4_BGtile.jpg');\n    const background2 = PIXI.Sprite.from('examples/assets/pixi-spine/iP4_BGtile.jpg');\n\n    const foreground = PIXI.Sprite.from('examples/assets/pixi-spine/iP4_ground.png');\n    const foreground2 = PIXI.Sprite.from('examples/assets/pixi-spine/iP4_ground.png');\n    foreground.anchor.set(0, 0.7);\n    foreground.position.y = app.screen.height;\n    foreground2.anchor.set(0, 0.7);\n    foreground2.position.y = app.screen.height;\n\n    app.stage.addChild(background, background2, foreground, foreground2);\n\n    const pixie = new PIXI.spine.Spine(pixieAsset.spineData);\n\n    const scale = 0.3;\n\n    pixie.x = 1024 / 3;\n    pixie.y = 500;\n\n    pixie.scale.x = pixie.scale.y = scale;\n\n    app.stage.addChild(pixie);\n\n    pixie.stateData.setMix('running', 'jump', 0.2);\n    pixie.stateData.setMix('jump', 'running', 0.4);\n\n    pixie.state.setAnimation(0, 'running', true);\n\n    app.stage.on('pointerdown', onTouchStart);\n\n    function onTouchStart() {\n        pixie.state.setAnimation(0, 'jump', false);\n        pixie.state.addAnimation(0, 'running', true, 0);\n    }\n\n    app.ticker.add(() => {\n        postition += 10;\n\n        background.x = -(postition * 0.6);\n        background.x %= 1286 * 2;\n        if (background.x < 0) {\n            background.x += 1286 * 2;\n        }\n        background.x -= 1286;\n\n        background2.x = -(postition * 0.6) + 1286;\n        background2.x %= 1286 * 2;\n        if (background2.x < 0) {\n            background2.x += 1286 * 2;\n        }\n        background2.x -= 1286;\n\n        foreground.x = -postition;\n        foreground.x %= 1286 * 2;\n        if (foreground.x < 0) {\n            foreground.x += 1286 * 2;\n        }\n        foreground.x -= 1286;\n\n        foreground2.x = -postition + 1286;\n        foreground2.x %= 1286 * 2;\n        if (foreground2.x < 0) {\n            foreground2.x += 1286 * 2;\n        }\n        foreground2.x -= 1286;\n    });\n}\n",
          "exists": true,
          "plugins": [
            "pixi-spine"
          ]
        },
        {
          "title": "Spineboy Walking",
          "entry": "spineboy.js",
          "path": "plugin-spine/spineboy.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// load spine data\nPIXI.Assets.load('examples/assets/pixi-spine/spineboy.json').then(onAssetsLoaded);\n\nfunction onAssetsLoaded(spineboyAsset) {\n    app.stage.interactive = true;\n\n    // create a spine boy\n    const spineBoy = new PIXI.spine.Spine(spineboyAsset.spineData);\n\n    // set the position\n    spineBoy.x = app.screen.width / 2;\n    spineBoy.y = app.screen.height;\n\n    spineBoy.scale.set(1.5);\n\n    // set up the mixes!\n    spineBoy.stateData.setMix('walk', 'jump', 0.2);\n    spineBoy.stateData.setMix('jump', 'walk', 0.4);\n\n    // play animation\n    spineBoy.state.setAnimation(0, 'walk', true);\n\n    app.stage.addChild(spineBoy);\n\n    app.stage.on('pointerdown', () => {\n        spineBoy.state.setAnimation(0, 'jump', false);\n        spineBoy.state.addAnimation(0, 'walk', true, 0);\n    });\n}\n",
          "exists": true,
          "plugins": [
            "pixi-spine"
          ]
        },
        {
          "title": "Spineboy Pro",
          "entry": "spineboy-pro.js",
          "path": "plugin-spine/spineboy-pro.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// load spine data\nPIXI.Assets.load('examples/assets/pixi-spine/spineboy-pro.json').then(onAssetsLoaded);\n\nfunction onAssetsLoaded(spineboyAsset) {\n    app.stage.interactive = true;\n\n    // create a spine boy\n    const spineBoyPro = new PIXI.spine.Spine(spineboyAsset.spineData);\n\n    // set the position\n    spineBoyPro.x = app.screen.width / 2;\n    spineBoyPro.y = app.screen.height;\n\n    spineBoyPro.scale.set(0.5);\n\n    app.stage.addChild(spineBoyPro);\n\n    const singleAnimations = ['aim', 'death', 'jump', 'portal'];\n    const loopAnimations = ['hoverboard', 'idle', 'run', 'shoot', 'walk'];\n    const allAnimations = [].concat(singleAnimations, loopAnimations);\n\n    let lastAnimation = '';\n\n    // Press the screen to play a random animation\n    app.stage.on('pointerdown', () => {\n        let animation = '';\n        do {\n            animation = allAnimations[Math.floor(Math.random() * allAnimations.length)];\n        } while (animation === lastAnimation);\n\n        spineBoyPro.state.setAnimation(0, animation, loopAnimations.includes(animation));\n\n        lastAnimation = animation;\n    });\n}\n",
          "exists": true,
          "plugins": [
            "pixi-spine"
          ]
        },
        {
          "title": "Spineboy Debugger",
          "entry": "spineboy-debug.js",
          "path": "plugin-spine/spineboy-debug.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// load spine data\nPIXI.Assets.load(['examples/assets/pixi-spine/spineboy-pro.json', 'examples/assets/pixi-spine/spineboy.json']).then(onAssetsLoaded);\n\n\nfunction onAssetsLoaded(spineAssets) {\n    app.stage.interactive = true;\n\n    const spineboyProAsset = spineAssets['examples/assets/pixi-spine/spineboy-pro.json'];\n    const spineboyAsset = spineAssets['examples/assets/pixi-spine/spineboy.json'];\n\n    // create a spine boy pro\n    const spineBoyPro = new PIXI.spine.Spine(spineboyProAsset.spineData);\n\n    // set the position\n    spineBoyPro.x = app.screen.width * 0.25;\n    spineBoyPro.y = app.screen.height * 0.9;\n\n    spineBoyPro.scale.set(0.5);\n\n    app.stage.addChild(spineBoyPro);\n\n    const singleAnimations = ['aim', 'death', 'jump', 'portal'];\n    const loopAnimations = ['hoverboard', 'idle', 'run', 'shoot', 'walk'];\n    const allAnimations = [].concat(singleAnimations, loopAnimations);\n\n    let lastAnimation = '';\n\n\n    // create a spine boy\n    const spineBoy = new PIXI.spine.Spine(spineboyAsset.spineData);\n\n    // set the position\n    spineBoy.x = app.screen.width * 0.75;\n    spineBoy.y = app.screen.height * 0.9;\n\n    spineBoy.scale.set(1.5);\n\n    // set up the mixes!\n    spineBoy.stateData.setMix('walk', 'jump', 0.2);\n    spineBoy.stateData.setMix('jump', 'walk', 0.4);\n\n    // play animation\n    spineBoy.state.setAnimation(0, 'walk', true);\n\n    app.stage.addChild(spineBoy);\n\n    app.stage.on('pointerdown', () => {\n\n    });\n\n\n    // Press the screen to play a random animation\n    app.stage.on('pointerdown', () => {\n        let animation = '';\n        do {\n            animation = allAnimations[Math.floor(Math.random() * allAnimations.length)];\n        } while (animation === lastAnimation);\n\n        spineBoyPro.state.setAnimation(0, animation, loopAnimations.includes(animation));\n\n        lastAnimation = animation;\n\n        spineBoy.state.setAnimation(0, 'jump', false);\n        spineBoy.state.addAnimation(0, 'walk', true, 0);\n    });\n\n\n    // ENABLE THE DEBUG!\n    spineBoy.debug = new PIXI.spine.SpineDebugRenderer();\n    spineBoyPro.debug = new PIXI.spine.SpineDebugRenderer();\n}\n",
          "exists": true,
          "plugins": [
            "pixi-spine"
          ]
        }
      ]
    },
    {
      "id": "plugin-dragonbones",
      "title": "Plugin Dragonbones",
      "examples": [
        {
          "title": "Robot",
          "entry": "robot.js",
          "path": "plugin-dragonbones/robot.js",
          "code": "const app = new PIXI.Application({ antialias: true });\ndocument.body.appendChild(app.view);\n\napp.stop();\n\n// load spine data\nPIXI.Loader.shared\n    .add('skeleton', 'examples/assets/pixi-dragonbones/robot/mecha_1002_101d_show_ske.json')\n    .add('texture_json', 'examples/assets/pixi-dragonbones/robot/mecha_1002_101d_show_tex.json')\n    .add('texture_png', 'examples/assets/pixi-dragonbones/robot/mecha_1002_101d_show_tex.png')\n    .load(onAssetsLoaded);\n\nfunction onAssetsLoaded(loader, res) {\n    const factory = dragonBones.PixiFactory.factory;\n\n    factory.parseDragonBonesData(res.skeleton.data);\n    factory.parseTextureAtlasData(res.texture_json.data, res.texture_png.texture);\n\n    const armatureDisplay = factory.buildArmatureDisplay('mecha_1002_101d', 'mecha_1002_101d_show');\n    armatureDisplay.animation.play('idle');\n    armatureDisplay.x = 400.0;\n    armatureDisplay.y = 500.0;\n\n    app.stage.addChild(armatureDisplay);\n\n    app.start();\n}\n",
          "exists": true,
          "plugins": [
            "pixi-dragonbones"
          ]
        },
        {
          "title": "Eye Tracking",
          "entry": "eyetracking.js",
          "path": "plugin-dragonbones/eyetracking.js",
          "code": "const app = new PIXI.Application({ antialias: true });\ndocument.body.appendChild(app.view);\n\napp.stop();\n\nconst scale = 0.3;\nconst target = new PIXI.Point();\nlet armatureDisplay;\n\nconst animationNames = [\n    'PARAM_ANGLE_X',\n    'PARAM_ANGLE_Y',\n    'PARAM_ANGLE_Z',\n    'PARAM_EYE_BALL_X',\n    'PARAM_EYE_BALL_Y',\n    'PARAM_BODY_X',\n    'PARAM_BODY_Y',\n    'PARAM_BODY_Z',\n    'PARAM_BODY_ANGLE_X',\n    'PARAM_BODY_ANGLE_Y',\n    'PARAM_BODY_ANGLE_Z',\n    'PARAM_BREATH',\n];\n\n// load spine data\nPIXI.Loader.shared\n    .add('skeleton', 'examples/assets/pixi-dragonbones/eyetracking/shizuku_ske.json')\n    .add('texture_png_0', 'examples/assets/pixi-dragonbones/eyetracking/texture_00.png')\n    .add('texture_png_1', 'examples/assets/pixi-dragonbones/eyetracking/texture_01.png')\n    .add('texture_png_2', 'examples/assets/pixi-dragonbones/eyetracking/texture_02.png')\n    .add('texture_png_3', 'examples/assets/pixi-dragonbones/eyetracking/texture_03.png')\n    .load(onAssetsLoaded);\n\nfunction onAssetsLoaded(loader, res) {\n    const factory = dragonBones.PixiFactory.factory;\n\n    factory.parseDragonBonesData(res.skeleton.data, 'shizuku');\n    factory.updateTextureAtlases([res.texture_png_0.texture, res.texture_png_1.texture, res.texture_png_2.texture, res.texture_png_3.texture], 'shizuku');\n    armatureDisplay = factory.buildArmatureDisplay('shizuku', 'shizuku');\n    armatureDisplay.animation.play('idle_00');\n    armatureDisplay.x = 400.0;\n    armatureDisplay.y = 500.0;\n    armatureDisplay.scale.set(scale, scale);\n    app.stage.addChild(armatureDisplay);\n\n    app.stage.interactive = true;\n    app.stage.on('touchmove', touchHandler);\n    app.stage.on('mousemove', touchHandler);\n\n    PIXI.Ticker.shared.add(enterFrameHandler);\n\n    app.start();\n}\n\nfunction touchHandler(event) {\n    const x = event.data.global.x;\n    const y = event.data.global.y;\n\n    target.x += ((x - app.stage.x - armatureDisplay.x) / 0.4 - target.x) * 0.3;\n    target.y += ((y - app.stage.y - armatureDisplay.y) / scale - target.y) * 0.3;\n}\n\nfunction enterFrameHandler(deltaTime) {\n    const armature = armatureDisplay.armature;\n    const animation = armatureDisplay.animation;\n    const canvas = armature.armatureData.canvas;\n\n    let p = 0.0;\n    const pX = Math.max(Math.min((target.x - canvas.x) / (canvas.width * 0.5), 1.0), -1.0);\n    const pY = -Math.max(Math.min((target.y - canvas.y) / (canvas.height * 0.5), 1.0), -1.0);\n    for (const animationName of animationNames) {\n        if (animation.hasAnimation(animationName)) {\n            let animationState = animation.getState(animationName, 1);\n            if (!animationState) {\n                animationState = animation.fadeIn(animationName, 0.1, 1, 1, animationName);\n                if (animationState) {\n                    animationState.resetToPose = false;\n                    animationState.stop();\n                }\n            }\n\n            if (animationState) {\n                switch (animationName) {\n                    case 'PARAM_ANGLE_X':\n                    case 'PARAM_EYE_BALL_X':\n                        p = (pX + 1.0) * 0.5;\n                        break;\n\n                    case 'PARAM_ANGLE_Y':\n                    case 'PARAM_EYE_BALL_Y':\n                        p = (pY + 1.0) * 0.5;\n                        break;\n\n                    case 'PARAM_ANGLE_Z':\n                        p = (-pX * pY + 1.0) * 0.5;\n                        break;\n\n                    case 'PARAM_BODY_X':\n                    case 'PARAM_BODY_ANGLE_X':\n                        p = (pX + 1.0) * 0.5;\n                        break;\n\n                    case 'PARAM_BODY_Y':\n                    case 'PARAM_BODY_ANGLE_Y':\n                        p = (-pX * pY + 1.0) * 0.5;\n                        break;\n\n                    case 'PARAM_BODY_Z':\n                    case 'PARAM_BODY_ANGLE_Z':\n                        p = (-pX * pY + 1.0) * 0.5;\n                        break;\n\n                    case 'PARAM_BREATH':\n                        p = (Math.sin(armature.clock.time) + 1.0) * 0.5;\n                        break;\n\n                    default:\n                        break;\n                }\n\n                animationState.currentTime = p * animationState.totalTime;\n            }\n        }\n    }\n}\n",
          "exists": true,
          "plugins": [
            "pixi-dragonbones"
          ]
        }
      ]
    },
    {
      "id": "plugin-heaven",
      "title": "Plugin Heaven",
      "examples": [
        {
          "title": "Invert",
          "entry": "invert.js",
          "path": "plugin-heaven/invert.js",
          "code": "// the plugin is here: https://github.com/gameofbombs/pixi-heaven/tree/master\n\nconst app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// create a new Sprite from an image path\nconst bunny = new PIXI.heaven.SpriteH(PIXI.Texture.from('examples/assets/bunny.png'));\n\n// Let us invert the colors!\nbunny.color.setLight(0.0, 0.0, 0.0);\nbunny.color.setDark(1.0, 1.0, 1.0);\n\n// center the sprite's anchor point\nbunny.anchor.set(0.5);\nbunny.scale.set(3.0);\n\n// move the sprite to the center of the screen\nbunny.x = app.screen.width / 2;\nbunny.y = app.screen.height / 2;\n\napp.stage.addChild(bunny);\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // just for fun, let's rotate mr rabbit a little\n    // delta is 1 if running at 100% performance\n    // creates frame-independent transformation\n    bunny.rotation += 0.1 * delta;\n});\n",
          "exists": true,
          "plugins": [
            "pixi-heaven"
          ]
        },
        {
          "title": "Polygon Packing",
          "entry": "polygon.js",
          "path": "plugin-heaven/polygon.js",
          "code": "// the plugin is here: https://github.com/gameofbombs/pixi-heaven/tree/master\n\nconst app = new PIXI.Application({ background: '#1099bb', autoStart: false });\ndocument.body.appendChild(app.view);\n\nconst container = new PIXI.Container();\napp.stage.addChild(container);\n\napp.loader.add('dudes', 'examples/assets/polygon/dudes.json');\napp.loader.load((loader, resources) => {\n    const keys = Object.keys(resources.dudes.textures);\n    const textures = keys.map((x) => resources.dudes.textures[x]);\n\n    // Create a 5x5 grid of bunnies\n    for (let i = 0; i < 25; i++) {\n        const bunny = new PIXI.heaven.SpriteH(textures[i % textures.length]);\n\n        const graphics = new PIXI.Graphics();\n        genWireframe(bunny, graphics);\n        bunny.addChild(graphics);\n\n        bunny.scale.set(0.5);\n        bunny.x = (i % 5) * 90;\n        bunny.y = Math.floor(i / 5) * 100;\n\n        container.addChild(bunny);\n    }\n\n    // Move container to the center\n    container.x = app.screen.width / 2;\n    container.y = app.screen.height / 2;\n\n    // Center bunny sprite in local container coordinates\n    container.pivot.x = container.width / 2;\n    container.pivot.y = container.height / 2;\n\n    app.start();\n});\n\nfunction genWireframe(sprite, graphics) {\n    sprite.calculateVertices();\n\n    const indices = sprite.indices;\n    const vertices = sprite.vertexData;\n\n    graphics.lineStyle(4.0, Math.random() * 0xffffff | 0);\n    // generating it in current sprite world coords.\n    // they are local if sprite wasnt added yet\n    console.log(indices);\n    console.log(vertices);\n    for (let i = 0; i < indices.length; i += 3) {\n        let ind = indices[i + 2];\n        graphics.moveTo(vertices[ind * 2], vertices[ind * 2 + 1]);\n        for (let j = 0; j < 3; j++) {\n            ind = indices[i + j];\n            graphics.lineTo(vertices[ind * 2], vertices[ind * 2 + 1]);\n        }\n    }\n\n    return graphics;\n}\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // rotate the container!\n    // use delta to create frame-independent transform\n    container.rotation -= 0.01 * delta;\n});\n",
          "exists": true,
          "plugins": [
            "pixi-heaven"
          ]
        },
        {
          "title": "Decals",
          "entry": "decals.js",
          "path": "plugin-heaven/decals.js",
          "code": "// the plugin is here: https://github.com/gameofbombs/pixi-heaven/tree/master\n\nconst app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\napp.loader.add('bunny', 'examples/assets/bunny.png');\napp.loader.load(onComplete);\n\nfunction onComplete(loader, resources) {\n    const bunnyTex = resources.bunny.texture;\n    bunnyTex.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\n\n    const bunny = new PIXI.heaven.SpriteH(bunnyTex);\n    bunny.position.set(100, 100);\n    bunny.scale.set(10);\n\n    const W = bunny.width;\n    const H = bunny.height;\n\n    const maskRT = PIXI.RenderTexture.create(W, H, 1);\n    const blackGraphics = new PIXI.Graphics();\n    blackGraphics.beginFill(0);\n    blackGraphics.drawRect(0, 0, W, H);\n\n    const whiteBunny = new PIXI.heaven.SpriteH(bunnyTex);\n    whiteBunny.scale.set(10);\n    whiteBunny.color.setDark(1.0, 1.0, 1.0);\n    app.renderer.render(blackGraphics, maskRT, false);\n    app.renderer.render(whiteBunny, maskRT, false);\n\n    const decalRT = PIXI.RenderTexture.create({ width: W, height: H, scaleMode: PIXI.SCALE_MODES.NEAREST });\n    const decals = new PIXI.Container();\n    for (let i = 0; i < 100; i++) {\n        const randomBunny = new PIXI.heaven.SpriteH(bunnyTex);\n        randomBunny.position.set(Math.random() * W | 0, Math.random() * H | 0);\n        randomBunny.color.setLight(Math.random(), Math.random(), Math.random());\n        randomBunny.color.setDark(Math.random(), Math.random(), Math.random());\n        decals.addChild(randomBunny);\n    }\n    app.renderer.render(decals, decalRT);\n\n    const maskSprite = new PIXI.heaven.SpriteH(maskRT);\n    const decalSprite = new PIXI.heaven.SpriteH(decalRT);\n\n    maskSprite.position = bunny.position;\n    decalSprite.position = bunny.position;\n    maskSprite.renderable = false;\n    decalSprite.maskSprite = maskSprite;\n    decalSprite.pluginName = 'batchMasked';\n\n    app.stage.addChild(bunny);\n    app.stage.addChild(maskSprite);\n    app.stage.addChild(decalSprite);\n}\n",
          "exists": true,
          "plugins": [
            "pixi-heaven"
          ]
        },
        {
          "title": "Batching ADD",
          "entry": "unity-add-blend.js",
          "path": "plugin-heaven/unity-add-blend.js",
          "code": "/**\n * All sprites are in separate container that is filtered / masked\n * with this setting, ADD blendMode works through that filter and affect background\n * also ADD batches together with NORMAL\n */\n\nPIXI.heaven.settings.BLEND_ADD_UNITY = true;\n\nconst app = new PIXI.Application({ backgroundAlpha: 0 });\ndocument.body.appendChild(app.view);\n\n// create a new background sprite\nconst background = PIXI.Sprite.from('examples/assets/bg_rotate.jpg');\nbackground.width = app.screen.width / 2;\nbackground.height = app.screen.height;\n\nconst background2 = PIXI.Sprite.from('examples/assets/bg_rotate.jpg');\nbackground2.width = app.screen.width / 2;\nbackground2.height = app.screen.height;\nbackground2.position.set(app.screen.width / 2, 0);\nbackground2.alpha = 0.5;\n\napp.stage.addChild(background, background2);\n\n// create an array to store a reference to the dudes\nconst dudeArray = [];\n\nconst totaldudes = 20;\n\nconst dudeContainer = new PIXI.Container();\ndudeContainer.filterArea = app.screen;\ndudeContainer.filters = [new PIXI.filters.AlphaFilter()];\napp.stage.addChild(dudeContainer);\n\nfor (let i = 0; i < totaldudes; i++) {\n    // create a new Sprite that uses the image name that we just generated as its source\n    const dude = new PIXI.heaven.SpriteH(PIXI.Texture.from('examples/assets/flowerTop.png'));\n\n    dude.anchor.set(0.5);\n\n    // set a random scale for the dude\n    dude.scale.set(0.8 + Math.random() * 0.3);\n\n    // finally let's set the dude to be at a random position...\n    dude.x = Math.floor(Math.random() * app.screen.width);\n    dude.y = Math.floor(Math.random() * app.screen.height);\n\n    // The important bit of this example, this is how you change the default blend mode of the sprite\n    if (Math.random() < 0.5) {\n        dude.blendMode = PIXI.BLEND_MODES.ADD;\n    }\n\n    // create some extra properties that will control movement\n    dude.direction = Math.random() * Math.PI * 2;\n\n    // this number will be used to modify the direction of the dude over time\n    dude.turningSpeed = Math.random() - 0.8;\n\n    // create a random speed for the dude between 0 - 2\n    dude.speed = 2 + Math.random() * 2;\n\n    // finally we push the dude into the dudeArray so it it can be easily accessed later\n    dudeArray.push(dude);\n\n    dudeContainer.addChild(dude);\n}\n\n// create a bounding box for the little dudes\nconst dudeBoundsPadding = 100;\n\nconst dudeBounds = new PIXI.Rectangle(\n    -dudeBoundsPadding,\n    -dudeBoundsPadding,\n    app.screen.width + dudeBoundsPadding * 2,\n    app.screen.height + dudeBoundsPadding * 2,\n);\n\napp.ticker.add(() => {\n    // iterate through the dudes and update the positions\n    for (let i = 0; i < dudeArray.length; i++) {\n        const dude = dudeArray[i];\n        dude.direction += dude.turningSpeed * 0.01;\n        dude.x += Math.sin(dude.direction) * dude.speed;\n        dude.y += Math.cos(dude.direction) * dude.speed;\n        dude.rotation = -dude.direction - Math.PI / 2;\n\n        // wrap the dudes by testing their bounds...\n        if (dude.x < dudeBounds.x) {\n            dude.x += dudeBounds.width;\n        } else if (dude.x > dudeBounds.x + dudeBounds.width) {\n            dude.x -= dudeBounds.width;\n        }\n\n        if (dude.y < dudeBounds.y) {\n            dude.y += dudeBounds.height;\n        } else if (dude.y > dudeBounds.y + dudeBounds.height) {\n            dude.y -= dudeBounds.height;\n        }\n    }\n});\n",
          "exists": true,
          "plugins": [
            "pixi-heaven"
          ]
        },
        {
          "title": "Spine support",
          "entry": "spineboy-pro.js",
          "path": "plugin-heaven/spineboy-pro.js",
          "code": "// the plugin is here: https://github.com/gameofbombs/pixi-heaven/tree/master\n\nconst app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nPIXI.heaven.applySpineMixin(PIXI.spine.Spine.prototype);\n\n// load spine data\napp.loader\n    .add('spineboypro', 'examples/assets/pixi-spine/spineboy-pro.json')\n    .load(onAssetsLoaded);\n\napp.stage.interactive = true;\n\nfunction onAssetsLoaded(loader, res) {\n    // create a spine boy\n    const spineBoyPro = new PIXI.spine.Spine(res.spineboypro.spineData);\n\n    // set the position\n    spineBoyPro.x = app.screen.width / 2;\n    spineBoyPro.y = app.screen.height;\n\n    spineBoyPro.scale.set(0.5);\n\n    app.stage.addChild(spineBoyPro);\n\n    const singleAnimations = ['aim', 'death', 'jump', 'portal'];\n    const loopAnimations = ['hoverboard', 'idle', 'run', 'shoot', 'walk'];\n    const allAnimations = [].concat(singleAnimations, loopAnimations);\n\n    let lastAnimation = '';\n\n    // Press the screen to play a random animation\n    app.stage.on('pointerdown', () => {\n        let animation = '';\n        do {\n            animation = allAnimations[Math.floor(Math.random() * allAnimations.length)];\n        } while (animation === lastAnimation);\n\n        spineBoyPro.state.setAnimation(0, animation, loopAnimations.includes(animation));\n\n        lastAnimation = animation;\n    });\n\n    let phase = 0;\n    app.ticker.add(() => {\n        phase += 0.1;\n        const x = Math.sin(phase) * 0.25 + 0.25;\n        spineBoyPro.color.setDark(x, x, x);\n    });\n}\n",
          "exists": true,
          "plugins": [
            "pixi-spine",
            "pixi-heaven"
          ]
        }
      ]
    },
    {
      "id": "plugin-projection",
      "title": "Plugin Projection",
      "examples": [
        {
          "title": "2D Basics",
          "entry": "basic.js",
          "path": "plugin-projection/basic.js",
          "code": "const app = new PIXI.Application({ backgroundColor: 0x103322 });\ndocument.body.appendChild(app.view);\n\nconst squareX = new PIXI.Sprite(PIXI.Texture.WHITE);\nsquareX.tint = 0xff0000;\nsquareX.factor = 1;\nsquareX.anchor.set(0.5);\nsquareX.position.set(app.screen.width - 100, app.screen.height / 2);\n\nconst squareY = new PIXI.Sprite(PIXI.Texture.WHITE);\nsquareY.tint = 0xff0000;\nsquareY.factor = 1;\nsquareY.anchor.set(0.5);\nsquareY.position.set(app.screen.width / 2, app.screen.height - 100);\n\n// create a new Sprite from an image path\nconst container = new PIXI.projection.Container2d();\ncontainer.position.set(app.screen.width / 2, app.screen.height / 2);\n\napp.stage.addChild(container);\napp.stage.addChild(squareX);\napp.stage.addChild(squareY);\n\n// add sprite itself\n\nconst bunny = new PIXI.projection.Sprite2d(PIXI.Texture.from('examples/assets/flowerTop.png'));\nbunny.anchor.set(0.5);\nbunny.scale.set(0.7);\ncontainer.addChild(bunny);\n\n// illuminate the sprite from two points!\nconst lightY = new PIXI.projection.Sprite2d(PIXI.Texture.WHITE);\nlightY.anchor.set(0.5, 0.1);\nlightY.scale.set(15, 200);\nlightY.alpha = 0.2;\ncontainer.addChildAt(lightY, 0);\n\nconst lightX = new PIXI.projection.Sprite2d(PIXI.Texture.WHITE);\nlightX.anchor.set(0.1, 0.5);\nlightX.scale.set(200, 15);\nlightX.alpha = 0.2;\ncontainer.addChildAt(lightX, 1);\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // now we can get local coords for points of perspective\n    const posX = container.toLocal(squareX.position, undefined, undefined, undefined, PIXI.projection.TRANSFORM_STEP.BEFORE_PROJ);\n    const posY = container.toLocal(squareY.position, undefined, undefined, undefined, PIXI.projection.TRANSFORM_STEP.BEFORE_PROJ);\n    container.proj.setAxisX(posX, squareX.factor);\n    container.proj.setAxisY(posY, squareY.factor);\n});\n\naddInteraction(squareX);\naddInteraction(squareY);\n// move the bunny too!\naddInteraction(bunny);\n\n// === CLICKS AND SNAP ===\n\n// changes axis factor\nfunction toggle(obj) {\n    if (obj !== bunny) {\n        obj.factor = 1.0 - obj.factor;\n        obj.tint = obj.factor ? 0xff0033 : 0x00ff00;\n    }\n}\n\nfunction snap(obj) {\n    if (obj === bunny) {\n        obj.position.set(0);\n    } else {\n        obj.position.x = Math.min(Math.max(obj.position.x, 0), app.screen.width);\n        obj.position.y = Math.min(Math.max(obj.position.y, 0), app.screen.height);\n    }\n}\n\n// === INTERACTION CODE  ===\n\nfunction addInteraction(obj) {\n    obj.interactive = true;\n    obj\n        .on('pointerdown', onDragStart)\n        .on('pointerup', onDragEnd)\n        .on('pointerupoutside', onDragEnd)\n        .on('pointermove', onDragMove);\n}\n\nfunction onDragStart(event) {\n    const obj = event.currentTarget;\n    obj.dragData = event.data;\n    obj.dragging = 1;\n    obj.dragPointerStart = event.data.getLocalPosition(obj.parent);\n    obj.dragObjStart = new PIXI.Point();\n    obj.dragObjStart.copyFrom(obj.position);\n    obj.dragGlobalStart = new PIXI.Point();\n    obj.dragGlobalStart.copyFrom(event.data.global);\n}\n\nfunction onDragEnd(event) {\n    const obj = event.currentTarget;\n    if (!obj.dragging) return;\n    if (obj.dragging === 1) {\n        toggle(obj);\n    } else {\n        snap(obj);\n    }\n\n    obj.dragging = 0;\n    obj.dragData = null;\n    // set the interaction data to null\n}\n\nfunction onDragMove(event) {\n    const obj = event.currentTarget;\n    if (!obj.dragging) return;\n    const data = obj.dragData; // it can be different pointer!\n    if (obj.dragging === 1) {\n    // click or drag?\n        if (Math.abs(data.global.x - obj.dragGlobalStart.x)\n            + Math.abs(data.global.y - obj.dragGlobalStart.y) >= 3) {\n            // DRAG\n            obj.dragging = 2;\n        }\n    }\n    if (obj.dragging === 2) {\n        const dragPointerEnd = data.getLocalPosition(obj.parent);\n        // DRAG\n        obj.position.set(\n            obj.dragObjStart.x + (dragPointerEnd.x - obj.dragPointerStart.x),\n            obj.dragObjStart.y + (dragPointerEnd.y - obj.dragPointerStart.y),\n        );\n    }\n}\n",
          "exists": true,
          "plugins": [
            "pixi-projection"
          ]
        },
        {
          "title": "2D Plane",
          "entry": "plane.js",
          "path": "plugin-projection/plane.js",
          "code": "const app = new PIXI.Application({ backgroundColor: 0x103322 });\ndocument.body.appendChild(app.view);\n\nconst bigWhiteTexture = new PIXI.Texture(PIXI.Texture.WHITE.baseTexture);\nbigWhiteTexture.orig.width = 30;\nbigWhiteTexture.orig.height = 30;\n\nconst squareFar = new PIXI.Sprite(bigWhiteTexture);\nsquareFar.tint = 0xff0000;\nsquareFar.factor = 1;\nsquareFar.anchor.set(0.5);\nsquareFar.position.set(app.screen.width / 2, 50);\n\n// create a new Sprite from an image path\nconst container = new PIXI.projection.Container2d();\ncontainer.position.set(app.screen.width / 2, app.screen.height);\n\nconst surface = new PIXI.projection.Sprite2d(PIXI.Texture.from('examples/assets/bg_plane.jpg'));\nsurface.anchor.set(0.5, 1.0);\n// surface.scale.y = -1; //sorry, have to do that to make a correct projection\nsurface.width = app.screen.width;\nsurface.height = app.screen.height;\n// var squarePlane = new PIXI.projection.Sprite2d(PIXI.Texture.from('examples/assets/flowerTop.png'));\nconst squarePlane = new PIXI.projection.Sprite2d(bigWhiteTexture);\nsquarePlane.tint = 0xff0000;\nsquarePlane.factor = 1;\nsquarePlane.proj.affine = PIXI.projection.AFFINE.AXIS_X;\nsquarePlane.anchor.set(0.5, 0.0);\nsquarePlane.position.set(-app.screen.width / 4, -app.screen.height / 2);\n\nconst bunny = new PIXI.projection.Sprite2d(PIXI.Texture.from('examples/assets/flowerTop.png'));\nbunny.anchor.set(0.5, 1.0);\n\napp.stage.addChild(container);\napp.stage.addChild(squareFar);\ncontainer.addChild(surface);\ncontainer.addChild(squarePlane);\nsquarePlane.addChild(bunny);\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    const pos = container.toLocal(squareFar.position, undefined, undefined, undefined, PIXI.projection.TRANSFORM_STEP.BEFORE_PROJ);\n    // need to invert this thing, otherwise we'll have to use scale.y=-1 which is not good\n    pos.y = -pos.y;\n    pos.x = -pos.x;\n    container.proj.setAxisY(pos, -squareFar.factor);\n\n    squarePlane.proj.affine = squarePlane.factor\n        ? PIXI.projection.AFFINE.AXIS_X : PIXI.projection.AFFINE.NONE;\n    squarePlane.rotation += 0.1;\n});\n\naddInteraction(squareFar);\naddInteraction(squarePlane);\n// move the bunny too!\naddInteraction(bunny);\n\n// === CLICKS AND SNAP ===\n\n// changes axis factor\nfunction toggle(obj) {\n    if (obj !== bunny) {\n        obj.factor = 1.0 - obj.factor;\n        obj.tint = obj.factor ? 0xff0033 : 0x00ff00;\n    }\n}\n\nfunction snap(obj) {\n    if (obj === bunny) {\n        obj.position.set(0);\n    } else if (obj === squarePlane) {\n    // plane bounds\n        obj.position.x = Math.min(Math.max(obj.position.x, -app.screen.width / 2 + 10), app.screen.width / 2 - 10);\n        obj.position.y = Math.min(Math.max(obj.position.y, -app.screen.height + 10), 10);\n    } else {\n    // far\n        obj.position.x = Math.min(Math.max(obj.position.x, 0), app.screen.width);\n        obj.position.y = Math.min(Math.max(obj.position.y, 0), app.screen.height);\n    }\n}\n\n// === INTERACTION CODE  ===\n\nfunction addInteraction(obj) {\n    obj.interactive = true;\n    obj\n        .on('pointerdown', onDragStart)\n        .on('pointerup', onDragEnd)\n        .on('pointerupoutside', onDragEnd)\n        .on('pointermove', onDragMove);\n}\n\nfunction onDragStart(event) {\n    const obj = event.currentTarget;\n    obj.dragData = event.data;\n    obj.dragging = 1;\n    obj.dragPointerStart = event.data.getLocalPosition(obj.parent);\n    obj.dragObjStart = new PIXI.Point();\n    obj.dragObjStart.copyFrom(obj.position);\n    obj.dragGlobalStart = new PIXI.Point();\n    obj.dragGlobalStart.copyFrom(event.data.global);\n    event.stopPropagation();\n}\n\nfunction onDragEnd(event) {\n    const obj = event.currentTarget;\n    if (!obj.dragging) return;\n    if (obj.dragging === 1) {\n        toggle(obj);\n    } else {\n        snap(obj);\n    }\n\n    obj.dragging = 0;\n    obj.dragData = null;\n\n    event.stopPropagation();\n    // set the interaction data to null\n}\n\nfunction onDragMove(event) {\n    const obj = event.currentTarget;\n    if (!obj.dragging) return;\n    event.stopPropagation();\n    const data = obj.dragData; // it can be different pointer!\n    if (obj.dragging === 1) {\n    // click or drag?\n        if (Math.abs(data.global.x - obj.dragGlobalStart.x)\n            + Math.abs(data.global.y - obj.dragGlobalStart.y) >= 3) {\n            // DRAG\n            obj.dragging = 2;\n        }\n    }\n    if (obj.dragging === 2) {\n        const dragPointerEnd = data.getLocalPosition(obj.parent);\n        // DRAG\n        obj.position.set(\n            obj.dragObjStart.x + (dragPointerEnd.x - obj.dragPointerStart.x),\n            obj.dragObjStart.y + (dragPointerEnd.y - obj.dragPointerStart.y),\n        );\n    }\n}\n",
          "exists": true,
          "plugins": [
            "pixi-projection"
          ]
        },
        {
          "title": "2D Plane Tiling",
          "entry": "plane-tiling.js",
          "path": "plugin-projection/plane-tiling.js",
          "code": "const app = new PIXI.Application({ backgroundColor: 0x103322 });\ndocument.body.appendChild(app.view);\n\nconst squareFar = new PIXI.Sprite(PIXI.Texture.WHITE);\nsquareFar.tint = 0xff0000;\nsquareFar.factor = 1;\nsquareFar.anchor.set(0.5);\nsquareFar.position.set(app.screen.width / 2, 50);\n\n// create a new Sprite from an image path\nconst container = new PIXI.projection.Container2d();\ncontainer.position.set(app.screen.width / 2, app.screen.height);\n\n// tiling - takes whole screen, anchor and position are the same as of sprite surface\n// different tint, to see the black part\nconst tiling = new PIXI.projection.TilingSprite2d(PIXI.Texture.from('examples/assets/bg_plane.jpg'), app.screen.width, app.screen.height);\ntiling.position.set(app.screen.width / 2, app.screen.height);\ntiling.anchor.set(0.5, 1.0);\ntiling.tint = 0x808080;\n\nconst surface = new PIXI.projection.Sprite2d(PIXI.Texture.from('examples/assets/bg_plane.jpg'));\nsurface.anchor.set(0.5, 1.0);\n// surface.scale.y = -1; //sorry, have to do that to make a correct projection\nsurface.width = app.screen.width;\nsurface.height = app.screen.height;\n// var squarePlane = new PIXI.projection.Sprite2d(PIXI.Texture.from('examples/assets/flowerTop.png'));\nconst squarePlane = new PIXI.projection.Sprite2d(PIXI.Texture.WHITE);\nsquarePlane.tint = 0xff0000;\nsquarePlane.factor = 1;\nsquarePlane.proj.affine = PIXI.projection.AFFINE.AXIS_X;\nsquarePlane.anchor.set(0.5, 0.0);\nsquarePlane.position.set(-app.screen.width / 4, -app.screen.height / 2);\n\nconst bunny = new PIXI.projection.Sprite2d(PIXI.Texture.from('examples/assets/flowerTop.png'));\nbunny.anchor.set(0.5, 1.0);\n\napp.stage.addChild(tiling);\napp.stage.addChild(container);\napp.stage.addChild(squareFar);\ncontainer.addChild(surface);\ncontainer.addChild(squarePlane);\nsquarePlane.addChild(bunny);\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // now we can get local coords for points of perspective\n    const pos = container.toLocal(squareFar.position, undefined, undefined, undefined, PIXI.projection.TRANSFORM_STEP.BEFORE_PROJ);\n    // need to invert this thing, otherwise we'll have to use scale.y=-1 which is not good\n    pos.y = -pos.y;\n    pos.x = -pos.x;\n    container.proj.setAxisY(pos, -squareFar.factor);\n\n    tiling.tileScale.copyFrom(surface.scale);\n    // dont overflow tilePosition, shaders will have less precision\n    tiling.tilePosition.x = (tiling.tilePosition.x + delta) % tiling.texture.width;\n    // sync container proj and tiling inside proj\n    tiling.tileProj.setAxisY(pos, -squareFar.factor);\n\n    squarePlane.proj.affine = squarePlane.factor\n        ? PIXI.projection.AFFINE.AXIS_X : PIXI.projection.AFFINE.NONE;\n});\n\naddInteraction(squareFar);\naddInteraction(squarePlane);\n// move the bunny too!\naddInteraction(bunny);\n\n// === CLICKS AND SNAP ===\n\n// changes axis factor\nfunction toggle(obj) {\n    if (obj !== bunny) {\n        obj.factor = 1.0 - obj.factor;\n        obj.tint = obj.factor ? 0xff0033 : 0x00ff00;\n    }\n}\n\nfunction snap(obj) {\n    if (obj === bunny) {\n        obj.position.set(0);\n    } else if (obj === squarePlane) {\n    // plane bounds\n        obj.position.x = Math.min(Math.max(obj.position.x, -app.screen.width / 2 + 10), app.screen.width / 2 - 10);\n        obj.position.y = Math.min(Math.max(obj.position.y, -app.screen.height + 10), 10);\n    } else {\n    // far\n        obj.position.x = Math.min(Math.max(obj.position.x, 0), app.screen.width);\n        obj.position.y = Math.min(Math.max(obj.position.y, 0), app.screen.height);\n    }\n}\n\n// === INTERACTION CODE  ===\n\nfunction addInteraction(obj) {\n    obj.interactive = true;\n    obj\n        .on('pointerdown', onDragStart)\n        .on('pointerup', onDragEnd)\n        .on('pointerupoutside', onDragEnd)\n        .on('pointermove', onDragMove);\n}\n\nfunction onDragStart(event) {\n    const obj = event.currentTarget;\n    obj.dragData = event.data;\n    obj.dragging = 1;\n    obj.dragPointerStart = event.data.getLocalPosition(obj.parent);\n    obj.dragObjStart = new PIXI.Point();\n    obj.dragObjStart.copyFrom(obj.position);\n    obj.dragGlobalStart = new PIXI.Point();\n    obj.dragGlobalStart.copyFrom(event.data.global);\n    event.stopPropagation();\n}\n\nfunction onDragEnd(event) {\n    const obj = event.currentTarget;\n    if (!obj.dragging) return;\n    if (obj.dragging === 1) {\n        toggle(obj);\n    } else {\n        snap(obj);\n    }\n\n    obj.dragging = 0;\n    obj.dragData = null;\n\n    event.stopPropagation();\n    // set the interaction data to null\n}\n\nfunction onDragMove(event) {\n    const obj = event.currentTarget;\n    if (!obj.dragging) return;\n    event.stopPropagation();\n    const data = obj.dragData; // it can be different pointer!\n    if (obj.dragging === 1) {\n    // click or drag?\n        if (Math.abs(data.global.x - obj.dragGlobalStart.x)\n            + Math.abs(data.global.y - obj.dragGlobalStart.y) >= 3) {\n            // DRAG\n            obj.dragging = 2;\n        }\n    }\n    if (obj.dragging === 2) {\n        const dragPointerEnd = data.getLocalPosition(obj.parent);\n        // DRAG\n        obj.position.set(\n            obj.dragObjStart.x + (dragPointerEnd.x - obj.dragPointerStart.x),\n            obj.dragObjStart.y + (dragPointerEnd.y - obj.dragPointerStart.y),\n        );\n    }\n}\n",
          "exists": true,
          "plugins": [
            "pixi-projection"
          ]
        },
        {
          "title": "2D Quad projective",
          "entry": "quad-homo.js",
          "path": "plugin-projection/quad-homo.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nconst w = app.screen.width / 2; const\n    h = app.screen.height / 2;\n\nfunction createSquare(x, y) {\n    const square = new PIXI.Sprite(PIXI.Texture.WHITE);\n    square.tint = 0xff0000;\n    square.factor = 1;\n    square.anchor.set(0.5);\n    square.position.set(x, y);\n    return square;\n}\n\nconst squares = [\n    createSquare(w - 150, h - 150),\n    createSquare(w + 150, h - 150),\n    createSquare(w + 150, h + 150),\n    createSquare(w - 150, h + 150),\n];\n\nconst quad = squares.map((s) => s.position);\n\n// add sprite itself\nconst containerSprite = new PIXI.projection.Sprite2d(PIXI.Texture.from('examples/assets/bg_scene_rotate.jpg'));\ncontainerSprite.anchor.set(0.5);\n\napp.stage.addChild(containerSprite);\nsquares.forEach((s) => { app.stage.addChild(s); });\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    containerSprite.proj.mapSprite(containerSprite, quad);\n});\n\nsquares.forEach((s) => { addInteraction(s); });\n\n// let us add sprite to make it more funny\n\nconst bunny = new PIXI.projection.Sprite2d(PIXI.Texture.from('examples/assets/flowerTop.png'));\nbunny.anchor.set(0.5);\ncontainerSprite.addChild(bunny);\n\naddInteraction(bunny);\n\n// === INTERACTION CODE  ===\n\nfunction toggle(obj) {\n}\n\nfunction snap(obj) {\n    if (obj === bunny) {\n        obj.position.set(0);\n    } else {\n        obj.position.x = Math.min(Math.max(obj.position.x, 0), app.screen.width);\n        obj.position.y = Math.min(Math.max(obj.position.y, 0), app.screen.height);\n    }\n}\n\nfunction addInteraction(obj) {\n    obj.interactive = true;\n    obj\n        .on('pointerdown', onDragStart)\n        .on('pointerup', onDragEnd)\n        .on('pointerupoutside', onDragEnd)\n        .on('pointermove', onDragMove);\n}\n\nfunction onDragStart(event) {\n    const obj = event.currentTarget;\n    obj.dragData = event.data;\n    obj.dragging = 1;\n    obj.dragPointerStart = event.data.getLocalPosition(obj.parent);\n    obj.dragObjStart = new PIXI.Point();\n    obj.dragObjStart.copyFrom(obj.position);\n    obj.dragGlobalStart = new PIXI.Point();\n    obj.dragGlobalStart.copyFrom(event.data.global);\n}\n\nfunction onDragEnd(event) {\n    const obj = event.currentTarget;\n    if (obj.dragging === 1) {\n        toggle(obj);\n    } else {\n        snap(obj);\n    }\n    obj.dragging = 0;\n    obj.dragData = null;\n    // set the interaction data to null\n}\n\nfunction onDragMove(event) {\n    const obj = event.currentTarget;\n    if (!obj.dragging) return;\n    const data = obj.dragData; // it can be different pointer!\n    if (obj.dragging === 1) {\n    // click or drag?\n        if (Math.abs(data.global.x - obj.dragGlobalStart.x)\n            + Math.abs(data.global.y - obj.dragGlobalStart.y) >= 3) {\n            // DRAG\n            obj.dragging = 2;\n        }\n    }\n    if (obj.dragging === 2) {\n        const dragPointerEnd = data.getLocalPosition(obj.parent);\n        // DRAG\n        obj.position.set(\n            obj.dragObjStart.x + (dragPointerEnd.x - obj.dragPointerStart.x),\n            obj.dragObjStart.y + (dragPointerEnd.y - obj.dragPointerStart.y),\n        );\n    }\n}\n",
          "exists": true,
          "plugins": [
            "pixi-projection"
          ]
        },
        {
          "title": "2D Quad bilinear",
          "entry": "quad-bi.js",
          "path": "plugin-projection/quad-bi.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nconst w = app.screen.width / 2; const\n    h = app.screen.height / 2;\n\nfunction createSquare(x, y) {\n    const square = new PIXI.Sprite(PIXI.Texture.WHITE);\n    square.tint = 0xff0000;\n    square.factor = 1;\n    square.anchor.set(0.5);\n    square.position.set(x, y);\n    return square;\n}\n\nconst squares = [\n    createSquare(w - 150, h - 150),\n    createSquare(w + 150, h - 150),\n    createSquare(w + 150, h + 150),\n    createSquare(w - 150, h + 150),\n];\n\nconst quad = squares.map((s) => s.position);\n\n// add sprite itself\nconst containerSprite = new PIXI.projection.Sprite2s(PIXI.Texture.from('examples/assets/bg_scene_rotate.jpg'));\ncontainerSprite.anchor.set(0.5);\n\napp.stage.addChild(containerSprite);\nsquares.forEach((s) => { app.stage.addChild(s); });\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    containerSprite.proj.mapBilinearSprite(containerSprite, quad);\n});\n\nsquares.forEach((s) => { addInteraction(s); });\n\n// let us add sprite to make it more funny\n\nconst bunny = new PIXI.projection.Sprite2s(PIXI.Texture.from('examples/assets/flowerTop.png'));\nbunny.anchor.set(0.5);\ncontainerSprite.addChild(bunny);\n\naddInteraction(bunny);\n\n// === INTERACTION CODE  ===\n\nfunction toggle(obj) {\n}\n\nfunction snap(obj) {\n    if (obj === bunny) {\n        obj.position.set(0);\n    } else {\n        obj.position.x = Math.min(Math.max(obj.position.x, 0), app.screen.width);\n        obj.position.y = Math.min(Math.max(obj.position.y, 0), app.screen.height);\n    }\n}\n\nfunction addInteraction(obj) {\n    obj.interactive = true;\n    obj\n        .on('pointerdown', onDragStart)\n        .on('pointerup', onDragEnd)\n        .on('pointerupoutside', onDragEnd)\n        .on('pointermove', onDragMove);\n}\n\nfunction onDragStart(event) {\n    const obj = event.currentTarget;\n    obj.dragData = event.data;\n    obj.dragging = 1;\n    obj.dragPointerStart = event.data.getLocalPosition(obj.parent);\n    obj.dragObjStart = new PIXI.Point();\n    obj.dragObjStart.copyFrom(obj.position);\n    obj.dragGlobalStart = new PIXI.Point();\n    obj.dragGlobalStart.copyFrom(event.data.global);\n}\n\nfunction onDragEnd(event) {\n    const obj = event.currentTarget;\n    if (obj.dragging === 1) {\n        toggle(obj);\n    } else {\n        snap(obj);\n    }\n    obj.dragging = 0;\n    obj.dragData = null;\n    // set the interaction data to null\n}\n\nfunction onDragMove(event) {\n    const obj = event.currentTarget;\n    if (!obj.dragging) return;\n    const data = obj.dragData; // it can be different pointer!\n    if (obj.dragging === 1) {\n    // click or drag?\n        if (Math.abs(data.global.x - obj.dragGlobalStart.x)\n            + Math.abs(data.global.y - obj.dragGlobalStart.y) >= 3) {\n            // DRAG\n            obj.dragging = 2;\n        }\n    }\n    if (obj.dragging === 2) {\n        const dragPointerEnd = data.getLocalPosition(obj.parent);\n\n        if (dragPointerEnd.x >= -2000 && dragPointerEnd.x <= 2000\n            && dragPointerEnd.y >= -2000 && dragPointerEnd.y <= 2000) {\n            // DRAG only if its not too far away, and its not NaN\n            obj.position.set(\n                obj.dragObjStart.x + (dragPointerEnd.x - obj.dragPointerStart.x),\n                obj.dragObjStart.y + (dragPointerEnd.y - obj.dragPointerStart.y),\n            );\n        }\n    }\n}\n",
          "exists": true,
          "plugins": [
            "pixi-projection"
          ]
        },
        {
          "title": "Isometry basics",
          "entry": "iso-basic.js",
          "path": "plugin-projection/iso-basic.js",
          "code": "const app = new PIXI.Application({ backgroundColor: 0x103322 });\ndocument.body.appendChild(app.view);\n\n// === FIRST PART ===\n// just simple rotation\n\nconst sprite = new PIXI.projection.Sprite2d(PIXI.Texture.from('examples/assets/flowerTop.png'));\nsprite.anchor.set(0.5, 1.0);\nsprite.proj.affine = PIXI.projection.AFFINE.AXIS_X; // return to affine after rotating\nsprite.position.set(app.screen.width * 1 / 8, app.screen.height / 2);\napp.stage.addChild(sprite);\n\nlet step = 0;\n\napp.ticker.add((delta) => {\n    step += delta;\n    sprite.rotation = step * 0.1;\n});\n\n// === SECOND PART ===\n// lets also add scaling container\n\nconst scalingContainer = new PIXI.Container();\nscalingContainer.scale.y = 0.3; // adjust scale by Y - that will change \"perspective\" a bit\nscalingContainer.position.set(app.screen.width * 3 / 8, app.screen.height / 2);\napp.stage.addChild(scalingContainer);\n\nconst sprite2 = new PIXI.projection.Sprite2d(PIXI.Texture.from('examples/assets/flowerTop.png'));\nsprite2.anchor.set(0.5, 1.0);\nsprite2.proj.affine = PIXI.projection.AFFINE.AXIS_X;\nscalingContainer.addChild(sprite2);\n\napp.ticker.add(() => {\n    sprite2.rotation = step * 0.1;\n});\n\n// === THIRD PART ===\n// Better isometry plane.\n// We can even rotate it if you want!\n\nconst isoScalingContainer = new PIXI.Container();\nisoScalingContainer.scale.y = 0.5; // isometry can be achieved by setting scaleY 0.5 or tan(30 degrees)\nisoScalingContainer.position.set(app.screen.width * 6 / 8, app.screen.height / 2);\napp.stage.addChild(isoScalingContainer);\n\nconst isometryPlane = new PIXI.Graphics();\nisometryPlane.rotation = Math.PI / 4;\nisoScalingContainer.addChild(isometryPlane);\n\nisometryPlane.lineStyle(2, 0xffffff);\nfor (let i = -100; i <= 100; i += 50) {\n    isometryPlane.moveTo(-150, i);\n    isometryPlane.lineTo(150, i);\n    isometryPlane.moveTo(i, -150);\n    isometryPlane.lineTo(i, 150);\n}\n\nisometryPlane.drawCircle(0, 0, 100);\n\nconst sprite3 = new PIXI.projection.Sprite2d(PIXI.Texture.from('examples/assets/eggHead.png'));\nsprite3.anchor.set(0.5, 1.0);\nsprite3.proj.affine = PIXI.projection.AFFINE.AXIS_X;\nsprite3.scale.set(0.3, 0.5); // make it small but tall!\n// not-proportional scale can't work without special flag `scaleAfterAffine`\n// fortunately, its `true` by default\nisometryPlane.addChild(sprite3);\n\napp.ticker.add(() => {\n    sprite3.rotation = step * 0.05;\n    const radius = 100; const\n        speed = 0.005;\n    sprite3.position.set(Math.cos(step * speed) * radius, Math.sin(step * speed) * radius);\n});\n",
          "exists": true,
          "plugins": [
            "pixi-projection"
          ]
        },
        {
          "title": "3D Camera Spine Layers",
          "entry": "camera-spine-layers.js",
          "path": "plugin-projection/camera-spine-layers.js",
          "code": "// This examples is hard\n// To understand it, you have to carefully read all readme`s and other examples of respective plugins\n// Be ready to study the plugins code. Please use latest version of those libs\n// Used plugins: pixi-spine, pixi-projection (+spine), pixi-display\n\nconst app = new PIXI.Application({ autoStart: false });\ndocument.body.appendChild(app.view);\napp.stage = new PIXI.display.Stage();\n\n// apply mixin to spine class, otherwise objects might not be projected\nPIXI.projection.applySpine3dMixin(PIXI.spine.Spine.prototype);\n\nconst { loader } = app;\n\n// create a new loader\nloader.add('spritesheet', 'examples/assets/pixi-projection/dudes.json');\nloader.add('back', 'examples/assets/pixi-projection/back.png');\nloader.add('pixie', 'examples/assets/pixi-spine/pixie.json');\n// begin load\nloader.load(onAssetsLoaded);\n\n// holder to store aliens\nconst alienFrames = ['eggHead.png', 'flowerTop.png', 'helmlok.png', 'skully.png'];\n\n// create an empty container\nconst camera = new PIXI.projection.Camera3d();\ncamera.position.set(app.screen.width / 2, app.screen.height / 2);\ncamera.setPlanes(1000, 10, 10000, true);\napp.stage.addChild(camera);\n\nconst alienContainer = new PIXI.projection.Container3d();\nconst earthContainer = new PIXI.projection.Container3d();\ncamera.addChild(earthContainer);\ncamera.addChild(alienContainer);\n\nconst sortGroup = new PIXI.display.Group(1, ((plane) => {\n    plane.zOrder = -plane.getDepth();\n}));\napp.stage.addChild(new PIXI.display.Layer(sortGroup));\nconst debugGraphics = new PIXI.Graphics();\napp.stage.addChild(debugGraphics);\n\nfunction spawnAlien(d) {\n    let sprite1;\n    if (d < 4) {\n        const frameName = alienFrames[d];\n        // if you want to use 3d transform for object, either create Sprite3d/Container3d\n        sprite1 = new PIXI.projection.Sprite3d(PIXI.Texture.from(frameName));\n        sprite1.anchor.set(0.5, 1.0);\n        sprite1.scale3d.set(0.5);\n    } else {\n        sprite1 = new PIXI.spine.Spine(loader.resources.pixie.spineData);\n        sprite1.scale3d.set(0.1);\n        sprite1.state.setAnimation(0, 'running', true);\n    }\n\n    // Sprite belongs to plane, and plane is vertical in world coordinates.\n    const spritePlane = new PIXI.projection.Container3d();\n    spritePlane.alwaysFront = true;\n    spritePlane.addChild(sprite1);\n    spritePlane.interactive = true;\n    spritePlane.parentGroup = sortGroup;\n\n    return spritePlane;\n}\n\nconst filter = new PIXI.filters.BlurFilter();\nfilter.blur = 2;\n\nfunction onAssetsLoaded() {\n    const earth = new PIXI.projection.Sprite3d(loader.resources.back.texture);\n    // because earth is Sprite3d, we can access its euler angles\n    earth.euler.x = Math.PI / 2;\n    earth.anchor.x = earth.anchor.y = 0.5;\n    earthContainer.addChild(earth);\n\n    for (let i = 0; i < 30; i++) {\n        const d = Math.random() * 6 | 0;\n\n        const spritePlane = spawnAlien(d);\n        spritePlane.position3d.x = (Math.random() * 2 - 1) * 500.0;\n        spritePlane.position3d.z = (Math.random() * 2 - 1) * 500.0;\n\n        alienContainer.addChild(spritePlane);\n    }\n\n    earthContainer.interactive = true;\n    earthContainer.on('click', (event) => {\n        const p = new PIXI.Point();\n        event.data.getLocalPosition(earth, p, event.data.global);\n\n        const sp = spawnAlien(4);\n        sp.position3d.x = p.x;\n        sp.position3d.z = p.y;\n        alienContainer.addChild(sp);\n    });\n\n    // start animating\n    app.start();\n}\n\nlet ang = 0;\n\napp.ticker.add(() => {\n    debugGraphics.clear();\n    debugGraphics.lineStyle(2, 0xffffff, 1.0);\n    alienContainer.children.forEach((alien) => {\n        const rect = alien.getBounds();\n        if (rect !== PIXI.Rectangle.EMPTY) debugGraphics.drawShape(rect);\n        if (alien.trackedPointers[1] && alien.trackedPointers[1].over) {\n            if (!alien.filters) {\n                alien.filters = [filter];\n            }\n        } else {\n            alien.filters = null;\n        }\n    });\n\n    ang += 0.01;\n    camera.euler.y = ang;\n    camera.euler.x = -Math.PI / 6;\n\n    alienContainer.children.forEach((plane) => {\n        if (plane.alwaysFront) {\n            // 1. rotate sprite plane to the camera\n            plane.children[0].euler.x = -Math.PI / 6;\n            // 2. rotate sprite to the camera\n            plane.euler.y = ang;\n        }\n    });\n    // We are gonna sort and show correct side of card,\n    // so we need updateTransform BEFORE the sorting will be called.\n    // otherwise this part will be tardy by one frame\n    camera.updateTransform();\n});\n",
          "exists": true,
          "plugins": [
            "pixi-spine",
            "@pixi/layers",
            "pixi-projection"
          ]
        },
        {
          "title": "3D Cards",
          "entry": "cards.js",
          "path": "plugin-projection/cards.js",
          "code": "// This examples is hard\n// To understand it, you have to carefully read all readme`s and other examples of respective plugins\n// Be ready to study the plugins code. Please use latest version of those libs\n// Used plugins: pixi-projection, pixi-display\n\nconst app = new PIXI.Application({ autoStart: false, antialias: true });\ndocument.body.appendChild(app.view);\napp.stage = new PIXI.display.Stage();\n\nconst { loader } = app;\n\nconst camera = new PIXI.projection.Camera3d();\ncamera.position.set(app.screen.width / 2, app.screen.height / 2);\ncamera.setPlanes(350, 30, 10000);\ncamera.euler.x = Math.PI / 5.5;\napp.stage.addChild(camera);\n\nconst cards = new PIXI.projection.Container3d();\ncards.position3d.y = -50;\n// MAKE CARDS LARGER:\ncards.scale3d.set(1.5);\ncamera.addChild(cards);\n\nconst shadowGroup = new PIXI.display.Group(1);\nconst cardsGroup = new PIXI.display.Group(2, ((item) => {\n    item.zOrder = -item.getDepth();\n    item.parent.checkFace();\n}));\n\n// Layers are 2d elements but we use them only to show stuff, not to transform items, so its fine :)\ncamera.addChild(new PIXI.display.Layer(shadowGroup));\ncamera.addChild(new PIXI.display.Layer(cardsGroup));\n// we could also add layers in the stage, but then we'll need extra layer for the text\n\n// load assets\nloader.add('cards', 'examples/assets/pixi-projection/cards.json');\nloader.add('table', 'examples/assets/pixi-projection/table.png');\nloader.load(onAssetsLoaded);\n\n// blur for shadow. Do not use it in production, bake shadow into the texture!\nconst blurFilter = new PIXI.filters.BlurFilter();\nblurFilter.blur = 0.2;\n\nclass CardSprite extends PIXI.projection.Container3d {\n    constructor() {\n        super();\n\n        const tex = loader.resources.cards.textures;\n\n        // shadow will be under card\n        this.shadow = new PIXI.projection.Sprite3d(tex['black.png']);\n        this.shadow.anchor.set(0.5);\n        this.shadow.scale3d.set(0.98);\n        this.shadow.alpha = 0.7;\n        // TRY IT WITH FILTER:\n        this.shadow.filters = [blurFilter];\n        // all shadows are UNDER all cards\n        this.shadow.parentGroup = shadowGroup;\n        this.inner = new PIXI.projection.Container3d();\n        // cards are above the shadows\n        // either they have back, either face\n        this.inner.parentGroup = cardsGroup;\n\n        this.addChild(this.shadow);\n        this.addChild(this.inner);\n\n        // construct \"inner\" from back and face\n        this.back = new PIXI.projection.Sprite3d(tex['cover1.png']);\n        this.back.anchor.set(0.5);\n        this.face = new PIXI.projection.Container3d();\n        this.inner.addChild(this.back);\n        this.inner.addChild(this.face);\n        this.code = 0;\n        this.showCode = -1;\n        this.inner.euler.y = Math.PI;\n        this.scale3d.set(0.2);\n\n        // construct \"face\" from four sprites\n        this.createFace();\n    }\n\n    createFace() {\n        const { face } = this;\n        face.removeChildren();\n        const tex = loader.resources.cards.textures;\n        const sprite = new PIXI.projection.Sprite3d(tex['white1.png']);\n        const sprite2 = new PIXI.projection.Sprite3d(PIXI.Texture.EMPTY);\n        const sprite3 = new PIXI.projection.Sprite3d(PIXI.Texture.EMPTY);\n        const sprite4 = new PIXI.projection.Sprite3d(PIXI.Texture.EMPTY);\n        sprite2.y = -120;\n        sprite2.x = -80;\n        sprite3.y = 70;\n        sprite3.x = 40;\n        sprite4.y = -70;\n        sprite4.x = -100;\n\n        sprite.anchor.set(0.5);\n        sprite2.anchor.set(0.5);\n        sprite3.anchor.set(0.5);\n        face.addChild(sprite);\n        face.addChild(sprite2);\n        face.addChild(sprite3);\n        face.addChild(sprite4);\n\n        this.updateFace();\n    }\n\n    updateFace() {\n        const tex = loader.resources.cards.textures;\n        const code = this.showCode === -1 ? 0 : this.showCode;\n        const num = code & 0xf;\n        const suit = code >> 4;\n\n        const { face } = this;\n        face.children[1].texture = num > 0 ? tex[`${suit % 2}_${num}.png`] : PIXI.Texture.EMPTY;\n        if (!face.children[1].texture) {\n            console.log('FAIL 1 ', `${suit % 2}_${num}.png`);\n        }\n        face.children[2].texture = suit !== 0 ? tex[`${suit}_big.png`] : PIXI.Texture.EMPTY;\n        if (!face.children[2].texture) {\n            console.log('FAIL 2', `${suit}_big.png`);\n        }\n        face.children[3].texture = suit !== 0 ? tex[`${suit}_small.png`] : PIXI.Texture.EMPTY;\n        if (!face.children[3].texture) {\n            console.log('FAIL 3', `${suit}_small.png`);\n        }\n    }\n\n    update(dt) {\n        const { inner } = this;\n        if (this.code > 0 && inner.euler.y > 0) {\n            inner.euler.y = Math.max(0, inner.euler.y - dt * 5);\n        }\n        if (this.code === 0 && inner.euler.y < Math.PI) {\n            inner.euler.y = Math.min(Math.PI, inner.euler.y + dt * 5);\n        }\n        inner.position3d.z = -Math.sin(inner.euler.y) * this.back.width;\n\n        // assignment is overriden, so its actually calling euler.copyFrom(this.euler)\n        this.shadow.euler = inner.euler;\n    }\n\n    checkFace() {\n        const { inner } = this;\n        let cc;\n\n        if (!inner.isFrontFace()) {\n        // user sees the back\n            cc = 0;\n        } else {\n        // user sees the face\n            cc = this.showCode || this.code;\n        }\n        if (cc === 0) {\n            this.back.renderable = true;\n            this.face.renderable = false;\n        } else {\n            this.back.renderable = false;\n            this.face.renderable = true;\n        }\n\n        if (cc !== this.showCode) {\n            this.showCode = cc;\n            this.updateFace();\n        }\n    }\n}\n\nfunction dealHand() {\n    cards.removeChildren();\n    for (let i = 0; i < 5; i++) {\n        const card = new CardSprite();\n        card.position3d.x = 56 * (i - 2);\n        if ((Math.random() * 3 | 0) === 0) {\n            onClick({ target: card });\n        }\n        card.update(0);\n        card.interactive = true;\n        card.on('mouseup', onClick);\n        card.on('touchend', onClick);\n        cards.addChild(card);\n    }\n}\n\nfunction onClick(event) {\n    const { target } = event;\n    if (target.code === 0) {\n        const num = (Math.random() * 13 | 0) + 2;\n        const suit = (Math.random() * 4 | 0) + 1;\n        target.code = suit * 16 + num;\n    } else {\n        target.code = 0;\n    }\n}\n\nfunction addText(txt) {\n    const style = {\n        fontSize: 80,\n        fontFamily: 'Arial',\n        fill: '#f5ffe3',\n        dropShadow: true,\n        dropShadowColor: 'rgba(1, 1, 1, 0.4)',\n        dropShadowDistance: 6,\n        wordWrap: false,\n    };\n    const basicText = new PIXI.projection.Text3d(txt, style);\n    basicText.position3d.x = -240;\n    basicText.position3d.y = 20;\n    camera.addChild(basicText);\n}\n\nfunction onAssetsLoaded() {\n    // background must be UNDER camera, it doesnt have z-index or any other bullshit for camera\n    app.stage.addChildAt(new PIXI.Sprite(loader.resources.table.texture), 0);\n    dealHand();\n    addText('Tap on cards');\n    // start animating\n    app.start();\n}\n\napp.ticker.add((deltaTime) => {\n    for (let i = 0; i < cards.children.length; i++) {\n        cards.children[i].update(deltaTime / 60.0);\n    }\n\n    // We are gonna sort and show correct side of card,\n    // so we need updateTransform BEFORE the sorting will be called.\n    // otherwise this part will be tardy by one frame\n    camera.updateTransform();\n});\n",
          "exists": true,
          "plugins": [
            "@pixi/layers",
            "pixi-projection"
          ]
        },
        {
          "title": "3D Runner",
          "entry": "runner.js",
          "path": "plugin-projection/runner.js",
          "code": "// this example uses both pixi-spine and pixi-projection\n// it doesnt use projection-spine bridge because it uses only 2d version of spine object\n\nconst app = new PIXI.Application({ autoStart: false });\ndocument.body.appendChild(app.view);\n\napp.stop();\n\nconst { loader } = app;\n\n// load spine data\nloader\n    .add('pixie', 'examples/assets/pixi-spine/pixie.json')\n    .add('bg', 'examples/assets/pixi-spine/iP4_BGtile.jpg')\n    .add('fg', 'examples/assets/pixi-spine/iP4_ground.png')\n    .load(onAssetsLoaded);\n\nconst objs = []; let\n    pixie;\n\napp.stage.interactive = true;\n\n// 1 earth and 2 parallax layers\n\nconst camera = new PIXI.projection.Camera3d();\ncamera.setPlanes(300, 10, 1000, false);\ncamera.position.set(app.screen.width / 2, 0);\ncamera.position3d.y = -500; // camera is above the ground\napp.stage.addChild(camera);\n\nconst groundLayer = new PIXI.projection.Container3d();\ngroundLayer.euler.x = Math.PI / 2;\ncamera.addChild(groundLayer);\n\n// Those two layers can have 2d objects inside\n// because they return everything to affine space\n\nconst bgLayer = new PIXI.projection.Container3d();\nbgLayer.proj.affine = PIXI.projection.AFFINE.AXIS_X;\ncamera.addChild(bgLayer);\nbgLayer.position3d.z = 80;\n\nconst mainLayer = new PIXI.projection.Container3d();\nmainLayer.proj.affine = PIXI.projection.AFFINE.AXIS_X;\ncamera.addChild(mainLayer);\n\nconst repeats = 3;\n\nfunction onAssetsLoaded(loaderInstance, res) {\n    for (let i = 0; i < repeats; i++) {\n    // simple 2d sprite on back\n        const bg = new PIXI.Sprite(res.bg.texture);\n        bgLayer.addChild(bg);\n        bg.position.x = bg.texture.width * i;\n        bg.anchor.y = 1;\n        objs.push(bg);\n    }\n\n    for (let i = 0; i < repeats; i++) {\n    // 3d sprite on floor\n        const fg = new PIXI.projection.Sprite3d(res.fg.texture);\n        groundLayer.addChild(fg);\n        fg.anchor.set(0, 0.5);\n        // use position or position3d here, its not important,\n        // unless you need Z - then you need position3d\n        fg.position.x = fg.texture.width * i;\n        objs.push(fg);\n    }\n\n    pixie = new PIXI.spine.Spine(res.pixie.spineData);\n    pixie.position.set(300, 0);\n    pixie.scale.set(0.3);\n\n    mainLayer.addChild(pixie);\n\n    pixie.stateData.setMix('running', 'jump', 0.2);\n    pixie.stateData.setMix('jump', 'running', 0.4);\n\n    pixie.state.setAnimation(0, 'running', true);\n\n    app.stage.on('pointerdown', onTouchStart);\n\n    function onTouchStart() {\n        pixie.state.setAnimation(0, 'jump', false);\n        pixie.state.addAnimation(0, 'running', true, 0);\n    }\n\n    app.start();\n}\n\napp.ticker.add((delta) => {\n    pixie.position.x += 10 * delta;\n\n    // camera looks on pixi!\n    camera.position3d.x = pixie.position.x;\n\n    objs.forEach((obj) => {\n        if (obj.position.x + obj.texture.width < pixie.position.x - 500) {\n            obj.position.x += repeats * obj.texture.width;\n        }\n    });\n});\n",
          "exists": true,
          "plugins": [
            "pixi-spine",
            "pixi-projection"
          ]
        },
        {
          "title": "Bunnies Packer",
          "entry": "bunny-pack.js",
          "path": "plugin-projection/bunny-pack.js",
          "code": "const PROJ = PIXI.projection;\n\nclass BagPart extends PROJ.Container3d {\n    constructor(tIn, tOut = undefined) {\n        super();\n\n        this.axis = new PROJ.Container3d();\n        this._cent = new PROJ.Container3d();\n        this._closed = false;\n        this._closing = false;\n        this._duration = 0;\n        this._fader = 0;\n\n        this._in = new PROJ.Sprite3d(tIn);\n\n        this.sideWidth = this._in.width;\n        this.sideHeight = this._in.height;\n\n        this._cent.addChild(this._in);\n\n        if (tOut) {\n            this._out = new PROJ.Sprite3d(tOut);\n            this._out.renderable = false;\n            this._out.tint = 0xff00ff;\n            this._cent.addChild(this._out);\n        }\n\n        this._cent.pivot3d.set(this.sideWidth / 2, this.sideHeight / 2);\n        this._cent.position3d.set(this.sideWidth / 2, this.sideHeight / 2);\n\n        this.axis.addChild(this._cent);\n        this.addChild(this.axis);\n\n        this.rotPoint = new PIXI.ObservablePoint(this._rChange, this, -1, 0);\n        this._rChange();\n\n        this.parentSide = undefined;\n        this.parentLink = undefined;\n\n        this.index = 0;\n    }\n\n    update(dt) {\n        if (this._closing) {\n            this._closeBech(dt);\n        }\n\n        if (this._childSide) {\n            this._childSide.update(dt);\n        }\n    }\n\n    _closeBech(dt) {\n        if (this._fader >= 1) {\n            this._closed = true;\n            this._closing = false;\n            this._fader = 1;\n            this._closingEnd();\n        } else {\n            this._fader += dt / this._duration;\n        }\n\n        const r = -this._fader * Math.PI;\n\n        this.axis.euler.y = r;\n        if (this._out) {\n            this._out.renderable = this._fader > 0.5;\n            this._in.renderable = this._fader < 0.5;\n        } else {\n            this._in.alpha = 1 - this._fader;\n        }\n    }\n\n    _closingEnd() {\n        this.emit('closed', this);\n    }\n\n    _rChange() {\n        const p = this.rotPoint;\n        const p3d = this.axis.pivot3d;\n        const angle = Math.atan2(-p.y, p.x);\n\n        p3d.x = (p.x + 1) * 0.5 * this.sideWidth;\n        p3d.y = (p.y + 1) * 0.5 * this.sideHeight;\n\n        this.axis.euler.z = angle;\n        this.euler.z = -angle;\n    }\n\n    get realLink() {\n        return new PIXI.Point(\n            this.sideWidth * (this.linkPoint.x + 1) * 0.5,\n            this.sideHeight * (this.linkPoint.y + 1) * 0.5,\n        );\n    }\n\n    close(duration = 300) {\n        if (this._closed || this._closing) {\n            return;\n        }\n\n        this._duration = duration;\n        this._closing = true;\n        this._fader = 0;\n    }\n\n    bind(parent, link = [-1, 0]) {\n        this.parentSide = parent;\n        this.parentLink = link;\n        this.index = parent.index + 1;\n\n        const x = 0.5 * (link[0] + 1) * parent.sideWidth;\n        const y = 0.5 * (link[1] + 1) * parent.sideHeight;\n        const piv = parent.axis.pivot3d;\n\n        this.position.x = x + parent.position.x - piv.x;\n        this.position.y = y + parent.position.y - piv.y;\n\n        if (link[0] && this.index % 2 === 1) {\n            this._cent.scale3d.x = -1;\n        }\n\n        if (link[1] && this.index % 2 === 1) {\n            this._cent.scale3d.y = -1;\n        }\n    }\n\n    link() {\n        const p = this.parentSide;\n        const link = this.parentLink;\n\n        if (!p) return;\n\n        p.axis.addChild(this);\n\n        const x = p.sideWidth * (link[0] + 1) * 0.5;\n        const y = p.sideHeight * (link[1] + 1) * 0.5;\n\n        this.position.x = x;\n        this.position.y = y;\n    }\n}\n\nclass Bag extends PROJ.Container3d {\n    constructor() {\n        super();\n        this._sides = [];\n    }\n\n    pack(side, parent = undefined, link = undefined) {\n        const h = this.head;\n\n        this.addChild(side);\n        if (h) {\n            this.addChild(h);\n            side.rotPoint.set(-link[0], -link[1]);\n        }\n        this._sides.push(side);\n\n        if (parent) {\n            side.bind(parent, link);\n        }\n\n        return this;\n    }\n\n    close(duration = 300) {\n        const len = this._sides.length;\n        let index = len - 1;\n\n        const c = (side) => {\n            if (index < 0) return;\n\n            let ch = this._sides[index];\n            if (side) {\n                side.link();\n            }\n\n            // skip second\n            if (index === 1) {\n                index--;\n                ch = this._sides[index];\n            }\n\n            ch.once('closed', c);\n            ch.close(duration / len);\n\n            index--;\n        };\n        c();\n    }\n\n    update(dt) {\n        this._sides.forEach((e) => {\n            e.update(dt);\n        });\n    }\n\n    get tall() {\n        return this._sides[this.children.length - 1];\n    }\n\n    get head() {\n        return this._sides[0];\n    }\n}\n\nconst app = new PIXI.Application({ background: '#2c3e50' });\ndocument.body.appendChild(app.view);\n\n// Load the bunny texture\napp.loader.add('bunny', 'https://pixijs.io/examples/examples/assets/bunny.png')\n    .load(startup);\n\nfunction startup() {\n    const camera = new PIXI.projection.Camera3d();\n    camera.position.set(app.screen.width / 2, app.screen.height / 2);\n    camera.setPlanes(100, 45, 1000);\n    app.stage.addChild(camera);\n\n    const t = app.loader.resources.bunny.texture;\n    const pack = new Bag();\n\n    const a = new BagPart(t, t);\n    const b = new BagPart(t);\n    const c = new BagPart(t);\n    const d = new BagPart(t);\n    const e = new BagPart(t);\n\n    a.rotPoint.set(1, 0);\n\n    pack.pack(a)\n        .pack(b, a, [1, 0])\n        .pack(c, b, [1, 0])\n        .pack(d, c, [0, 1])\n        .pack(e, a, [0, -1]);\n\n    pack.scale.set(3);\n\n    app.stage.interactive = true;\n    app.stage.on('click', () => {\n        pack.close(1000);\n    });\n    camera.addChild(pack);\n\n    // Listen for animate update\n    app.ticker.add((delta) => {\n        // Rotate mr rabbit clockwise\n        pack.update(1000 / 60);\n        camera.updateTransform();\n    });\n}\n",
          "exists": true,
          "plugins": [
            "pixi-projection"
          ]
        }
      ]
    },
    {
      "id": "plugin-layers",
      "title": "Plugin Layers",
      "examples": [
        {
          "title": "Normals",
          "entry": "normals.js",
          "path": "plugin-layers/normals.js",
          "code": "// LAYERS plugin is here: https://github.com/pixijs/pixi-layers/tree/master\n// LIGHTS plugin is here: https://github.com/pixijs/pixi-lights/tree/v4.x\n\nconst app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst stage = app.stage = new PIXI.layers.Stage();\nconst light = new PIXI.lights.PointLight(0xffffff, 1);\n\n// put all layers for deferred rendering of normals\nstage.addChild(new PIXI.layers.Layer(PIXI.lights.diffuseGroup));\nstage.addChild(new PIXI.layers.Layer(PIXI.lights.normalGroup));\nstage.addChild(new PIXI.layers.Layer(PIXI.lights.lightGroup));\n\nconst lightLoader = new PIXI.Loader();\nlightLoader.baseUrl = 'examples/assets/lights/';\nlightLoader\n    .add('bg_diffuse', 'BGTextureTest.jpg')\n    .add('bg_normal', 'BGTextureNORM.jpg')\n    .add('block_diffuse', 'block.png')\n    .add('block_normal', 'blockNormalMap.png')\n    .load(onAssetsLoaded);\n\nfunction createPair(diffuseTex, normalTex) {\n    const container = new PIXI.Container();\n    const diffuseSprite = new PIXI.Sprite(diffuseTex);\n    diffuseSprite.parentGroup = PIXI.lights.diffuseGroup;\n    const normalSprite = new PIXI.Sprite(normalTex);\n    normalSprite.parentGroup = PIXI.lights.normalGroup;\n    container.addChild(diffuseSprite);\n    container.addChild(normalSprite);\n    return container;\n}\n\nfunction onAssetsLoaded(loader, res) {\n    const bg = createPair(res.bg_diffuse.texture, res.bg_normal.texture);\n    const block = createPair(res.block_diffuse.texture, res.block_normal.texture);\n    const block1 = createPair(res.block_diffuse.texture, res.block_normal.texture);\n    const block2 = createPair(res.block_diffuse.texture, res.block_normal.texture);\n\n    block.position.set(100, 100);\n    block1.position.set(500, 100);\n    block2.position.set(300, 400);\n\n    light.position.set(525, 160);\n    stage.addChild(bg);\n    stage.addChild(block);\n    stage.addChild(block1);\n    stage.addChild(block2);\n\n    stage.addChild(new PIXI.lights.AmbientLight(0x4d4d59, 0.4));\n    stage.addChild(new PIXI.lights.DirectionalLight(0x4d4d59, 1, block1));\n    stage.addChild(light);\n\n    bg.interactive = true;\n    bg.on('mousemove', (event) => {\n        light.position.copyFrom(event.data.global);\n    });\n\n    bg.on('pointerdown', (event) => {\n        const clickLight = new PIXI.lights.PointLight(0xffffff);\n        clickLight.position.copyFrom(event.data.global);\n        stage.addChild(clickLight);\n    });\n}\n",
          "exists": true,
          "plugins": [
            "@pixi/layers",
            "pixi-lights"
          ]
        },
        {
          "title": "Lighting",
          "entry": "lighting.js",
          "path": "plugin-layers/lighting.js",
          "code": "const W = 800; const H = 600; const PAD = 80; const\n    resolution = 1;\nconst WIDTH = W / resolution; const\n    HEIGHT = H / resolution;\n\n// the plugin is here: https://github.com/pixijs/pixi-layers/tree/master, its WIP\n\nconst app = new PIXI.Application({ width: WIDTH, height: HEIGHT, resolution });\ndocument.body.appendChild(app.view);\n\n// create the stage instead of container\napp.stage = new PIXI.layers.Stage();\n\nconst background = new PIXI.TilingSprite(\n    PIXI.Texture.from('examples/assets/p2.jpeg'),\n    WIDTH,\n    HEIGHT,\n);\napp.stage.addChild(background);\n// make container for bunnies\nconst bunnyWorld = new PIXI.Container();\napp.stage.addChild(bunnyWorld);\n\nconst lighting = new PIXI.layers.Layer();\nlighting.on('display', (element) => {\n    element.blendMode = PIXI.BLEND_MODES.ADD;\n});\nlighting.useRenderTexture = true;\nlighting.clearColor = [0.5, 0.5, 0.5, 1]; // ambient gray\n\napp.stage.addChild(lighting);\n\nconst lightingSprite = new PIXI.Sprite(lighting.getRenderTexture());\nlightingSprite.blendMode = PIXI.BLEND_MODES.MULTIPLY;\n\napp.stage.addChild(lightingSprite);\n\nconst bunnyTexture = PIXI.Texture.from('examples/assets/bunny.png');\nfunction updateBunny(bunny) {\n    bunny.x += bunny.vx;\n    bunny.y += bunny.vy;\n    if (bunny.x > WIDTH + PAD) {\n        bunny.x -= WIDTH + 2 * PAD;\n    }\n    if (bunny.x < -PAD) {\n        bunny.x += WIDTH + 2 * PAD;\n    }\n    if (bunny.y > HEIGHT + PAD) {\n        bunny.y -= HEIGHT + 2 * PAD;\n    }\n    if (bunny.y < -PAD) {\n        bunny.y += HEIGHT + 2 * PAD;\n    }\n}\n\nfunction createBunny() {\n    const bunny = new PIXI.Sprite(bunnyTexture);\n    bunny.update = updateBunny;\n\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 200.0; // px per second\n    bunny.vx = Math.cos(angle) * speed / 60.0;\n    bunny.vy = Math.sin(angle) * speed / 60.0;\n    bunny.position.set(Math.random() * WIDTH, Math.random() * HEIGHT);\n    bunny.anchor.set(0.5, 0.5);\n\n    const lightbulb = new PIXI.Graphics();\n    const rr = Math.random() * 0x80 | 0;\n    const rg = Math.random() * 0x80 | 0;\n    const rb = Math.random() * 0x80 | 0;\n    const rad = 50 + Math.random() * 20;\n    lightbulb.beginFill((rr << 16) + (rg << 8) + rb, 1.0);\n    lightbulb.drawCircle(0, 0, rad);\n    lightbulb.endFill();\n    lightbulb.parentLayer = lighting;// <-- try comment it\n\n    bunny.addChild(lightbulb);\n\n    return bunny;\n}\n\nfor (let i = 0; i < 40; i++) {\n    bunnyWorld.addChild(createBunny());\n}\n\napp.ticker.add(() => {\n    bunnyWorld.children.forEach(updateBunny);\n});\n",
          "exists": true,
          "plugins": [
            "@pixi/layers"
          ]
        },
        {
          "title": "Z-order",
          "entry": "zorder.js",
          "path": "plugin-layers/zorder.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// META STUFF, groups exist without stage just fine\n\n// z-index = 0, sorting = true;\nconst greenGroup = new PIXI.layers.Group(0, true);\ngreenGroup.on('sort', (sprite) => {\n    // green bunnies go down\n    sprite.zOrder = sprite.y;\n});\n\n// z-index = 1, sorting = true, we can provide zOrder function directly in constructor\nconst blueGroup = new PIXI.layers.Group(1, ((sprite) => {\n    // blue bunnies go up\n    sprite.zOrder = -sprite.y;\n}));\n\n// Drag is the best layer, dragged element is above everything else\nconst dragGroup = new PIXI.layers.Group(2, false);\n\n// Shadows are the lowest\nconst shadowGroup = new PIXI.layers.Group(-1, false);\n\n// specify display list component\napp.stage = new PIXI.layers.Stage();\n// PixiJS v5 sorting - works on zIndex - and layer gets its zIndex from a group!\napp.stage.sortableChildren = true;\napp.stage.interactive = true;\napp.stage.hitArea = app.screen;\n// sorry, group cant exist without layer yet :(;\napp.stage.addChild(new PIXI.layers.Layer(greenGroup));\napp.stage.addChild(new PIXI.layers.Layer(blueGroup));\napp.stage.addChild(new PIXI.layers.Layer(dragGroup));\napp.stage.addChild(new PIXI.layers.Layer(shadowGroup));\n\nconst blurFilter = new PIXI.filters.BlurFilter();\nblurFilter.blur = 0.5;\n\n// create a texture from an image path\nconst textureGreen = PIXI.Texture.from('examples/assets/bunny_green.png');\nconst textureBlue = PIXI.Texture.from('examples/assets/bunny_blue.png');\n\n// make obsolete containers. Why do we need them?\n// Just to show that we can do everything without caring of actual parent container\nconst bunniesOdd = new PIXI.Container();\nconst bunniesEven = new PIXI.Container();\nconst bunniesBlue = new PIXI.Container();\napp.stage.addChild(bunniesOdd);\napp.stage.addChild(bunniesBlue);\napp.stage.addChild(bunniesEven);\n\nfor (let i = 0; i < 15; i++) {\n    const bunny = new PIXI.Sprite(textureGreen);\n    bunny.width = 50;\n    bunny.height = 50;\n    bunny.position.set(100 + 20 * i, 100 + 20 * i);\n    bunny.anchor.set(0.5);\n    // that thing is required\n    bunny.parentGroup = greenGroup;\n    if (i % 2 === 0) {\n        bunniesEven.addChild(bunny);\n    } else {\n        bunniesOdd.addChild(bunny);\n    }\n    subscribe(bunny);\n    addShadow(bunny);\n}\n\nfor (let i = 9; i >= 0; i--) {\n    const bunny = new PIXI.Sprite(textureBlue);\n    bunny.width = 50;\n    bunny.height = 50;\n    bunny.position.set(400 + 20 * i, 400 - 20 * i);\n    bunny.anchor.set(0.5);\n    // that thing is required\n    bunny.parentGroup = blueGroup;\n    bunniesBlue.addChild(bunny);\n    subscribe(bunny);\n    addShadow(bunny);\n}\n\nfunction subscribe(obj) {\n    obj.interactive = true;\n    obj.on('mousedown', onDragStart)\n        .on('touchstart', onDragStart)\n        .on('mouseup', onDragEnd)\n        .on('mouseupoutside', onDragEnd)\n        .on('touchend', onDragEnd)\n        .on('touchendoutside', onDragEnd);\n}\n\napp.stage\n    .on('mousemove', onDragMove)\n    .on('touchmove', onDragMove);\n\nlet dragTarget = null;\nconst dragPoint = new PIXI.Point();\n\nfunction addShadow(obj) {\n    const gr = new PIXI.Graphics();\n    gr.beginFill(0x0, 1);\n    // yes , I know bunny size, I'm sorry for this hack\n    const scale = 1.1;\n    gr.drawRect(-25 / 2 * scale, -36 / 2 * scale, 25 * scale, 36 * scale);\n    gr.endFill();\n    gr.filters = [blurFilter];\n\n    gr.parentGroup = shadowGroup;\n    obj.addChild(gr);\n}\n\nfunction onDragStart(event) {\n    if (!dragTarget) {\n        this.oldGroup = this.parentGroup;\n        this.parentGroup = dragGroup;\n        this.scale.x *= 1.1;\n        this.scale.y *= 1.1;\n        this.toLocal(event.global, null, dragPoint);\n        dragTarget = this;\n    }\n}\n\nfunction onDragEnd() {\n    if (dragTarget) {\n        this.parentGroup = this.oldGroup;\n        this.scale.x /= 1.1;\n        this.scale.y /= 1.1;\n        dragTarget = null;\n    }\n}\n\nfunction onDragMove(event) {\n    if (dragTarget) {\n        dragTarget.x = event.global.x - dragPoint.x;\n        dragTarget.y = event.global.y - dragPoint.y;\n    }\n}\n",
          "exists": true,
          "plugins": [
            "@pixi/layers"
          ]
        },
        {
          "title": "Bring to top",
          "entry": "bringToTop.js",
          "path": "plugin-layers/bringToTop.js",
          "code": "// This is demo of pixi-layers.js, https://github.com/pixijs/pixi-layers\n\nconst app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nconst textureGreen = PIXI.Texture.from('examples/assets/bunny_green.png');\nconst textureBlue = PIXI.Texture.from('examples/assets/bunny_blue.png');\n\nconst blue = new PIXI.Container();\nconst green = new PIXI.Container();\n\napp.stage = new PIXI.layers.Stage();\n\nconst topLayer = new PIXI.layers.Layer();\napp.stage.addChild(blue, green, topLayer);\n\nfor (let i = 0; i < 15; i++) {\n    const bunny = new PIXI.Sprite(textureGreen);\n    bunny.width = 50;\n    bunny.height = 50;\n    bunny.position.set(100 + 20 * i, 100 + 20 * i);\n    bunny.anchor.set(0.5);\n    green.addChild(bunny);\n}\n\nfor (let i = 9; i >= 0; i--) {\n    const bunny = new PIXI.Sprite(textureBlue);\n    bunny.width = 50;\n    bunny.height = 50;\n    bunny.position.set(100 + 20 * i, 150 + 20 * i);\n    bunny.anchor.set(0.5);\n\n    if (i === 9) {\n        bunny.tint = 0xFF0000;\n        bunny.parentLayer = topLayer;\n    }\n\n    blue.addChild(bunny);\n}\n",
          "exists": true,
          "plugins": [
            "@pixi/layers"
          ]
        },
        {
          "title": "Drag, Sort, Light",
          "entry": "normals-drag.js",
          "path": "plugin-layers/normals-drag.js",
          "code": "const W = 800;\nconst H = 600;\nconst resolution = 1;\nconst WIDTH = W / resolution;\nconst HEIGHT = H / resolution;\n\n// LAYERS plugin is here: https://github.com/pixijs/pixi-layers/tree/master\n// LIGHTS plugin is here: https://github.com/pixijs/pixi-lights/tree/master\n\nconst app = new PIXI.Application({ width: WIDTH, height: HEIGHT, resolution });\ndocument.body.appendChild(app.view);\n\nconst stage = app.stage = new PIXI.layers.Stage();\n\n// bg is first, its not lighted\nconst bg = new PIXI.TilingSprite(PIXI.Texture.from('examples/assets/p2.jpeg'), WIDTH, HEIGHT);\nbg.tint = 0x808080;\nstage.addChild(bg);\n\n// put all layers for deferred rendering of normals\nconst diffuseLayer = new PIXI.layers.Layer(PIXI.lights.diffuseGroup);\nstage.addChild(diffuseLayer);\nconst diffuseBlackSprite = new PIXI.Sprite(diffuseLayer.getRenderTexture());\ndiffuseBlackSprite.tint = 0;\n// without the black sprite, lighted elements will be transparent to background. Try remove that line\nstage.addChild(diffuseBlackSprite);\nstage.addChild(new PIXI.layers.Layer(PIXI.lights.normalGroup));\nstage.addChild(new PIXI.layers.Layer(PIXI.lights.lightGroup));\n\n/**\n * IMPROVEMENT - you can use vanilla pixi `stage.sortChildren = true`\n * and `block.zIndex` and remove that sortGroup completely\n * DragGroup will still need its sortPriority\n */\n\nconst sortGroup = new PIXI.layers.Group(0, true);\nsortGroup.on('sort', (sprite) => {\n    // green bunnies go down\n    sprite.zOrder = sprite.y;\n});\n// the group will process all of its members children after the sort\nsortGroup.sortPriority = 1;\nstage.addChild(new PIXI.layers.Layer(sortGroup));\n\nconst dragGroup = new PIXI.layers.Group(0, true);\n// dragged objects has to processed after sorted, so we need a flag here too\ndragGroup.sortPriority = 1;\nstage.addChild(new PIXI.layers.Layer(dragGroup));\n\n// LIGHT and its movement\nstage.addChild(new PIXI.lights.AmbientLight(0x4d4d59, 0.6));\nconst light = new PIXI.lights.PointLight(0xffffff, 1);\nlight.position.set(525, 160);\nstage.addChild(light);\napp.ticker.add(() => {\n    light.position.copyFrom(app.renderer.plugins.interaction.mouse.global);\n});\n\nconst lightLoader = new PIXI.Loader();\nlightLoader.baseUrl = 'examples/assets/lights/';\nlightLoader\n    .add('block_diffuse', 'block.png')\n    .add('block_normal', 'blockNormalMap.png')\n    .load(onAssetsLoaded);\n\nfunction onAssetsLoaded(loader, res) {\n    for (let i = 0; i < 8; i += 2) {\n        stage.addChild(createBlock(100 + i * 50, 100 + i * 30));\n    }\n    for (let i = 1; i < 8; i += 2) {\n        stage.addChild(createBlock(100 + i * 50, 100 + i * 30));\n    }\n}\n\nfunction createBlock(x, y) {\n    const container = new PIXI.Container();\n    // we need to sort them before children go to respective layers\n    container.parentGroup = sortGroup;\n    container.position.set(x, y);\n    const diffuseSprite = new PIXI.Sprite(lightLoader.resources.block_diffuse.texture);\n    diffuseSprite.parentGroup = PIXI.lights.diffuseGroup;\n    diffuseSprite.anchor.set(0.5);\n    const normalSprite = new PIXI.Sprite(lightLoader.resources.block_normal.texture);\n    normalSprite.parentGroup = PIXI.lights.normalGroup;\n    normalSprite.anchor.set(0.5);\n    container.addChild(diffuseSprite);\n    container.addChild(normalSprite);\n\n    subscribe(container);\n\n    return container;\n}\n\n// / === DRAG ZONE ===\nfunction subscribe(obj) {\n    obj.interactive = true;\n    obj.on('mousedown', onDragStart)\n        .on('touchstart', onDragStart)\n        .on('mouseup', onDragEnd)\n        .on('mouseupoutside', onDragEnd)\n        .on('touchend', onDragEnd)\n        .on('touchendoutside', onDragEnd)\n        .on('mousemove', onDragMove)\n        .on('touchmove', onDragMove);\n}\n\nfunction onDragStart(event) {\n    if (!this.dragging) {\n        this.data = event.data;\n        this.oldGroup = this.parentGroup;\n        this.parentGroup = dragGroup;\n        this.dragging = true;\n\n        this.scale.x *= 1.1;\n        this.scale.y *= 1.1;\n        this.dragPoint = event.data.getLocalPosition(this.parent);\n        this.dragPoint.x -= this.x;\n        this.dragPoint.y -= this.y;\n    }\n}\n\nfunction onDragEnd() {\n    if (this.dragging) {\n        this.dragging = false;\n        this.parentGroup = this.oldGroup;\n        this.scale.x /= 1.1;\n        this.scale.y /= 1.1;\n        // set the interaction data to null\n        this.data = null;\n    }\n}\n\nfunction onDragMove() {\n    if (this.dragging) {\n        const newPosition = this.data.getLocalPosition(this.parent);\n        this.x = newPosition.x - this.dragPoint.x;\n        this.y = newPosition.y - this.dragPoint.y;\n    }\n}\n",
          "exists": true,
          "plugins": [
            "@pixi/layers",
            "pixi-lights"
          ]
        },
        {
          "title": "Trail",
          "entry": "trail.js",
          "path": "plugin-layers/trail.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\napp.stage = new PIXI.layers.Stage();\n\nconst layer = new PIXI.layers.Layer();\nlayer.useRenderTexture = true;\n// this flag is required, or you'll get\n// \"glDrawElements: Source and destination textures of the draw are the same.\"\nlayer.useDoubleBuffer = true;\n\nconst trailSprite = new PIXI.Sprite(layer.getRenderTexture());\ntrailSprite.alpha = 0.6;\n\nlayer.addChild(trailSprite);\n\napp.stage.addChild(layer);\nconst showLayer = new PIXI.Sprite(layer.getRenderTexture());\napp.stage.addChild(showLayer);\n\nconst bunnyTex = PIXI.Texture.from('examples/assets/bunny.png');\nconst bunnies = [];\nfor (let i = 0; i < 5; i++) {\n    bunnies[i] = new PIXI.Container();\n    bunnies[i].position.set(app.screen.width / 2, app.screen.height / 2);\n    bunnies[i].rotation = (i / 5) * (Math.PI * 2);\n    bunnies[i].pivot.set(0, -200);\n\n    const sprite = new PIXI.Sprite(bunnyTex);\n    bunnies[i].addChild(sprite);\n    sprite.anchor.set(0.5);\n    sprite.scale.set(2 + Math.random());\n\n    layer.addChild(bunnies[i]);\n}\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // just for fun, let's rotate mr rabbit a little\n    // delta is 1 if running at 100% performance\n    // creates frame-independent transformation\n    for (let i = 0; i < bunnies.length; i++) {\n        bunnies[i].rotation += 0.05 * delta;\n        bunnies[i].children[0].rotation += 0.1 * delta;\n    }\n});\n",
          "exists": true,
          "plugins": [
            "@pixi/layers"
          ]
        }
      ]
    },
    {
      "id": "plugin-picture",
      "title": "Plugin Picture",
      "examples": [
        {
          "title": "Blend Modes",
          "entry": "blend-modes.js",
          "path": "plugin-picture/blend-modes.js",
          "code": "const app = new PIXI.Application({\n    autoStart: false,\n    backgroundAlpha: 0,\n});\nconst { stage, renderer } = app;\n\ndocument.body.appendChild(renderer.view);\n\nconst SUPPORTED_BLEND_MODES = [\n    'NORMAL',\n    'ADD',\n    'SUBTRACT',\n    'MULTIPLY',\n    'XOR',\n    'SRC_IN',\n    'SRC_OUT',\n    'SRC_ATOP',\n    'DST_OVER',\n    'DST_IN',\n    'DST_OUT',\n    'DST_ATOP',\n    'SCREEN',\n    'OVERLAY',\n    'SOFT_LIGHT',\n    'HARD_LIGHT',\n];\n\nconst BLEND_MODES = SUPPORTED_BLEND_MODES.map((modeName) => [modeName, PIXI.BLEND_MODES[modeName]]);\nconst R = 36;\nconst COLOR_DESTINATION = 0xe91e63;\nconst TEXTURE_DESTINATION = PIXI.RenderTexture.create({ width: 2 * R, height: 2 * R, resolution: renderer.resolution });\nconst COLOR_SOURCE = 0x2196f3;\nconst TEXTURE_SOURCE = PIXI.RenderTexture.create({ width: 2 * R, height: 2 * R, resolution: renderer.resolution });\n\nTEXTURE_DESTINATION.baseTexture.framebuffer.multisample = PIXI.MSAA_QUALITY.HIGH;\n\nrenderer.render(\n    new PIXI.Graphics()\n        .beginFill(COLOR_DESTINATION, 1)\n        .drawCircle(R, R, R)\n        .endFill(),\n    {\n        renderTexture: TEXTURE_DESTINATION,\n    },\n);\nif (renderer.framebuffer) {\n    renderer.framebuffer.blit();\n}\n\nrenderer.render(\n    new PIXI.Graphics()\n        .beginFill(COLOR_SOURCE, 0.8)\n        .drawRect(0, 0, 2 * R, 2 * R),\n    {\n        renderTexture: TEXTURE_SOURCE,\n    },\n);\n\nfor (let i = 0, blendModeIndex = 0; i < BLEND_MODES.length; i++) {\n    const [blendModeName, blendMode] = BLEND_MODES[i];\n    const item = new PIXI.Container();\n    const destination = item.addChild(new PIXI.picture.Sprite(TEXTURE_DESTINATION));\n    const source = item.addChild(new PIXI.picture.Sprite(TEXTURE_SOURCE));\n    const label = item.addChild(new PIXI.Text(blendModeName, {\n        fill: 0xffffff,\n        fontSize: 12,\n    }));\n\n    destination.position.set(-R, -R);\n    source.position.set(-2 * R, 0);\n    label.position.set(-2 * R, -1.5 * R);\n\n    // Set blend-mode!\n    source.blendMode = blendMode;\n\n    const index = blendModeIndex++;\n    const xIndex = Math.floor(index / 4);\n    const yIndex = (index % 4);\n\n    item.x = (3 + 6 * xIndex) * R;\n    item.y = (2 + yIndex * 4) * R;\n\n    stage.addChild(item);\n}\n\napp.render();\n",
          "exists": true,
          "plugins": [
            "@pixi/picture"
          ]
        },
        {
          "title": "Dissolve",
          "entry": "dissolve.js",
          "path": "plugin-picture/dissolve.js",
          "code": "// Dissolve blending shader part\nconst DISSOLVE_FULL = `\n    // Noise function that generates a random number between 0 and 1\n    float rand = fract(sin(dot(\n        vTextureCoord.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\n    if (rand < b_src.a) {\n        b_res = b_src;\n    }\n`;\n\n// Create a globally shared instance of the dissolve blending filter\nconst dissolveFilter = new PIXI.picture.BlendFilter({\n    blendCode: DISSOLVE_FULL,\n});\n\n// Setup app - autoStart false since we will render only once\n// to save battery life\nconst app = new PIXI.Application({\n    autoStart: false,\n    backgroundAlpha: 0,\n});\n\ndocument.body.appendChild(app.view);\n\n// Load assets\napp.loader\n    .add('bg_plane', 'examples/assets/bg_plane.jpg')\n    .load(main);\n\n// Setup scene and then render once\nfunction main() {\n    const left = makeBlendSubscene();\n    const right = makeBlendSubscene();\n\n    // Add dissolve filter\n    left.fg.filters = [dissolveFilter];\n\n    // Move right column\n    right.container.x = app.renderer.screen.width / 2;\n\n    // Render scence once\n    app.render();\n}\n\nfunction makeBlendSubscene() {\n    // Black background\n    const bg = new PIXI.Sprite(PIXI.Texture.from('bg_plane'));\n\n    // Translucent white layer on top\n    const fg = new PIXI.Sprite(PIXI.Texture.WHITE);\n\n    bg.width = fg.width = app.renderer.screen.width / 2;\n    bg.height = fg.height = app.renderer.screen.height;\n    fg.alpha = 0.3;\n\n    const container = new PIXI.Container();\n\n    container.addChild(bg, fg);\n    app.stage.addChild(container);\n\n    return { container, bg, fg };\n}\n",
          "exists": true,
          "plugins": [
            "@pixi/picture"
          ]
        },
        {
          "title": "More blend modes",
          "entry": "overlay.js",
          "path": "plugin-picture/overlay.js",
          "code": "// This is demo of pixi-picture.js, https://github.com/pixijs/pixi-picture\n// Plugin automatically assigns a filter for every sprite that has special blendModes\n\nconst app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\n// create a new background sprite\nconst background = PIXI.Sprite.from('examples/assets/bg_rotate.jpg');\nbackground.width = 800;\nbackground.height = 600;\napp.stage.addChild(background);\n\n// create an array to store a reference to the dudes\nconst dudeArray = [];\n\nconst totaldudes = 20;\nconst texture = PIXI.Texture.from('examples/assets/flowerTop.png');\n\nfor (let i = 0; i < totaldudes; i++) {\n    // create a new Sprite that uses the image name that we just generated as its source\n    const dude = new PIXI.picture.Sprite(texture);\n\n    dude.anchor.set(0.5);\n\n    // set a random scale for the dude\n    dude.scale.set(0.8 + Math.random() * 0.3);\n\n    // finally let's set the dude to be at a random position...\n    dude.x = Math.floor(Math.random() * app.screen.width);\n    dude.y = Math.floor(Math.random() * app.screen.height);\n\n    // The important bit of this example, this is how you change the default blend mode of the sprite\n    const num = Math.random() * 3 | 0;\n    if (num === 0) {\n        dude.blendMode = PIXI.BLEND_MODES.HARD_LIGHT;\n    } else if (num === 1) {\n        dude.blendMode = PIXI.BLEND_MODES.SOFT_LIGHT;\n    } else if (num === 2) {\n        dude.blendMode = PIXI.BLEND_MODES.OVERLAY;\n    }\n\n    // create some extra properties that will control movement\n    dude.direction = Math.random() * Math.PI * 2;\n\n    // this number will be used to modify the direction of the dude over time\n    dude.turningSpeed = Math.random() - 0.8;\n\n    // create a random speed for the dude between 0 - 2\n    dude.speed = 2 + Math.random() * 2;\n\n    // finally we push the dude into the dudeArray so it it can be easily accessed later\n    dudeArray.push(dude);\n\n    app.stage.addChild(dude);\n}\n\n// create a bounding box box for the little dudes\nconst dudeBoundsPadding = 100;\n\nconst dudeBounds = new PIXI.Rectangle(\n    -dudeBoundsPadding,\n    -dudeBoundsPadding,\n    app.screen.width + dudeBoundsPadding * 2,\n    app.screen.height + dudeBoundsPadding * 2,\n);\n\napp.ticker.add(() => {\n    // iterate through the dudes and update the positions\n    for (let i = 0; i < dudeArray.length; i++) {\n        const dude = dudeArray[i];\n        dude.direction += dude.turningSpeed * 0.01;\n        dude.x += Math.sin(dude.direction) * dude.speed;\n        dude.y += Math.cos(dude.direction) * dude.speed;\n        dude.rotation = -dude.direction - Math.PI / 2;\n\n        // wrap the dudes by testing their bounds...\n        if (dude.x < dudeBounds.x) {\n            dude.x += dudeBounds.width;\n        } else if (dude.x > dudeBounds.x + dudeBounds.width) {\n            dude.x -= dudeBounds.width;\n        }\n\n        if (dude.y < dudeBounds.y) {\n            dude.y += dudeBounds.height;\n        } else if (dude.y > dudeBounds.y + dudeBounds.height) {\n            dude.y -= dudeBounds.height;\n        }\n    }\n});\n",
          "exists": true,
          "plugins": [
            "pixi-picture"
          ]
        },
        {
          "title": "Backdrop displacement",
          "entry": "displacement.js",
          "path": "plugin-picture/displacement.js",
          "code": "// This is demo of pixi-picture.js, https://github.com/pixijs/pixi-picture\n// This is pixijs DisplacementFilter improvement, using a backdrop\n\nconst shaderVert = `\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n`;\n\nconst shaderFrag = `\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\n\nuniform sampler2D uSampler;\nuniform sampler2D backdropSampler;\nuniform vec2 backdropSampler_flipY;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(uSampler, vTextureCoord);\n\n  map -= 0.5;\n  map.xy *= scale * inputSize.zw;\n\n  vec2 dis = clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw);\n  // required to take backdrop from screen without extra drawcall\n  dis.y = dis.y * backdropSampler_flipY.y + backdropSampler_flipY.x;\n\n  gl_FragColor = texture2D(backdropSampler, dis);\n}\n`;\n\nclass DisplacementFilter extends PIXI.Filter {\n    constructor(scale) {\n        super(\n            shaderVert,\n            shaderFrag,\n        );\n\n        this.uniforms.scale = { x: 1, y: 1 };\n\n        if (scale === null || scale === undefined) {\n            scale = 20;\n        }\n\n        this.scale = new PIXI.Point(scale, scale);\n\n        this.backdropUniformName = 'backdropSampler';\n    }\n\n    apply(filterManager, input, output, clearMode) {\n        this.uniforms.scale.x = this.scale.x;\n        this.uniforms.scale.y = this.scale.y;\n\n        // draw the filter...\n        filterManager.applyFilter(this, input, output, clearMode);\n\n        this.clearColor = [0.5, 0.5, 0.5, 1.0];\n    }\n}\n\nconst app = new PIXI.Application(800, 600);\ndocument.body.appendChild(app.view);\n\napp.stage.interactive = true;\n\nconst container = new PIXI.Container();\napp.stage.addChild(container);\n\nconst padding = 100;\nconst bounds = new PIXI.Rectangle(\n    -padding,\n    -padding,\n    app.screen.width + padding * 2,\n    app.screen.height + padding * 2,\n);\nconst maggots = [];\n\nfor (let i = 0; i < 20; i++) {\n    const maggot = PIXI.Sprite.from('https://pixijs.io/examples/examples/assets/maggot.png');\n    maggot.anchor.set(0.5);\n    container.addChild(maggot);\n\n    maggot.direction = Math.random() * Math.PI * 2;\n    maggot.speed = 1;\n    maggot.turnSpeed = Math.random() - 0.8;\n\n    maggot.x = Math.random() * bounds.width;\n    maggot.y = Math.random() * bounds.height;\n\n    maggot.scale.set(1 + Math.random() * 0.3);\n    maggot.original = new PIXI.Point();\n    maggot.original.copyFrom(maggot.scale);\n    maggots.push(maggot);\n}\nconst displacementContainer = new PIXI.Container();\nconst displacementTexture = PIXI.Texture.from('https://pixijs.io/examples/examples/assets/pixi-filters/displace.png');\nfor (let i = -1; i <= 1; i += 2) {\n    const sprite1 = new PIXI.Sprite(displacementTexture);\n    sprite1.position.set(100 * i, 0);\n    sprite1.anchor.set(0.5);\n    displacementContainer.addChild(sprite1);\n}\napp.stage.addChild(displacementContainer);\n\nconst displacementFilter = new DisplacementFilter();\ndisplacementContainer.filters = [displacementFilter];\ndisplacementFilter.scale.x = 110;\ndisplacementFilter.scale.y = 110;\n// displacementFilter.padding = 0;\n\nconst ringTexture = PIXI.Texture.from('https://pixijs.io/examples/examples/assets/pixi-filters/ring.png');\nconst rings = new PIXI.Container();\nfor (let i = -1; i <= 1; i += 2) {\n    const sprite1 = new PIXI.Sprite(ringTexture);\n    sprite1.position.set(100 * i, 0);\n    sprite1.anchor.set(0.5);\n    rings.addChild(sprite1);\n}\nrings.visible = false;\n\napp.stage.addChild(rings);\n\nconst bg = PIXI.Sprite.from('https://pixijs.io/examples/examples/assets/bg_grass.jpg');\nbg.width = app.screen.width;\nbg.height = app.screen.height;\n\nbg.alpha = 1;\n\napp.stage.addChildAt(bg, 0);\n\napp.stage\n    .on('mousemove', onPointerMove)\n    .on('touchmove', onPointerMove);\n\nfunction onPointerMove(eventData) {\n    rings.visible = true;\n\n    displacementContainer.position.set(eventData.data.global.x, eventData.data.global.y);\n    rings.position.copyFrom(displacementContainer.position);\n}\n\nlet count = 0;\n\napp.ticker.add(() => {\n    count += 0.05;\n\n    for (let i = 0; i < maggots.length; i++) {\n        const maggot = maggots[i];\n\n        maggot.direction += maggot.turnSpeed * 0.01;\n        maggot.x += Math.sin(maggot.direction) * maggot.speed;\n        maggot.y += Math.cos(maggot.direction) * maggot.speed;\n\n        maggot.rotation = -maggot.direction - Math.PI / 2;\n        maggot.scale.x = maggot.original.x + Math.sin(count) * 0.2;\n\n        // wrap the maggots around as the crawl\n        if (maggot.x < bounds.x) {\n            maggot.x += bounds.width;\n        } else if (maggot.x > bounds.x + bounds.width) {\n            maggot.x -= bounds.width;\n        }\n\n        if (maggot.y < bounds.y) {\n            maggot.y += bounds.height;\n        } else if (maggot.y > bounds.y + bounds.height) {\n            maggot.y -= bounds.height;\n        }\n    }\n});\n",
          "exists": true,
          "plugins": [
            "pixi-picture"
          ]
        },
        {
          "title": "Backdrop pixelate",
          "entry": "pixelate.js",
          "path": "plugin-picture/pixelate.js",
          "code": "/**\n Based on discussion: http://www.html5gamedevs.com/topic/42199-how-to-make-pixelatefilter-take-effects-in-a-specific-area-of-a-pixisprite/\n\n How to modify PixelateFilter\n\n 1. put PixelateFilter in the example\n\n 2. add backdropSampler, that'll be our background, and take color from it , not from the uSampler\n\n 3. take only alpha channel of uSampler, without pixelation , multiply result by it\n\n 4. in renderer constructor manually specify two uniforms - backdropSampler, and size. pixi-picture doesn't work if we dont specify it manually :(\n\n 5. put a fullscreen filter on stage. pixi-picture requires that background is rendered inside a framebuffer, i mean Filter or RenderTexture, otherwise \"copySubTexImage2D\" wont work.\n */\n\nconst app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst fragment = `\nvarying vec2 vTextureCoord;\n\nuniform vec2 size;\nuniform sampler2D uSampler, backdropSampler;\nuniform vec2 backdropSampler_flipY;\nuniform highp vec4 inputSize;\nuniform highp vec4 outputFrame;\n\nvec2 mapCoord( vec2 coord )\n{\n    return coord * inputSize.xy + outputFrame.xy;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    return (coord - outputFrame.xy) * inputSize.zw;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor( coord / size ) * size;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n    coord = pixelate(coord, size);\n    coord = unmapCoord(coord);\n    // required to take backdrop from screen without extra drawcall\n    coord.y = coord.y * backdropSampler_flipY.y + backdropSampler_flipY.x;\n\n    vec4 color = texture2D(backdropSampler, coord);\n    vec4 multiplier = texture2D(uSampler, vTextureCoord);\n\n    gl_FragColor = color * multiplier.a;\n}`;\n\nclass PixelateFilter extends PIXI.Filter {\n    constructor(size = 10) {\n        super(undefined, fragment, {\n            backdropSampler: PIXI.Texture.WHITE.baseTexture,\n            uBackdrop_flipY: new Float32Array(2),\n            size: new Float32Array(2),\n        });\n        this.size = size;\n        this.backdropUniformName = 'backdropSampler';\n    }\n\n    get size() {\n        return this.uniforms.size;\n    }\n\n    set size(value) {\n        if (typeof value === 'number') {\n            value = [value, value];\n        }\n        this.uniforms.size = value;\n    }\n}\n\napp.loader.baseUrl = 'https://pixijs.io/examples/examples/assets';\n\napp.loader.add('bg_rotate.jpg').add('flowerTop.png').load(complete);\n\nfunction complete() {\n// create a new background sprite\n    const background = new PIXI.Sprite(app.loader.resources['bg_rotate.jpg'].texture);\n    background.width = 800;\n    background.height = 600;\n    app.stage.addChild(background);\n\n    const dude = new PIXI.Sprite(app.loader.resources['flowerTop.png'].texture);\n    dude.position.set(100);\n    dude.filters = [new PixelateFilter()];\n    app.stage.addChild(dude);\n}\n",
          "exists": true,
          "plugins": [
            "pixi-picture"
          ]
        },
        {
          "title": "Mask blur",
          "entry": "mask-blur.js",
          "path": "plugin-picture/mask-blur.js",
          "code": "// Easy way to apply ANY filter on backdrop with a mask\n\nconst app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\napp.loader.baseUrl = 'https://pixijs.io/examples/examples/assets';\napp.loader.add('bg_rotate.jpg').add('flowerTop.png').load(complete);\n\nconst blur = new PIXI.filters.BlurFilter();\n\nfunction makeEasyWindow() {\n    const container = new PIXI.Container();\n\n    // Mask the background and blur it\n    const graphics = new PIXI.Graphics();\n    graphics.beginFill(0xffffff, 1.0);\n    graphics.drawRoundedRect(-150, -50, 300, 100, 40);\n\n    // saveFlipY is optimization flag, saves one drawcall\n    // if backdrop is taken from main framebuffer\n    // in our case, blur doesn't care about flipping its input\n    // you can set this flag in config or in MaskFilter itself\n    const filter = new PIXI.picture.MaskFilter(blur);\n    filter.safeFlipY = true;\n    graphics.filters = [filter];\n\n    container.addChild(graphics);\n\n    // Blend graphics on top, after everything, with alpha=0.5\n    const graphics2 = new PIXI.Graphics();\n    graphics2.beginFill(0xffffff, 0.5);\n    graphics2.drawRoundedRect(-150, -50, 300, 100, 40);\n\n    container.addChild(graphics2);\n\n    return container;\n}\n\nfunction makeHardWindow() {\n    const container = new PIXI.Container();\n\n    const config = new PIXI.picture.MaskConfig();\n    config.maskBefore = true;\n    // combine with overlay graphics with alpha=0.6, then mask it with same graphics\n    config.uniforms.uChannel[3] = 0.6;\n    config.blendCode = 'vec4 overlay = b_src * uChannel.a;'\n        + 'vec4 mix = b_dest * (1.0-overlay.a) + overlay;'\n        + 'b_res = mix * b_src.a;';\n\n    const graphics = new PIXI.Graphics();\n    graphics.beginFill(0xffffff, 1.0);\n    graphics.drawRoundedRect(-150, -50, 300, 100, 40);\n    graphics.filters = [new PIXI.picture.MaskFilter(blur, config)];\n    container.addChild(graphics);\n    return container;\n}\n\nfunction complete() {\n    // Create a new background sprite\n    const background = new PIXI.Sprite(app.loader.resources['bg_rotate.jpg'].texture);\n    background.width = 800;\n    background.height = 600;\n    app.stage.addChild(background);\n\n    const window1 = makeEasyWindow();\n    const window2 = makeHardWindow();\n    window1.position.set(250, 150);\n    window2.position.set(250, 450);\n    app.stage.addChild(window1, window2);\n\n    app.ticker.add((delta) => {\n        window1.rotation += 0.01 * delta;\n    });\n}\n",
          "exists": true,
          "plugins": [
            "pixi-picture"
          ]
        }
      ]
    },
    {
      "id": "plugin-graphics-smooth",
      "title": "Plugin Graphics Smooth",
      "examples": [
        {
          "title": "Simple",
          "entry": "simple.js",
          "path": "plugin-graphics-smooth/simple.js",
          "code": "const app = new PIXI.Application({ antialias: false });\ndocument.body.appendChild(app.view);\n\nconst graphics = new PIXI.smooth.SmoothGraphics();\n\n// Rectangle\ngraphics.beginFill(0xDE3249);\ngraphics.drawRect(50, 50, 100, 100);\ngraphics.endFill();\n\n// Rectangle + line style 1\ngraphics.lineStyle(2, 0xFEEB77, 1);\ngraphics.beginFill(0x650A5A);\ngraphics.drawRect(200, 50, 100, 100);\ngraphics.endFill();\n\n// Rectangle + line style 2\ngraphics.lineStyle(10, 0xFFBD01, 1);\ngraphics.beginFill(0xC34288);\ngraphics.drawRect(350, 50, 100, 100);\ngraphics.endFill();\n\n// Rectangle 2\ngraphics.lineStyle(2, 0xFFFFFF, 1);\ngraphics.beginFill(0xAA4F08);\ngraphics.drawRect(530, 50, 140, 100);\ngraphics.endFill();\n\n// Circle\ngraphics.lineStyle(0); // draw a circle, set the lineStyle to zero so the circle doesn't have an outline\ngraphics.beginFill(0xDE3249, 1, true); // third param - smoothing for fills\ngraphics.drawCircle(100, 250, 50);\ngraphics.endFill();\n\n// Circle + line style 1\ngraphics.lineStyle(2, 0xFEEB77, 1);\ngraphics.beginFill(0x650A5A, 1);\ngraphics.drawCircle(250, 250, 50);\ngraphics.endFill();\n\n// Circle + line style 2\ngraphics.lineStyle(10, 0xFFBD01, 1);\ngraphics.beginFill(0xC34288, 1);\ngraphics.drawCircle(400, 250, 50);\ngraphics.endFill();\n\n// Ellipse + line style 2\ngraphics.lineStyle(2, 0xFFFFFF, 1);\ngraphics.beginFill(0xAA4F08, 1);\ngraphics.drawEllipse(600, 250, 80, 50);\ngraphics.endFill();\n\n// draw a shape\ngraphics.beginFill(0xFF3300);\ngraphics.lineStyle(4, 0xffd900, 1);\ngraphics.moveTo(50, 350);\ngraphics.lineTo(250, 350);\ngraphics.lineTo(100, 400);\ngraphics.lineTo(50, 350);\ngraphics.closePath();\ngraphics.endFill();\n\n// draw a rounded rectangle\ngraphics.lineStyle(2, 0xFF00FF, 1);\ngraphics.beginFill(0x650A5A, 0.25);\ngraphics.drawRoundedRect(50, 440, 100, 100, 16);\ngraphics.endFill();\n\n// draw star\ngraphics.lineStyle(2, 0xFFFFFF);\ngraphics.beginFill(0x35CC5A, 1);\ngraphics.drawStar(360, 370, 5, 50);\ngraphics.endFill();\n\n// draw star 2\ngraphics.lineStyle(2, 0xFFFFFF);\ngraphics.beginFill(0xFFCC5A, 1);\ngraphics.drawStar(280, 510, 7, 50);\ngraphics.endFill();\n\n// draw star 3\ngraphics.lineStyle(4, 0xFFFFFF);\ngraphics.beginFill(0x55335A, 1);\ngraphics.drawStar(470, 450, 4, 50);\ngraphics.endFill();\n\n// draw polygon\nconst path = [600, 370, 700, 460, 780, 420, 730, 570, 590, 520];\n\ngraphics.lineStyle(0);\ngraphics.beginFill(0x3500FA, 1, true); // third param - smoothing for fills\ngraphics.drawPolygon(path);\ngraphics.endFill();\n\napp.stage.addChild(graphics);\n",
          "exists": true,
          "plugins": [
            "@pixi/graphics-smooth"
          ]
        },
        {
          "title": "Joins and caps",
          "entry": "join-cap.js",
          "path": "plugin-graphics-smooth/join-cap.js",
          "code": "// Top - smoothed graphics\n// Bottom - usual pixi graphics\n\nconst app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst graphics = new PIXI.smooth.SmoothGraphics();\napp.stage.addChild(graphics);\n\nconst graphics2 = new PIXI.Graphics();\ngraphics2.y = 300;\napp.stage.addChild(graphics2);\n\nlet phase = 0;\n\nfunction addLine(gfx, y, len, rad, cap) {\n    gfx.lineStyle({\n        width: 30, color: 0xffffff, alpha: 1, join: PIXI.LINE_JOIN.MITER, cap,\n    });\n    gfx.moveTo(150 - len, y);\n    gfx.lineTo(150, y);\n    gfx.lineTo(150 + Math.cos(phase) * rad, y + Math.sin(phase) * rad);\n\n    gfx.lineStyle({\n        width: 30, color: 0xffffff, alpha: 1, join: PIXI.LINE_JOIN.BEVEL, cap,\n    });\n    gfx.moveTo(350 + Math.cos(phase) * rad, y + Math.sin(phase) * rad);\n    gfx.lineTo(350, y);\n    gfx.lineTo(350 - len, y);\n\n    gfx.lineStyle({\n        width: 30, color: 0xffffff, alpha: 1, join: PIXI.LINE_JOIN.ROUND, cap,\n    });\n    gfx.moveTo(550 - len, y);\n    gfx.lineTo(550, y);\n    gfx.lineTo(550 + Math.cos(phase) * rad, y + Math.sin(phase) * rad);\n}\n\nfunction makeFigures(gfx) {\n    gfx.clear();\n\n    addLine(gfx, 100, 50, 60, PIXI.LINE_CAP.BUTT);\n    addLine(gfx, 200, 50, 60, PIXI.LINE_CAP.ROUND);\n}\n\n// graphics.rotation = Math.PI * 3 / 2 - 0.0001;\napp.ticker.add((delta) => {\n    phase -= 0.008 * delta;\n    makeFigures(graphics);\n    makeFigures(graphics2);\n});\n",
          "exists": true,
          "plugins": [
            "@pixi/graphics-smooth"
          ]
        },
        {
          "title": "Very thin line",
          "entry": "thin-square.js",
          "path": "plugin-graphics-smooth/thin-square.js",
          "code": "const app = new PIXI.Application();\ndocument.body.appendChild(app.view);\n\nconst graphics = new PIXI.smooth.SmoothGraphics();\ngraphics.pivot = { x: 300, y: 300 };\ngraphics.position = { x: 300, y: 300 };\n\n// Rectangle\ngraphics.lineStyle(0.2, 0xffffff, 1);\n\ngraphics.drawRect(150, 150, 300, 300);\ngraphics.endFill();\n\napp.stage.addChild(graphics);\n\napp.ticker.add((delta) => {\n    graphics.rotation -= 0.004 * delta;\n});\n",
          "exists": true,
          "plugins": [
            "@pixi/graphics-smooth"
          ]
        }
      ]
    },
    {
      "id": "tweedle",
      "title": "Tweedle.js",
      "examples": [
        {
          "title": "Basic Examples",
          "entry": "simple.js",
          "path": "tweedle/simple.js",
          "code": "// Tween Documentation: https://miltoncandelero.github.io/tweedle.js/classes/Tween.html\r\n\r\nconst app = new PIXI.Application({ background: '#1099bb' });\r\ndocument.body.appendChild(app.view);\r\n\r\n// Update the shared group\r\napp.ticker.add(() => TWEEDLE.Group.shared.update());\r\n\r\n// Create a new texture\r\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\r\n\r\n// time animation in miliseconds!\r\nconst time = 2000;\r\n\r\nconst bunny1 = new PIXI.Sprite(texture);\r\napp.stage.addChild(bunny1);\r\n\r\nnew TWEEDLE.Tween(bunny1).to({ x: 500 }, time)\r\n    .repeat(Infinity)\r\n    .yoyo(true)\r\n    .start();\r\n\r\nconst bunny2 = new PIXI.Sprite(texture);\r\nbunny2.y = 100;\r\napp.stage.addChild(bunny2);\r\n\r\nnew TWEEDLE.Tween(bunny2).to({ alpha: 0.0 }, time)\r\n    .repeat(Infinity)\r\n    .yoyo(true)\r\n    .start();\r\n\r\nconst bunny3 = new PIXI.Sprite(texture);\r\nbunny3.y = 200;\r\napp.stage.addChild(bunny3);\r\n\r\nnew TWEEDLE.Tween(bunny3).to({ scale: { x: 2.0, y: 2.0 } }, time)\r\n    .repeat(Infinity)\r\n    .yoyo(true)\r\n    .start();\r\n\r\nconst bunny4 = new PIXI.Sprite(texture);\r\nbunny4.y = 350;\r\nbunny4.x = 100;\r\nbunny4.anchor.set(0.5, 0.5);\r\napp.stage.addChild(bunny4);\r\n\r\nnew TWEEDLE.Tween(bunny4).to({ rotation: 2 * Math.PI }, time)\r\n    .repeat(Infinity)\r\n    .yoyo(true)\r\n    .start();\r\n\r\nlet colorBunny = null;\r\ncreateNewBunny();\r\n\r\nfunction createNewBunny() {\r\n    if (colorBunny) {\r\n        app.stage.removeChild(colorBunny);\r\n    }\r\n\r\n    colorBunny = new PIXI.Sprite(texture);\r\n    colorBunny.y = 500;\r\n    colorBunny.x = 50;\r\n    colorBunny.tint = `0x${Math.floor(Math.random() * 16777215).toString(16)}`;\r\n    app.stage.addChild(colorBunny);\r\n\r\n    new TWEEDLE.Tween(colorBunny).to({ x: 500 }, time)\r\n        .onComplete(createNewBunny)\r\n        .start();\r\n}\r\n",
          "exists": true,
          "plugins": [
            "tweedle"
          ]
        },
        {
          "title": "Easings",
          "entry": "easings.js",
          "path": "tweedle/easings.js",
          "code": "// See all available easings at https://miltoncandelero.github.io/tweedle.js/variables/Easing.html\r\n\r\nconst app = new PIXI.Application({ background: '#1099bb' });\r\ndocument.body.appendChild(app.view);\r\n\r\n// Update the shared group\r\napp.ticker.add(() => TWEEDLE.Group.shared.update());\r\n\r\n// Create a new texture\r\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\r\n\r\n// time animation in miliseconds!\r\nconst time = 2000;\r\n\r\nconst bunny1 = new PIXI.Sprite(texture);\r\napp.stage.addChild(bunny1);\r\n\r\nnew TWEEDLE.Tween(bunny1).to({ x: 500 }, time)\r\n    .repeat(Infinity)\r\n    .easing(TWEEDLE.Easing.Elastic.Out)\r\n    .start();\r\n\r\nconst bunny2 = new PIXI.Sprite(texture);\r\nbunny2.y = 100;\r\napp.stage.addChild(bunny2);\r\n\r\nnew TWEEDLE.Tween(bunny2).to({ x: 500 }, time)\r\n    .repeat(Infinity)\r\n    .easing(TWEEDLE.Easing.Quadratic.Out)\r\n    .start();\r\n\r\nconst bunny3 = new PIXI.Sprite(texture);\r\nbunny3.y = 200;\r\napp.stage.addChild(bunny3);\r\n\r\nnew TWEEDLE.Tween(bunny3).to({ x: 500 }, time)\r\n    .repeat(Infinity)\r\n    .easing(TWEEDLE.Easing.Bounce.Out)\r\n    .start();\r\n\r\n\r\nconst bunny4 = new PIXI.Sprite(texture);\r\nbunny4.y = 300;\r\napp.stage.addChild(bunny4);\r\n\r\nnew TWEEDLE.Tween(bunny4).to({ x: 500 }, time)\r\n    .repeat(Infinity)\r\n    .easing(TWEEDLE.Easing.Cubic.In)\r\n    .start();\r\n\r\nconst bunny5 = new PIXI.Sprite(texture);\r\nbunny5.y = 400;\r\napp.stage.addChild(bunny5);\r\n\r\nnew TWEEDLE.Tween(bunny5).to({ x: 500 }, time)\r\n    .repeat(Infinity)\r\n    .easing(TWEEDLE.Easing.Linear.None)\r\n    .start();\r\n\r\nconst bunny6 = new PIXI.Sprite(texture);\r\nbunny6.y = 500;\r\napp.stage.addChild(bunny6);\r\n\r\nnew TWEEDLE.Tween(bunny6).to({ x: 500 }, time)\r\n    .repeat(Infinity)\r\n    .easing(TWEEDLE.Easing.Step.None)\r\n    .start();\n",
          "exists": true,
          "plugins": [
            "tweedle"
          ]
        },
        {
          "title": "Path",
          "entry": "path.js",
          "path": "tweedle/path.js",
          "code": "// Interpolations Documentation: https://miltoncandelero.github.io/tweedle.js/variables/Interpolation.html\r\n\r\nconst app = new PIXI.Application({ background: '#1099bb' });\r\ndocument.body.appendChild(app.view);\r\n\r\n// Update the shared group\r\napp.ticker.add(() => TWEEDLE.Group.shared.update());\r\n\r\n// Create a new texture\r\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\r\n\r\n// time animation in miliseconds!\r\nconst time = 10000;\r\n\r\nconst xTargets = [100, 500, 100, 300, 700, 0];\r\nconst yTargets = [200, 100, 500, 100, 500, 0];\r\n\r\n// Linear bunny\r\nconst bunny1 = new PIXI.Sprite(texture);\r\nbunny1.tint = 0xFF0000;\r\napp.stage.addChild(bunny1);\r\n\r\nnew TWEEDLE.Tween(bunny1).to({ x: xTargets, y: yTargets }, time)\r\n    .repeat(Infinity)\r\n    .start();\r\n\r\n// catmullRom bunny\r\nconst bunny2 = new PIXI.Sprite(texture);\r\nbunny2.tint = 0x00FF00;\r\napp.stage.addChild(bunny2);\r\n\r\nnew TWEEDLE.Tween(bunny2).to({ x: xTargets, y: yTargets }, time)\r\n    .repeat(Infinity)\r\n    .interpolation(TWEEDLE.Interpolation.Geom.CatmullRom)\r\n    .start();\r\n\r\n\r\nconst auxGraphics = new PIXI.Graphics();\r\nauxGraphics.lineStyle(2, 0xFFFFFF, 1);\r\nfor (let i = 0; i < xTargets.length; i++) {\r\n    auxGraphics.lineTo(xTargets[i], yTargets[i]);\r\n    auxGraphics.drawCircle(xTargets[i], yTargets[i], 5);\r\n}\r\napp.stage.addChild(auxGraphics);\r\n",
          "exists": true,
          "plugins": [
            "tweedle"
          ]
        },
        {
          "title": "Smart Interpolation",
          "entry": "smart.js",
          "path": "tweedle/smart.js",
          "code": "// Interpolations Documentation: https://miltoncandelero.github.io/tweedle.js/variables/Interpolation.html\r\n\r\nconst app = new PIXI.Application({ background: '#1099bb' });\r\ndocument.body.appendChild(app.view);\r\n\r\n// Update the shared group\r\napp.ticker.add(() => TWEEDLE.Group.shared.update());\r\n\r\n// Create a new texture\r\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\r\n\r\n// time animation in miliseconds!\r\nconst time = 2000;\r\n\r\n// Angle and Radians supported!\r\n\r\nconst directRotation = new PIXI.Sprite(texture);\r\ndirectRotation.anchor.set(0.5);\r\ndirectRotation.scale.set(3);\r\ndirectRotation.position.set(100, 100);\r\napp.stage.addChild(directRotation);\r\n\r\nconst smartAngle = new PIXI.Sprite(texture);\r\nsmartAngle.anchor.set(0.5);\r\nsmartAngle.scale.set(3);\r\nsmartAngle.position.set(300, 100);\r\napp.stage.addChild(smartAngle);\r\n\r\nconst smartRotation = new PIXI.Sprite(texture);\r\nsmartRotation.anchor.set(0.5);\r\nsmartRotation.scale.set(3);\r\nsmartRotation.position.set(500, 100);\r\napp.stage.addChild(smartRotation);\r\n\r\n// RGB\r\n\r\nconst directTint = new PIXI.Sprite(texture);\r\ndirectTint.anchor.set(0.5);\r\ndirectTint.scale.set(3);\r\ndirectTint.position.set(100, 300);\r\napp.stage.addChild(directTint);\r\n\r\nconst rgbTint = new PIXI.Sprite(texture);\r\nrgbTint.anchor.set(0.5);\r\nrgbTint.scale.set(3);\r\nrgbTint.position.set(300, 300);\r\napp.stage.addChild(rgbTint);\r\n\r\n\r\napp.stage.interactive = true;\r\napp.stage.on('pointerdown', () => {\r\n    const randomRadians = Math.random() * Math.PI * 2 * (Math.random() > 0.5 ? 1 : -1);\r\n    const randomDegrees = randomRadians * 180 / Math.PI;\r\n    const randomColor = Math.random() * 0xFFFFFF;\r\n\r\n    // Pay attention! Interpolation only works with arrays so we make an array of one element!\r\n\r\n    new TWEEDLE.Tween(directRotation).to({ rotation: randomRadians }, time).start();\r\n    new TWEEDLE.Tween(smartRotation).to({ rotation: [randomRadians] }, time).interpolation(TWEEDLE.Interpolation.Angle.Radians).start();\r\n    new TWEEDLE.Tween(smartAngle).to({ angle: [randomDegrees] }, time).interpolation(TWEEDLE.Interpolation.Angle.Degrees).start();\r\n\r\n    new TWEEDLE.Tween(directTint).to({ tint: randomColor }, time).start();\r\n    new TWEEDLE.Tween(rgbTint).to({ tint: [randomColor] }, time).interpolation(TWEEDLE.Interpolation.Color.RGB).start();\r\n});\r\n",
          "exists": true,
          "plugins": [
            "tweedle"
          ]
        }
      ]
    },
    {
      "id": "gsap2-interaction",
      "title": "GSAP2",
      "examples": [
        {
          "title": "GSAP 2 Tick Director",
          "entry": "gsap2-tick.js",
          "path": "gsap2-interaction/gsap2-tick.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\n\ndocument.body.appendChild(app.view);\n\n// We stop Pixi ticker using stop() function because autoStart = false does NOT stop the shared ticker:\n// doc: http://pixijs.download/release/docs/PIXI.Application.html\napp.ticker.stop();\n\n// Now, we use 'tick' from TweenMax (You can use TweenLite too)\nTweenMax.ticker.addEventListener('tick', () => {\n    app.ticker.update();\n});\n\nconst container = new PIXI.Container();\n\napp.stage.addChild(container);\n\n// Create a new texture\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\n\n// Create a 5x5 grid of bunnies\nfor (let i = 0; i < 25; i++) {\n    const bunny = new PIXI.Sprite(texture);\n    bunny.anchor.set(0.5);\n    bunny.x = (i % 5) * 40;\n    bunny.y = Math.floor(i / 5) * 40;\n    container.addChild(bunny);\n}\n\n// Move container to the center\ncontainer.x = app.screen.width / 2;\ncontainer.y = app.screen.height / 2;\n\n// Center bunny sprite in local container coordinates\ncontainer.pivot.x = container.width / 2;\ncontainer.pivot.y = container.height / 2;\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // rotate the container!\n    // use delta to create frame-independent transform\n    container.rotation -= 0.01 * delta;\n});\n",
          "exists": true,
          "plugins": [
            "gsap/gsap2/TweenMax.min"
          ]
        },
        {
          "title": "GSAP 2 Random Draw",
          "entry": "gsap2-random-draw.js",
          "path": "gsap2-interaction/gsap2-random-draw.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\n\ndocument.body.appendChild(app.view);\n\n// We stop Pixi ticker using stop() function because autoStart = false does NOT stop the shared ticker:\n// doc: http://pixijs.download/release/docs/PIXI.Application.html\napp.ticker.stop();\n\n// Global\nlet drawing = false;\nlet graphic = null;\nlet count = 0;\n\nlet xIni;\nlet yIni;\n\n// Now, we use 'tick' from TweenMax (You can use TweenLite too)\nTweenMax.ticker.addEventListener('tick', () => {\n    draw();\n    app.ticker.update();\n});\n\nfunction draw() {\n    count += 5.0;\n    if (!drawing) {\n        drawing = true;\n        graphic = new PIXI.Graphics();\n        graphic.lineStyle(8, `0x${Math.floor(Math.random() * 16777215).toString(16)}`, 1);\n        app.stage.addChild(graphic);\n        xIni = Math.random() * 800;\n        yIni = Math.random() * 600;\n    } else if (count > 50) {\n        count = 0;\n        drawing = false;\n    } else {\n        graphic.moveTo(xIni, yIni);\n        graphic.lineTo(xIni + Math.cos(count) * 20, yIni + Math.sin(count) * 20);\n    }\n}\n",
          "exists": true,
          "plugins": [
            "gsap/gsap2/TweenMax.min"
          ]
        },
        {
          "title": "GSAP 2 Basic Examples",
          "entry": "gsap2-basic.js",
          "path": "gsap2-interaction/gsap2-basic.js",
          "code": "// Note: In this example we have two \"requestAnimationFrame\", PIXI + TweenMax.\n// TweeMax coordinate his animations (bunnies).\n\nconst app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// Create a new texture\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\n\n// time animation in seconds\nconst time = 2.0;\n\nconst bunny1 = new PIXI.Sprite(texture);\napp.stage.addChild(bunny1);\n\nTweenMax.to(bunny1, time, { x: 500, repeat: -1, yoyo: true });\n\nconst bunny2 = new PIXI.Sprite(texture);\nbunny2.y = 100;\napp.stage.addChild(bunny2);\n\nTweenMax.to(bunny2, time, { alpha: 0.0, repeat: -1, yoyo: true });\n\nconst bunny3 = new PIXI.Sprite(texture);\nbunny3.y = 200;\napp.stage.addChild(bunny3);\n\nTweenMax.to(bunny3.scale, time, {\n    x: 2.0, y: 2.0, repeat: -1, yoyo: true,\n});\n\nconst bunny4 = new PIXI.Sprite(texture);\nbunny4.y = 350;\nbunny4.x = 100;\nbunny4.anchor.set(0.5, 0.5);\napp.stage.addChild(bunny4);\n\nTweenMax.to(bunny4, time, { rotation: 2 * Math.PI, repeat: -1, yoyo: true });\n\nlet colorBunny = null;\ncreateNewBunny();\n\nfunction createNewBunny() {\n    if (colorBunny) {\n        app.stage.removeChild(colorBunny);\n    }\n\n    colorBunny = new PIXI.Sprite(texture);\n    colorBunny.y = 500;\n    colorBunny.x = 50;\n    colorBunny.tint = `0x${Math.floor(Math.random() * 16777215).toString(16)}`;\n    app.stage.addChild(colorBunny);\n\n    TweenMax.to(colorBunny, time, { x: 500, onComplete: createNewBunny });\n}\n",
          "exists": true,
          "plugins": [
            "gsap/gsap2/TweenMax.min"
          ]
        },
        {
          "title": "GSAP 2 Filters",
          "entry": "gsap2-filters.js",
          "path": "gsap2-interaction/gsap2-filters.js",
          "code": "// Note: In this example we have two \"requestAnimationFrame\", PIXI + TweenMax.\n// TweeMax coordinate his animations (bunnies).\n\nconst app = new PIXI.Application({ background: '#1099bb' });\n\ndocument.body.appendChild(app.view);\n\nconst bg = PIXI.Sprite.from('examples/assets/pixi-filters/bg_depth_blur.jpg');\nbg.width = app.screen.width;\nbg.height = app.screen.height;\napp.stage.addChild(bg);\n\nconst littleDudes = PIXI.Sprite.from('examples/assets/pixi-filters/depth_blur_dudes.jpg');\nlittleDudes.x = (app.screen.width / 2) - 315;\nlittleDudes.y = 200;\napp.stage.addChild(littleDudes);\n\nconst littleRobot = PIXI.Sprite.from('examples/assets/pixi-filters/depth_blur_moby.jpg');\nlittleRobot.x = (app.screen.width / 2) - 200;\nlittleRobot.y = 100;\napp.stage.addChild(littleRobot);\n\nconst blurFilter1 = new PIXI.filters.BlurFilter();\nblurFilter1.blur = 0.0;\nlittleDudes.filters = [blurFilter1];\n\nconst time = 2.0;\nTweenMax.to(blurFilter1, time, { blur: 5.0, yoyo: true, repeat: -1 });\nTweenMax.to(littleRobot, time, { pixi: { brightness: 2 }, yoyo: true, repeat: -1 });\n",
          "exists": true,
          "plugins": [
            "gsap/gsap2/TweenMax.min",
            "gsap/gsap2/PixiPlugin.min"
          ]
        },
        {
          "title": "GSAP 2 Trail",
          "entry": "gsap2-trail.js",
          "path": "gsap2-interaction/gsap2-trail.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// We stop Pixi ticker using stop() function because autoStart = false does NOT stop the shared ticker:\n// doc: http://pixijs.download/release/docs/PIXI.Application.html\napp.ticker.stop();\n\n// Now, we use 'tick' from TweenMax (You can use TweenLite too)\nTweenMax.ticker.addEventListener('tick', () => {\n    app.ticker.update();\n});\n\n// Get the texture for rope.\nconst trailTexture = PIXI.Texture.from('examples/assets/trail.png');\nlet historyX;\nlet historyY;\n// historySize determines how long the trail will be.\nconst historySize = 50;\n// ropeSize determines how smooth the trail will be.\nconst ropeSize = 100;\nconst points = [];\n\nfunction createHistorySize() {\n    historyX = [];\n    historyY = [];\n    for (let i = 0; i < historySize; i++) {\n        historyX.push(0);\n        historyY.push(0);\n    }\n}\n\n// Create rope points.\nfor (let i = 0; i < ropeSize; i++) {\n    points.push(new PIXI.Point(0, 0));\n}\n\n// Create the rope\nconst rope = new PIXI.SimpleRope(trailTexture, points);\n\n// Set the blendmode\nrope.blendmode = PIXI.BLEND_MODES.ADD;\n\napp.stage.addChild(rope);\n\nconst counter = { x: 0, y: 0 };\nconst time = 5;\n\nplayTrail();\n\nfunction playTrail() {\n    // Create history array.\n    createHistorySize();\n    counter.x = 0;\n    counter.y = 0;\n    TweenMax.to(counter, time, {\n        x: 500, y: 500, onUpdateParams: [counter], onUpdate: updateTrail, onComplete: playTrail,\n    });\n}\n\nfunction updateTrail(param) {\n    // Update the mouse values to history\n    historyX.pop();\n    historyX.unshift(param.x);\n    historyY.pop();\n    historyY.unshift(param.y);\n    // Update the points to correspond with history.\n    for (let i = 0; i < ropeSize; i++) {\n        const p = points[i];\n\n        // Smooth the curve with cubic interpolation to prevent sharp edges.\n        const ix = cubicInterpolation(historyX, i / ropeSize * historySize);\n        const iy = cubicInterpolation(historyY, i / ropeSize * historySize);\n\n        p.x = ix;\n        p.y = iy;\n    }\n}\n\n/**\n * Cubic interpolation based on https://github.com/osuushi/Smooth.js\n */\nfunction clipInput(k, arr) {\n    if (k < 0) k = 0;\n    if (k > arr.length - 1) k = arr.length - 1;\n    return arr[k];\n}\n\nfunction getTangent(k, factor, array) {\n    return factor * (clipInput(k + 1, array) - clipInput(k - 1, array)) / 2;\n}\n\nfunction cubicInterpolation(array, t, tangentFactor) {\n    if (tangentFactor == null) tangentFactor = 1;\n\n    const k = Math.floor(t);\n    const m = [getTangent(k, tangentFactor, array), getTangent(k + 1, tangentFactor, array)];\n    const p = [clipInput(k, array), clipInput(k + 1, array)];\n    t -= k;\n    const t2 = t * t;\n    const t3 = t * t2;\n    return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];\n}\n",
          "exists": true,
          "plugins": [
            "gsap/gsap2/TweenMax.min"
          ]
        },
        {
          "title": "GSAP 2 Tint",
          "entry": "gsap2-tint.js",
          "path": "gsap2-interaction/gsap2-tint.js",
          "code": "// Note: In this example we have two \"requestAnimationFrame\", PIXI + gsap.\n// gsap coordinate his animations (bunnies).\n\n// GSAP documentation: https://greensock.com/docs/v2/Plugins/PixiPlugin\n\nconst app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// Create a new texture\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\n\n// time animation in seconds\nconst time = 2.0;\n\nconst bunny1 = new PIXI.Sprite(texture);\nbunny1.scale.set(3.0, 3.0);\nbunny1.anchor.set(0.5, 0.5);\nbunny1.x = app.screen.width / 4;\nbunny1.y = app.screen.height / 2;\n\napp.stage.addChild(bunny1);\n\nTweenMax.to(bunny1, time, {\n    pixi: { tint: 'red' }, repeat: -1, yoyo: true,\n});\n\nconst bunny2 = new PIXI.Sprite(texture);\nbunny2.scale.set(3.0, 3.0);\nbunny2.anchor.set(0.5, 0.5);\nbunny2.x = 2 * app.screen.width / 4;\nbunny2.y = app.screen.height / 2;\n\napp.stage.addChild(bunny2);\n\nTweenMax.to(bunny2, time, {\n    pixi: { tint: '#00FF00' }, repeat: -1, yoyo: true,\n});\n\nconst bunny3 = new PIXI.Sprite(texture);\nbunny3.scale.set(3.0, 3.0);\nbunny3.anchor.set(0.5, 0.5);\nbunny3.x = 3 * app.screen.width / 4;\nbunny3.y = app.screen.height / 2;\n\napp.stage.addChild(bunny3);\n\nTweenMax.to(bunny3, time, {\n    pixi: { tint: 'rgb(0,0,255)' }, repeat: -1, yoyo: true,\n});\n",
          "exists": true,
          "plugins": [
            "gsap/gsap2/TweenMax.min",
            "gsap/gsap2/PixiPlugin.min"
          ]
        }
      ]
    },
    {
      "id": "gsap3-interaction",
      "title": "GSAP3",
      "examples": [
        {
          "title": "GSAP 3 Tick Director",
          "entry": "gsap3-tick.js",
          "path": "gsap3-interaction/gsap3-tick.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// We stop Pixi ticker using stop() function because autoStart = false does NOT stop the shared ticker:\n// doc: http://pixijs.download/release/docs/PIXI.Application.html\napp.ticker.stop();\n\n// Now, we use 'tick' from gsap\ngsap.ticker.add(() => {\n    app.ticker.update();\n});\n\nconst container = new PIXI.Container();\n\napp.stage.addChild(container);\n\n// Create a new texture\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\n\n// Create a 5x5 grid of bunnies\nfor (let i = 0; i < 25; i++) {\n    const bunny = new PIXI.Sprite(texture);\n    bunny.anchor.set(0.5);\n    bunny.x = (i % 5) * 40;\n    bunny.y = Math.floor(i / 5) * 40;\n    container.addChild(bunny);\n}\n\n// Move container to the center\ncontainer.x = app.screen.width / 2;\ncontainer.y = app.screen.height / 2;\n\n// Center bunny sprite in local container coordinates\ncontainer.pivot.x = container.width / 2;\ncontainer.pivot.y = container.height / 2;\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // rotate the container!\n    // use delta to create frame-independent transform\n    container.rotation -= 0.01 * delta;\n});\n",
          "exists": true,
          "plugins": [
            "gsap/gsap3/gsap.min"
          ]
        },
        {
          "title": "GSAP 3 Random Draw",
          "entry": "gsap3-random-draw.js",
          "path": "gsap3-interaction/gsap3-random-draw.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// We stop Pixi ticker using stop() function because autoStart = false does NOT stop the shared ticker:\n// doc: http://pixijs.download/release/docs/PIXI.Application.html\napp.ticker.stop();\n\n// Global\nlet drawing = false;\nlet graphic = null;\nlet count = 0;\n\nlet xIni;\nlet yIni;\n\n// Now, we use 'tick' from gsap\ngsap.ticker.add(() => {\n    draw();\n    app.ticker.update();\n});\n\nfunction draw() {\n    count += 5.0;\n    if (!drawing) {\n        drawing = true;\n        graphic = new PIXI.Graphics();\n        graphic.lineStyle(8, `0x${Math.floor(Math.random() * 16777215).toString(16)}`, 1);\n        app.stage.addChild(graphic);\n        xIni = Math.random() * 800;\n        yIni = Math.random() * 600;\n    } else if (count > 50) {\n        count = 0;\n        drawing = false;\n    } else {\n        graphic.moveTo(xIni, yIni);\n        graphic.lineTo(xIni + Math.cos(count) * 20, yIni + Math.sin(count) * 20);\n    }\n}\n",
          "exists": true,
          "plugins": [
            "gsap/gsap3/gsap.min"
          ]
        },
        {
          "title": "GSAP 3 Basic Examples",
          "entry": "gsap3-basic.js",
          "path": "gsap3-interaction/gsap3-basic.js",
          "code": "// Note: In this example we have two \"requestAnimationFrame\", PIXI + gsap.\n// gsap coordinate his animations (bunnies).\n\nconst app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// Create a new texture\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\n\n// time animation in seconds\nconst time = 2.0;\n\nconst bunny1 = new PIXI.Sprite(texture);\napp.stage.addChild(bunny1);\n\ngsap.to(bunny1, {\n    x: 500, duration: time, repeat: -1, yoyo: true,\n});\n\nconst bunny2 = new PIXI.Sprite(texture);\nbunny2.y = 100;\napp.stage.addChild(bunny2);\n\ngsap.to(bunny2, {\n    alpha: 0.0, duration: time, repeat: -1, yoyo: true,\n});\n\nconst bunny3 = new PIXI.Sprite(texture);\nbunny3.y = 200;\napp.stage.addChild(bunny3);\n\ngsap.to(bunny3.scale, {\n    x: 2.0, y: 2.0, duration: time, repeat: -1, yoyo: true,\n});\n\nconst bunny4 = new PIXI.Sprite(texture);\nbunny4.y = 350;\nbunny4.x = 100;\nbunny4.anchor.set(0.5, 0.5);\napp.stage.addChild(bunny4);\n\ngsap.to(bunny4, {\n    rotation: 2 * Math.PI, duration: time, repeat: -1, yoyo: true,\n});\n\nlet colorBunny = null;\ncreateNewBunny();\n\nfunction createNewBunny() {\n    if (colorBunny) {\n        app.stage.removeChild(colorBunny);\n    }\n\n    colorBunny = new PIXI.Sprite(texture);\n    colorBunny.y = 500;\n    colorBunny.x = 50;\n    colorBunny.tint = `0x${Math.floor(Math.random() * 16777215).toString(16)}`;\n    app.stage.addChild(colorBunny);\n\n    gsap.to(colorBunny, { x: 500, duration: time, onComplete: createNewBunny });\n}\n",
          "exists": true,
          "plugins": [
            "gsap/gsap3/gsap.min"
          ]
        },
        {
          "title": "GSAP 3 Filters",
          "entry": "gsap3-filters.js",
          "path": "gsap3-interaction/gsap3-filters.js",
          "code": "// Note: In this example we have two \"requestAnimationFrame\", PIXI + gsap.\n// gsap coordinate his animations (bunnies).\nconst app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\nconst bg = PIXI.Sprite.from('examples/assets/pixi-filters/bg_depth_blur.jpg');\nbg.width = app.screen.width;\nbg.height = app.screen.height;\napp.stage.addChild(bg);\n\nconst littleDudes = PIXI.Sprite.from('examples/assets/pixi-filters/depth_blur_dudes.jpg');\nlittleDudes.x = (app.screen.width / 2) - 315;\nlittleDudes.y = 200;\napp.stage.addChild(littleDudes);\n\nconst littleRobot = PIXI.Sprite.from('examples/assets/pixi-filters/depth_blur_moby.jpg');\nlittleRobot.x = (app.screen.width / 2) - 200;\nlittleRobot.y = 100;\napp.stage.addChild(littleRobot);\n\nconst blurFilter1 = new PIXI.filters.BlurFilter();\nblurFilter1.blur = 0.0;\nlittleDudes.filters = [blurFilter1];\n\nconst time = 2.0;\ngsap.to(blurFilter1, {\n    blur: 5.0, duration: time, yoyo: true, repeat: -1,\n});\n\nconst filter = new PIXI.filters.ColorMatrixFilter();\nlittleRobot.filters = [filter];\n\ngsap.to(filter, {\n    brightness: 2, duration: time, yoyo: true, repeat: -1,\n});\n",
          "exists": true,
          "plugins": [
            "gsap/gsap3/gsap.min"
          ]
        },
        {
          "title": "GSAP 3 Trail",
          "entry": "gsap3-trail.js",
          "path": "gsap3-interaction/gsap3-trail.js",
          "code": "const app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// We stop Pixi ticker using stop() function because autoStart = false does NOT stop the shared ticker:\n// doc: http://pixijs.download/release/docs/PIXI.Application.html\napp.ticker.stop();\n\n// Now, we use 'tick' from gsap\ngsap.ticker.add(() => {\n    app.ticker.update();\n});\n\n// Get the texture for rope.\nconst trailTexture = PIXI.Texture.from('examples/assets/trail.png');\nlet historyX;\nlet historyY;\n// historySize determines how long the trail will be.\nconst historySize = 50;\n// ropeSize determines how smooth the trail will be.\nconst ropeSize = 100;\nconst points = [];\n\nfunction createHistorySize() {\n    historyX = [];\n    historyY = [];\n    for (let i = 0; i < historySize; i++) {\n        historyX.push(0);\n        historyY.push(0);\n    }\n}\n\n// Create rope points.\nfor (let i = 0; i < ropeSize; i++) {\n    points.push(new PIXI.Point(0, 0));\n}\n\n// Create the rope\nconst rope = new PIXI.SimpleRope(trailTexture, points);\n\n// Set the blendmode\nrope.blendmode = PIXI.BLEND_MODES.ADD;\n\napp.stage.addChild(rope);\n\nconst counter = { x: 0, y: 0 };\nconst time = 5;\n\nplayTrail();\n\nfunction playTrail() {\n    // Create history array.\n    createHistorySize();\n    counter.x = 0;\n    counter.y = 0;\n    gsap.to(counter, {\n        x: 500, y: 500, duration: time, onUpdateParams: [counter], onUpdate: updateTrail, onComplete: playTrail,\n    });\n}\n\nfunction updateTrail(param) {\n    // Update the mouse values to history\n    historyX.pop();\n    historyX.unshift(param.x);\n    historyY.pop();\n    historyY.unshift(param.y);\n    // Update the points to correspond with history.\n    for (let i = 0; i < ropeSize; i++) {\n        const p = points[i];\n\n        // Smooth the curve with cubic interpolation to prevent sharp edges.\n        const ix = cubicInterpolation(historyX, i / ropeSize * historySize);\n        const iy = cubicInterpolation(historyY, i / ropeSize * historySize);\n\n        p.x = ix;\n        p.y = iy;\n    }\n}\n\n/**\n * Cubic interpolation based on https://github.com/osuushi/Smooth.js\n */\nfunction clipInput(k, arr) {\n    if (k < 0) k = 0;\n    if (k > arr.length - 1) k = arr.length - 1;\n    return arr[k];\n}\n\nfunction getTangent(k, factor, array) {\n    return factor * (clipInput(k + 1, array) - clipInput(k - 1, array)) / 2;\n}\n\nfunction cubicInterpolation(array, t, tangentFactor) {\n    if (tangentFactor == null) tangentFactor = 1;\n\n    const k = Math.floor(t);\n    const m = [getTangent(k, tangentFactor, array), getTangent(k + 1, tangentFactor, array)];\n    const p = [clipInput(k, array), clipInput(k + 1, array)];\n    t -= k;\n    const t2 = t * t;\n    const t3 = t * t2;\n    return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];\n}\n",
          "exists": true,
          "plugins": [
            "gsap/gsap3/gsap.min"
          ]
        },
        {
          "title": "GSAP 3 Tint",
          "entry": "gsap3-tint.js",
          "path": "gsap3-interaction/gsap3-tint.js",
          "code": "// Note: In this example we have two \"requestAnimationFrame\", PIXI + gsap.\n// gsap coordinate his animations (bunnies).\n\n// GSAP documentation: https://greensock.com/docs/v3/Plugins/PixiPlugin\n\nconst app = new PIXI.Application({ background: '#1099bb' });\ndocument.body.appendChild(app.view);\n\n// Create a new texture\nconst texture = PIXI.Texture.from('examples/assets/bunny.png');\n\n// time animation in seconds\nconst time = 2.0;\n\nconst bunny1 = new PIXI.Sprite(texture);\nbunny1.scale.set(3.0, 3.0);\nbunny1.anchor.set(0.5, 0.5);\nbunny1.x = app.screen.width / 4;\nbunny1.y = app.screen.height / 2;\n\napp.stage.addChild(bunny1);\n\ngsap.to(bunny1, {\n    pixi: { tint: 'red' }, duration: time, repeat: -1, yoyo: true,\n});\n\nconst bunny2 = new PIXI.Sprite(texture);\nbunny2.scale.set(3.0, 3.0);\nbunny2.anchor.set(0.5, 0.5);\nbunny2.x = 2 * app.screen.width / 4;\nbunny2.y = app.screen.height / 2;\n\napp.stage.addChild(bunny2);\n\ngsap.to(bunny2, {\n    pixi: { tint: '#00FF00' }, duration: time, repeat: -1, yoyo: true,\n});\n\nconst bunny3 = new PIXI.Sprite(texture);\nbunny3.scale.set(3.0, 3.0);\nbunny3.anchor.set(0.5, 0.5);\nbunny3.x = 3 * app.screen.width / 4;\nbunny3.y = app.screen.height / 2;\n\napp.stage.addChild(bunny3);\n\ngsap.to(bunny3, {\n    pixi: { tint: 'rgb(0,0,255)' }, duration: time, repeat: -1, yoyo: true,\n});\n",
          "exists": true,
          "plugins": [
            "gsap/gsap3/gsap.min",
            "gsap/gsap3/PixiPlugin.min"
          ]
        }
      ]
    },
    {
      "id": "tilemaps",
      "title": "Tilemaps",
      "examples": [
        {
          "title": "Basic",
          "entry": "basic.js",
          "path": "tilemaps/basic.js",
          "code": "const renderer = PIXI.autoDetectRenderer({\n    antialias: true,\n    autoDensity: true,\n});\n\nlet stage;\nlet tilemap;\nlet frame = 0;\n\ndocument.body.appendChild(renderer.view);\n\nPIXI.Assets.add('atlas', 'examples/assets/tilemaps/atlas.json');\nPIXI.Assets.add('button', 'examples/assets/tilemaps/button.png');\nPIXI.Assets.load(['atlas', 'button']).then(() => {\n    // Setup tilemap scene\n    stage = new PIXI.Container();\n    tilemap = new PIXI.tilemap.CompositeTilemap();\n    stage.addChild(tilemap);\n\n    // Setup rendering loop\n    PIXI.Ticker.shared.add(() => renderer.render(stage));\n\n    makeTilemap();\n    setInterval(() => {\n        // Animate the chest tile textures. Since they are placed in 1 row\n        // only, we only need to update tileAnim[0] (for x) and not\n        // tileAnim[1] (for y).\n        renderer.plugins.tilemap.tileAnim[0] = frame++;\n    }, 400);\n});\n\nfunction makeTilemap() {\n    // Clear the tilemap, in case it is being reused.\n    tilemap.clear();\n\n    const size = 32;\n\n    // Calculate the dimensions of the tilemap to build\n    const pxW = renderer.screen.width;\n    const pxH = renderer.screen.height;\n    const tileW = pxW / size;\n    const tileH = pxH / size;\n    const wallBoundary = 2 + Math.floor(tileH / 2);\n\n    // Fill the scene with grass and sparse rocks on top and chests on\n    // the bottom. Some chests are animated between two tile textures\n    // (so they flash red).\n    for (let i = 0; i < tileW; i++) {\n        for (let j = 0; j < tileH; j++) {\n            tilemap.tile(\n                (j < tileH / 2) && (i % 2 === 1) && (j % 2 === 1)\n                    ? 'tough.png'\n                    : 'grass.png',\n                i * size,\n                j * size,\n            );\n\n            if (j === wallBoundary) {\n                tilemap.tile('brick_wall.png', i * size, j * size);\n            } else if (j > wallBoundary + 1 && j < tileH - 1) {\n                if (Math.random() > 0.8) {\n                    tilemap.tile('chest.png', i * size, j * size);\n\n                    if (Math.random() > 0.8) {\n                        // Animate between 2 tile textures. The x-offset\n                        // between them in the base-texture is 34px, i.e.\n                        // \"red_chest\" is exactly 34 pixels right in the atlas.\n                        tilemap.tileAnimX(34, 2);\n                    }\n                }\n            }\n        }\n    }\n\n    // Button does not appear in the atlas, but @pixi/tilemap won't surrender\n    // - it will create second layer for special for buttons and they will\n    // appear above all the other tiles.\n    tilemap.tile(PIXI.Assets.get('button'), 0, 0);\n}\n",
          "exists": true,
          "plugins": [
            "@pixi/tilemap"
          ]
        }
      ]
    }
  ]
}