{
  "type": "class",
  "name": "UniformGroup",
  "sourcePath": "rendering/renderers/shared/shader/UniformGroup.ts",
  "extends": null,
  "implements": [],
  "description": "Extracts the value type from a uniform data object. / export type ExtractUniformObject<T = Record<string, UniformData>> = { [K in keyof T]: FLOPS<T[K]>; }; /** Uniform group options / export type UniformGroupOptions = { /** if true the UniformGroup is handled as an Uniform buffer object. This is the only way WebGPU can work with uniforms. WebGL2 can also use this. So don't set to true if you want to use WebGPU :D / ubo?: boolean; /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */ isStatic?: boolean; }; /** Uniform group holds uniform map and some ID's for work `UniformGroup` has two modes: 1: Normal mode Normal mode will upload the uniforms with individual function calls as required. This is the default mode for WebGL rendering. 2: Uniform buffer mode This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or or a generic object that PixiJS will automatically map to a buffer for you. For maximum benefits, make Ubo UniformGroups static, and only update them each frame. This is the only way uniforms can be used with WebGPU. Rules of UBOs: - UBOs only work with WebGL2, so make sure you have a fallback! - Only floats are supported (including vec[2,3,4], mat[2,3,4]) - Samplers cannot be used in ubo's (a GPU limitation) - You must ensure that the object you pass in exactly matches in the shader ubo structure. Otherwise, weirdness will ensue! - The name of the ubo object added to the group must match exactly the name of the ubo in the shader. When declaring your uniform options, you ust parse in the value and the type of the uniform. The types correspond to the WebGPU types Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor. ```ts // UBO in shader: uniform myCoolData { // Declaring a UBO... mat4 uCoolMatrix; float uFloatyMcFloatFace; }; ``` ```js // A new Uniform Buffer Object... const myCoolData = new UniformGroup({ uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'}, uFloatyMcFloatFace: {value:23, type: 'f32'}, }} // modify the data myCoolData.uniforms.uFloatyMcFloatFace = 42; // Build a shader... const shader = Shader.from(srcVert, srcFrag, { myCoolData // Name matches the UBO name in the shader. Will be processed accordingly. }) ```",
  "category": "rendering",
  "deprecated": false,
  "methods": [
    {
      "name": "for",
      "params": [
        {
          "name": "const i in uniformStructures",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "!UNIFORM_TYPES_MAP[uniformData.type]",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "match",
      "params": [
        {
          "name": "/^array<(\\w+(?:<\\w+>",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "arrayMatch",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "Error",
      "params": [
        {
          "name": "type",
          "type": "'${innerType}'",
          "optional": false,
          "default": null
        },
        {
          "name": "size",
          "type": "${size} instead.`",
          "optional": false,
          "default": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "Error",
      "params": [
        {
          "name": "are",
          "type": "${UNIFORM_TYPES_VALUES.join('",
          "optional": false,
          "default": null
        },
        {
          "name": "'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "getDefaultUniformValue",
      "params": [
        {
          "name": "uniformData.type",
          "type": null
        },
        {
          "name": "uniformData.size",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "createIdFromString",
      "params": [
        {
          "name": "Object.keys(uniforms",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "map",
      "params": [
        {
          "name": "(i",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "join",
      "params": [
        {
          "name": "'-'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "update",
      "params": [],
      "returnType": "void",
      "description": "Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true."
    }
  ],
  "properties": []
}