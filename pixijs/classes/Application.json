{
  "type": "class",
  "name": "Application",
  "sourcePath": "app/Application.ts",
  "extends": null,
  "implements": [],
  "description": "Interface for creating Application plugins. Any plugin that's usable for Application must implement these methods. To create a plugin: 1. Create a class that implements this interface 2. Add the required static extension property 3. Register the plugin using extensions.add() ```ts import { ApplicationPlugin, ExtensionType, extensions } from 'pixi.js'; class MyPlugin { // Required: Declare the extension type public static extension = ExtensionType.Application; // Required: Implement init method public static init(options: Partial<ApplicationOptions>): void { // Add properties/methods to the Application instance (this) Object.defineProperty(this, 'myFeature', { value: () => console.log('My feature!'), }); // Use options if needed console.log('Plugin initialized with:', options); } // Required: Implement destroy method public static destroy(): void { // Clean up any resources console.log('Plugin destroyed'); } } // Register the plugin extensions.add(MyPlugin); // Usage in application const app = new Application(); await app.init(); app.myFeature(); // Output: \"My feature!\" ``` > [!IMPORTANT] > - Plugins are initialized in the order they are added > - Plugins are destroyed in reverse order > - The `this` context in both methods refers to the Application instance / export interface ApplicationPlugin { /** Called when Application is constructed, scoped to Application instance. Passes in `options` as the only argument, which are Application `init()` options. / init(options: Partial<ApplicationOptions>): void; /** Called when destroying Application, scoped to Application instance. */ destroy(): void; } /** Application options supplied to the {@link Application#init} method. These options configure how your PixiJS application behaves. ```js import { Application } from 'pixi.js'; const app = new Application(); // Initialize with common options await app.init({ // Rendering options width: 800,                    // Canvas width height: 600,                   // Canvas height backgroundColor: 0x1099bb,     // Background color antialias: true,              // Enable antialiasing resolution: window.devicePixelRatio, // Screen resolution // Performance options autoStart: true,              // Auto-starts the render loop sharedTicker: true,           // Use shared ticker for better performance // Automatic resize options resizeTo: window,             // Auto-resize to window autoDensity: true,           // Adjust for device pixel ratio // Advanced options preference: 'webgl',         // Renderer preference ('webgl' or 'webgpu') powerPreference: 'high-performance' // GPU power preference }); ``` / export interface ApplicationOptions extends AutoDetectOptions, PixiMixins.ApplicationOptions { } // eslint-disable-next-line max-len // eslint-disable-next-line @typescript-eslint/no-empty-object-type, requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc export interface Application extends PixiMixins.Application { } /** Convenience class to create a new PixiJS application. The Application class is the main entry point for creating a PixiJS application. It handles the setup of all core components needed to start rendering and managing your game or interactive experience. Key features: - Automatically creates and manages the renderer - Provides a stage (root container) for your display objects - Handles canvas creation and management - Supports plugins for extending functionality - {@link ResizePlugin} for automatic resizing - {@link TickerPlugin} for managing frame updates - {@link CullerPlugin} for culling off-screen objects ```js import { Assets, Application, Sprite } from 'pixi.js'; // Create a new application const app = new Application(); // Initialize with options await app.init({ width: 800,           // Canvas width height: 600,          // Canvas height backgroundColor: 0x1099bb, // Background color antialias: true,     // Enable antialiasing resolution: 1,       // Resolution / device pixel ratio preference: 'webgl', // or 'webgpu' // Renderer preference }); // Add the canvas to your webpage document.body.appendChild(app.canvas); // Start adding content to your application const texture - await Assets.load('your-image.png'); const sprite = new Sprite(texture); app.stage.addChild(sprite); ``` > [!IMPORTANT] From PixiJS v8.0.0, the application must be initialized using the async `init()` method > rather than passing options to the constructor.",
  "category": "app",
  "deprecated": false,
  "methods": [
    {
      "name": "if",
      "params": [
        {
          "name": "args[0] !== undefined",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "deprecation",
      "params": [
        {
          "name": "v8_0_0",
          "type": null
        },
        {
          "name": "'Application constructor options are deprecated",
          "type": null
        },
        {
          "name": "please use Application.init(",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "init",
      "params": [
        {
          "name": "options",
          "type": "Partial<ApplicationOptions>",
          "optional": true,
          "default": null
        }
      ],
      "returnType": null,
      "description": "Initializes the PixiJS application with the specified options. This method must be called after creating a new Application instance. ```js const app = new Application(); // Initialize with custom options await app.init({ width: 800, height: 600, backgroundColor: 0x1099bb, preference: 'webgl', // or 'webgpu' }); ```"
    },
    {
      "name": "autoDetectRenderer",
      "params": [
        {
          "name": "options as ApplicationOptions",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "forEach",
      "params": [
        {
          "name": "(plugin",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "call",
      "params": [
        {
          "name": "this",
          "type": null
        },
        {
          "name": "options",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "render",
      "params": [],
      "returnType": "void",
      "description": "Renders the current stage to the screen. When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call this method directly as rendering is handled automatically. Only use this method if you've disabled the {@link TickerPlugin} or need custom render timing control. ```js // Example 1: Default setup (TickerPlugin handles rendering) const app = new Application(); await app.init(); // No need to call render() - TickerPlugin handles it // Example 2: Custom rendering loop (if TickerPlugin is disabled) const app = new Application(); await app.init({ autoStart: false }); // Disable automatic rendering function animate() { app.render(); requestAnimationFrame(animate); } animate(); ```"
    },
    {
      "name": "render",
      "params": [
        {
          "name": "container",
          "type": "this.stage }",
          "optional": false,
          "default": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "destroy",
      "params": [
        {
          "name": "rendererDestroyOptions",
          "type": "RendererDestroyOptions",
          "optional": true,
          "default": "false"
        },
        {
          "name": "options",
          "type": "DestroyOptions",
          "optional": true,
          "default": "false"
        }
      ],
      "returnType": "void",
      "description": "Reference to the renderer's canvas element. This is the HTML element that displays your application's graphics. ```js // Create a new application const app = new Application(); // Initialize the application await app.init({...}); // Add canvas to the page document.body.appendChild(app.canvas); // Access the canvas directly console.log(app.canvas); // HTMLCanvasElement ``` / get canvas(): R['canvas'] { return this.renderer.canvas as R['canvas']; } /** Reference to the renderer's canvas element. / get view(): R['canvas'] { // #if _DEBUG deprecation(v8_0_0, 'Application.view is deprecated, please use Application.canvas instead.'); // #endif return this.renderer.canvas as R['canvas']; } /** Reference to the renderer's screen rectangle. This represents the visible area of your application. It's commonly used for: - Setting filter areas for full-screen effects - Defining hit areas for screen-wide interaction - Determining the visible bounds of your application ```js // Use as filter area for a full-screen effect const blurFilter = new BlurFilter(); sprite.filterArea = app.screen; // Use as hit area for screen-wide interaction const screenSprite = new Sprite(); screenSprite.hitArea = app.screen; // Get screen dimensions console.log(app.screen.width, app.screen.height); ``` / get screen(): Rectangle { return this.renderer.screen; } /** Destroys the application and all of its resources. This method should be called when you want to completely clean up the application and free all associated memory. - `false` or `undefined`: Preserves the canvas element (default) - `true`: Removes the canvas element - `{ removeView: boolean }`: Object with removeView property to control canvas removal - `false` or `undefined`: Basic cleanup (default) - `true`: Complete cleanup including children - Detailed options object: - `children`: Remove children - `texture`: Destroy textures - `textureSource`: Destroy texture sources - `context`: Destroy WebGL context ```js // Basic cleanup app.destroy(); // Remove canvas and do complete cleanup app.destroy(true, true); // Remove canvas with explicit options app.destroy({ removeView: true }, true); // Detailed cleanup with specific options app.destroy( { removeView: true }, { children: true, texture: true, textureSource: true, context: true } ); ``` > [!WARNING] After calling destroy, the application instance should no longer be used. > All properties will be null and further operations will throw errors."
    },
    {
      "name": "slice",
      "params": [
        {
          "name": "0",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "reverse",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "forEach",
      "params": [
        {
          "name": "(plugin",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "call",
      "params": [
        {
          "name": "this",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "destroy",
      "params": [
        {
          "name": "options",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "destroy",
      "params": [
        {
          "name": "rendererDestroyOptions",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "handleByList",
      "params": [
        {
          "name": "ExtensionType.Application",
          "type": null
        },
        {
          "name": "Application._plugins",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "add",
      "params": [
        {
          "name": "ApplicationInitHook",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    }
  ],
  "properties": [
    {
      "name": "canvas",
      "type": "R['canvas']",
      "description": "Reference to the renderer's canvas element. This is the HTML element that displays your application's graphics. ```js // Create a new application const app = new Application(); // Initialize the application await app.init({...}); // Add canvas to the page document.body.appendChild(app.canvas); // Access the canvas directly console.log(app.canvas); // HTMLCanvasElement ```"
    },
    {
      "name": "view",
      "type": "R['canvas']",
      "description": "Reference to the renderer's canvas element."
    },
    {
      "name": "screen",
      "type": "Rectangle",
      "description": "Reference to the renderer's screen rectangle. This represents the visible area of your application. It's commonly used for: - Setting filter areas for full-screen effects - Defining hit areas for screen-wide interaction - Determining the visible bounds of your application ```js // Use as filter area for a full-screen effect const blurFilter = new BlurFilter(); sprite.filterArea = app.screen; // Use as hit area for screen-wide interaction const screenSprite = new Sprite(); screenSprite.hitArea = app.screen; // Get screen dimensions console.log(app.screen.width, app.screen.height); ```"
    }
  ]
}