{
  "type": "class",
  "name": "AnimatedSprite",
  "sourcePath": "scene/sprite-animated/AnimatedSprite.ts",
  "extends": "Sprite",
  "implements": [],
  "description": "A collection of textures or frame objects that can be used to create an `AnimatedSprite`. / export type AnimatedSpriteFrames = Texture[] | FrameObject[]; /** Constructor options used for `AnimatedSprite` instances. Allows configuration of animation playback, speed, and texture frames. ```ts // Create a basic animated sprite const sprite = new AnimatedSprite({ textures: [ Texture.from('walk1.png'), Texture.from('walk2.png'), Texture.from('walk3.png') ], animationSpeed: 0.1, loop: true }); // Create with spritesheet frames and callbacks const sheet = await Assets.load('character.json'); const animatedSprite = new AnimatedSprite({ textures: sheet.animations['walk'], autoPlay: true, updateAnchor: true, onComplete: () => console.log('Animation complete'), onFrameChange: (frame) => console.log('Current frame:', frame), onLoop: () => console.log('Animation looped') }); // Create with custom timing for each frame const customTimingSprite = new AnimatedSprite({ textures: [ { texture: Texture.from('frame1.png'), time: 100 }, { texture: Texture.from('frame2.png'), time: 200 }, { texture: Texture.from('frame3.png'), time: 300 } ], autoUpdate: true }); ``` / export interface AnimatedSpriteOptions extends PixiMixins.AnimatedSpriteOptions, Omit<SpriteOptions, 'texture'> { /** The speed that the AnimatedSprite will play at. Higher is faster, lower is slower. ```ts // Create an AnimatedSprite with a slower animation speed const animation = new AnimatedSprite({ textures: [Texture.from('frame1.png'), Texture.from('frame2.png')], animationSpeed: 0.5 // Slower animation }); // Update the animation speed to make it faster animation.animationSpeed = 2; // Faster animation ``` / animationSpeed?: number; /** Whether to start the animation immediately on creation. If set to `true`, the animation will start playing as soon as the `AnimatedSprite` is created. If set to `false`, you will need to call the `play` method to start the animation. ```ts // Create an AnimatedSprite that starts playing immediately const animation = new AnimatedSprite({ textures: [Texture.from('frame1.png'), Texture.from('frame2.png')], autoPlay: true }); // Create an AnimatedSprite that does not start playing immediately const animation = new AnimatedSprite({ textures: [Texture.from('frame1.png'), Texture.from('frame2.png')], autoPlay: false }); animation.play(); // Start the animation manually ``` / autoPlay?: boolean; /** Whether to use Ticker.shared to auto update animation time. This is useful for animations that need to be updated every frame. If set to `false`, you will need to manually call the `update` method to update the animation. ```ts // Create an AnimatedSprite that does not auto update const animation = new AnimatedSprite({ textures: [Texture.from('frame1.png'), Texture.from('frame2.png')], autoUpdate: false }); // Manually update the animation in your game loop ticker.add((ticker) => { animation.update(ticker); } ``` / autoUpdate?: boolean; /** Whether or not the animation repeats after playing. / loop?: boolean; /** User-assigned function to call when an AnimatedSprite finishes playing. ```ts animation.onComplete = () => { // Finished! console.log('Animation complete'); }; ``` / onComplete?: () => void; /** User-assigned function to call when an AnimatedSprite changes which texture is being rendered. ```ts animation.onFrameChange = (currentFrame) => { // Updated! console.log('Current frame:', currentFrame); }; ``` / onFrameChange?: (currentFrame: number) => void; /** User-assigned function to call when `loop` is true, and an AnimatedSprite is played and loops around to start again. ```ts animation.onLoop = () => { // Looped! }; ``` / onLoop?: () => void; /** An array of {@link Texture} or frame objects that make up the animation. ```ts // Create an AnimatedSprite with an array of textures const animation = new AnimatedSprite({ textures: [ Texture.from('frame1.png'), Texture.from('frame2.png'), Texture.from('frame3.png') ] }); * // Create an AnimatedSprite with an array of frame objects const animation = new AnimatedSprite({ textures: [ { texture: Texture.from('frame1.png'), time: 100 }, { texture: Texture.from('frame2.png'), time: 200 }, { texture: Texture.from('frame3.png'), time: 300 } ] }); ``` / textures: AnimatedSpriteFrames; /** Update anchor to [Texture's defaultAnchor]{@link Texture#defaultAnchor} when frame changes. Useful with [sprite sheet animations]{@link Spritesheet#animations} created with tools. Changing anchor for each frame allows to pin sprite origin to certain moving feature of the frame (e.g. left foot). > [!NOTE] Enabling this will override any previously set `anchor` on each frame change. ```ts // Create an AnimatedSprite with updateAnchor enabled const animation = new AnimatedSprite({ textures: [Texture.from('frame1.png'), Texture.from('frame2.png')], updateAnchor: true }); ``` / updateAnchor?: boolean; } // eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc export interface AnimatedSprite extends PixiMixins.AnimatedSprite, Sprite {} /** An AnimatedSprite is a simple way to display an animation depicted by a list of textures. ```js import { AnimatedSprite, Texture } from 'pixi.js'; const alienImages = [ 'image_sequence_01.png', 'image_sequence_02.png', 'image_sequence_03.png', 'image_sequence_04.png', ]; const textureArray = []; for (let i = 0; i < 4; i++) { const texture = Texture.from(alienImages[i]); textureArray.push(texture); } const animatedSprite = new AnimatedSprite(textureArray); ``` The more efficient and simpler way to create an animated sprite is using a {@link Spritesheet} containing the animation definitions: ```js import { AnimatedSprite, Assets } from 'pixi.js'; const sheet = await Assets.load('assets/spritesheet.json'); animatedSprite = new AnimatedSprite(sheet.animations['image_sequence']); ```",
  "category": "scene",
  "deprecated": false,
  "methods": [
    {
      "name": "if",
      "params": [
        {
          "name": "Array.isArray(args[0]",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "super",
      "params": [
        {
          "name": "{\n            ...rest",
          "type": null
        },
        {
          "name": "texture",
          "type": "firstFrame instanceof Texture ? firstFrame : firstFrame.texture",
          "optional": false,
          "default": null
        },
        {
          "name": "}",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "autoPlay",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "play",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "stop",
      "params": [],
      "returnType": "void",
      "description": "Stops the animation playback and freezes the current frame. Does not reset the current frame or animation progress. ```ts // Create an animated sprite const sprite = new AnimatedSprite({ textures: [ Texture.from('walk1.png'), Texture.from('walk2.png'), Texture.from('walk3.png') ], autoPlay: true }); // Stop at current frame sprite.stop(); // Stop at specific frame sprite.gotoAndStop(1); // Stops at second frame // Stop and reset sprite.stop(); sprite.currentFrame = 0; // Stop with completion check if (sprite.playing) { sprite.stop(); sprite.onComplete?.(); } ```"
    },
    {
      "name": "if",
      "params": [
        {
          "name": "!this._playing",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "this._autoUpdate && this._isConnectedToTicker",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "remove",
      "params": [
        {
          "name": "this.update",
          "type": null
        },
        {
          "name": "this",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "play",
      "params": [],
      "returnType": "void",
      "description": "Starts or resumes the animation playback. If the animation was previously stopped, it will continue from where it left off. ```ts // Basic playback const sprite = new AnimatedSprite({ textures: [ Texture.from('walk1.png'), Texture.from('walk2.png'), ], autoPlay: false }); sprite.play(); // Play after stopping sprite.stop(); sprite.currentFrame = 0; // Reset to start sprite.play(); // Play from beginning // Play with auto-update disabled sprite.autoUpdate = false; sprite.play(); app.ticker.add(() => { sprite.update(app.ticker); // Manual updates }); ```"
    },
    {
      "name": "if",
      "params": [
        {
          "name": "this._playing",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "this._autoUpdate && !this._isConnectedToTicker",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "add",
      "params": [
        {
          "name": "this.update",
          "type": null
        },
        {
          "name": "this",
          "type": null
        },
        {
          "name": "UPDATE_PRIORITY.HIGH",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "gotoAndStop",
      "params": [
        {
          "name": "frameNumber",
          "type": "number",
          "optional": false,
          "default": null
        }
      ],
      "returnType": "void",
      "description": "Stops the AnimatedSprite and sets it to a specific frame. ```ts // Create an animated sprite const sprite = new AnimatedSprite({ textures: [ Texture.from('walk1.png'), Texture.from('walk2.png'), Texture.from('walk3.png'), ] }); // Go to specific frames sprite.gotoAndStop(0);  // First frame sprite.gotoAndStop(2);  // Third frame // Jump to last frame sprite.gotoAndStop(sprite.totalFrames - 1); ```"
    },
    {
      "name": "stop",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "gotoAndPlay",
      "params": [
        {
          "name": "frameNumber",
          "type": "number",
          "optional": false,
          "default": null
        }
      ],
      "returnType": "void",
      "description": "Goes to a specific frame and begins playing the AnimatedSprite from that point. Combines frame navigation and playback start in one operation. ```ts // Start from specific frame sprite.gotoAndPlay(1); // Starts playing from second frame ```"
    },
    {
      "name": "play",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "update",
      "params": [
        {
          "name": "ticker",
          "type": "Ticker",
          "optional": false,
          "default": null
        }
      ],
      "returnType": "void",
      "description": "Updates the object transform for rendering. This method handles animation timing, frame updates, and manages looping behavior. ```ts // Create an animated sprite with manual updates const sprite = new AnimatedSprite({ textures: [ Texture.from('frame1.png'), Texture.from('frame2.png'), Texture.from('frame3.png') ], autoUpdate: false // Disable automatic updates }); // Manual update with app ticker app.ticker.add((ticker) => { sprite.update(ticker); }); ```"
    },
    {
      "name": "if",
      "params": [
        {
          "name": "!this._playing",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "this._durations !== null",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "while",
      "params": [
        {
          "name": "lag < 0",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "sign",
      "params": [
        {
          "name": "this.animationSpeed * deltaTime",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "floor",
      "params": [
        {
          "name": "this._currentTime",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "while",
      "params": [
        {
          "name": "lag >= this._durations[this.currentFrame]",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "this._currentTime < 0 && !this.loop",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "gotoAndStop",
      "params": [
        {
          "name": "0",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "this.onComplete",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "onComplete",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "this._currentTime >= this._textures.length && !this.loop",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "gotoAndStop",
      "params": [
        {
          "name": "this._textures.length - 1",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "this.onComplete",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "onComplete",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "previousFrame !== this.currentFrame",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "this.loop && this.onLoop",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "(this.animationSpeed > 0 && this.currentFrame < previousFrame",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "onLoop",
      "params": [],
      "returnType": null,
      "description": null
    }
  ],
  "properties": []
}