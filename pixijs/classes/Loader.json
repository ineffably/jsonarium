{
  "type": "class",
  "name": "Loader",
  "sourcePath": "assets/loader/Loader.ts",
  "extends": null,
  "implements": [],
  "description": "Options for loading assets with the Loader ```ts await Assets.load(['file1.png', 'file2.png'], { onProgress: (progress) => console.log(`Progress: ${progress * 100}%`), onError: (error, url) => console.error(`Error loading ${url}: ${error.message}`), strategy: 'retry', // 'throw' | 'skip' | 'retry' retryCount: 5, // Number of retry attempts if strategy is 'retry' retryDelay: 500, // Delay in ms between retries }); ``` / export interface LoadOptions { /** Callback for progress updates during loading ```ts const options: LoadOptions = { onProgress: (progress) => { console.log(`Loading progress: ${progress * 100}%`); }, }; await Assets.load('image.png', options); ``` / onProgress?: (progress: number) => void; /** Callback for handling errors during loading ```ts const options: LoadOptions = { onError: (error, url) => { console.error(`Failed to load ${url}: ${error.message}`); }, }; await Assets.load('missing-file.png', options); ``` / onError?: (error: Error, url: string | ResolvedAsset) => void; /** Strategy to handle load failures - 'throw': Immediately throw an error and stop loading (default) - 'skip': Skip the failed asset and continue loading others - 'retry': Retry loading the asset a specified number of times ```ts const options: LoadOptions = { strategy: 'skip', }; await Assets.load('sometimes-fails.png', options); ``` / strategy?: 'throw' | 'skip' | 'retry'; /** Number of retry attempts if strategy is 'retry' ```ts const options: LoadOptions = { strategy: 'retry', retryCount: 5, // Retry up to 5 times }; await Assets.load('unstable-asset.png', options); ``` / retryCount?: number; /** Delay in milliseconds between retry attempts ```ts const options: LoadOptions = { strategy: 'retry', retryDelay: 1000, // Wait 1 second between retries }; await Assets.load('sometimes-fails.png', options); ``` / retryDelay?: number; } /** The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc. It does not do anything clever with URLs - it just loads stuff! Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once. Through the use of LoaderParsers, the loader can understand how to load any kind of file! It is not intended that this class is created by developers - its part of the Asset class This is the second major system of PixiJS' main Assets class",
  "category": "assets",
  "deprecated": false,
  "methods": [
    {
      "name": "reset",
      "params": [],
      "returnType": "void",
      "description": "Default options for loading assets ```ts // Change default load options globally Loader.defaultOptions = { strategy: 'skip', // Change default strategy to 'skip' retryCount: 5,   // Change default retry count to 5 retryDelay: 500, // Change default retry delay to 500ms }; ``` / public static defaultOptions: LoadOptions = { onProgress: undefined, onError: undefined, strategy: 'throw', retryCount: 3, retryDelay: 250, }; /** Options for loading assets with the loader. These options will be used as defaults for all load calls made with this loader instance. They can be overridden by passing options directly to the load method. ```ts // Create a loader with custom default options const loader = new Loader(); loader.loadOptions = { strategy: 'skip', // Default strategy to 'skip' retryCount: 5,   // Default retry count to 5 retryDelay: 500, // Default retry delay to 500ms }; // This load call will use the loader's default options await loader.load('image1.png'); / public loadOptions: LoadOptions = { ...Loader.defaultOptions }; private readonly _parsers: LoaderParser[] = []; private _parserHash: Record<string, LoaderParser>; private _parsersValidated = false; /** All loader parsers registered / public parsers = new Proxy(this._parsers, { set: (target, key, value) => { this._parsersValidated = false; target[key as any as number] = value; return true; } }); /** Cache loading promises that ae currently active */ public promiseCache: Record<string, PromiseAndParser> = {}; /** function used for testing"
    },
    {
      "name": "unload",
      "params": [
        {
          "name": "assetsToUnloadIn",
          "type": "string | string[] | ResolvedAsset | ResolvedAsset[]",
          "optional": false,
          "default": null
        },
        {
          "name": "",
          "type": null
        }
      ],
      "returnType": "Promise<void>",
      "description": "Used internally to generate a promise for the asset to be loaded. / private _getLoadPromiseAndParser(url: string, data?: ResolvedAsset): PromiseAndParser { const result: PromiseAndParser = { promise: null, parser: null }; result.promise = (async () => { let asset = null; let parser: LoaderParser = null; // first check to see if the user has specified a parser if (data.parser || data.loadParser) { // they have? lovely, lets use it parser = this._parserHash[data.parser || data.loadParser]; // #if _DEBUG if (data.loadParser) { warn( `[Assets] \"loadParser\" is deprecated, use \"parser\" instead for ${url}` ); } // #endif if (!parser) { // #if _DEBUG warn( `[Assets] specified load parser \"${data.parser || data.loadParser}\" not found while loading ${url}` ); // #endif } } // no parser specified, so lets try and find one using the tests if (!parser) { for (let i = 0; i < this.parsers.length; i++) { const parserX = this.parsers[i]; if (parserX.load && parserX.test?.(url, data, this)) { parser = parserX; break; } } if (!parser) { // #if _DEBUG // eslint-disable-next-line max-len warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`); // #endif return null; } } asset = await parser.load(url, data, this); result.parser = parser; for (let i = 0; i < this.parsers.length; i++) { const parser = this.parsers[i]; if (parser.parse) { if (parser.parse && await parser.testParse?.(asset, data, this)) { // transform the asset.. asset = await parser.parse(asset, data, this) || asset; result.parser = parser; } } } return asset; })(); return result; } /** Loads one or more assets using the parsers added to the Loader. // Single asset: const asset = await Loader.load('cool.png'); console.log(asset); // Multiple assets: const assets = await Loader.load(['cool.png', 'cooler.png']); console.log(assets); when progress on asset loading is made. The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0) of the assets loaded. Do not use this function to detect when assets are complete and available, instead use the Promise returned by this function. / public async load<T = any>( assetsToLoadIn: string | ResolvedAsset, onProgress?: ProgressCallback | LoadOptions, ): Promise<T>; public async load<T = any>( assetsToLoadIn: string[] | ResolvedAsset[], onProgress?: ProgressCallback | LoadOptions, ): Promise<Record<string, T>>; public async load<T = any>( assetsToLoadIn: string | string[] | ResolvedAsset | ResolvedAsset[], onProgressOrOptions?: ProgressCallback | LoadOptions, ): Promise<T | Record<string, T>> { if (!this._parsersValidated) { this._validateParsers(); } const options: LoadOptions = typeof onProgressOrOptions === 'function' ? { ...Loader.defaultOptions, ...this.loadOptions, onProgress: onProgressOrOptions } : { ...Loader.defaultOptions, ...this.loadOptions, ...(onProgressOrOptions || {}) }; const { onProgress, onError, strategy, retryCount, retryDelay } = options; let count = 0; const assets: Record<string, Promise<any>> = {}; const singleAsset = isSingleItem(assetsToLoadIn); const assetsToLoad = convertToList<ResolvedAsset>(assetsToLoadIn, (item) => ({ alias: [item], src: item, data: {} })); const total = assetsToLoad.reduce((sum, asset) => sum + (asset.progressSize || 1), 0); const promises: Promise<void>[] = assetsToLoad.map(async (asset: ResolvedAsset) => { const url = path.toAbsolute(asset.src); if (assets[asset.src]) return; await this._loadAssetWithRetry(url, asset, { onProgress, onError, strategy, retryCount, retryDelay }, assets); count += (asset.progressSize || 1); if (onProgress) onProgress(count / total); }); await Promise.all(promises); return singleAsset ? assets[assetsToLoad[0].src] : assets; } /** Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app. The parser that created the asset, will be the one that unloads it. // Single asset: const asset = await Loader.load('cool.png'); await Loader.unload('cool.png'); console.log(asset.destroyed); // true"
    },
    {
      "name": "map",
      "params": [
        {
          "name": "asset",
          "type": "ResolvedAsset",
          "optional": false,
          "default": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "toAbsolute",
      "params": [
        {
          "name": "asset.src",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "loadPromise",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "all",
      "params": [
        {
          "name": "promises",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "filter",
      "params": [
        {
          "name": "(parser",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "reduce",
      "params": [
        {
          "name": "(hash",
          "type": null
        },
        {
          "name": "parser",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "!parser.name && !parser.id",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "warn",
      "params": [
        {
          "name": "`[Assets] parser should have an id`",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "hash[parser.name] || hash[parser.id]",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "warn",
      "params": [
        {
          "name": "`[Assets] parser id conflict \"${parser.id}\"`",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "parser.id",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "Promise",
      "params": [
        {
          "name": "(r",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "setTimeout",
      "params": [
        {
          "name": "r",
          "type": null
        },
        {
          "name": "ms",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "while",
      "params": [
        {
          "name": "true",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "!this.promiseCache[url]",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "catch",
      "params": [
        {
          "name": "e",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "strategy === 'retry' && !isLast",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "onError",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "onError",
      "params": [
        {
          "name": "e as Error",
          "type": null
        },
        {
          "name": "asset",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "wait",
      "params": [
        {
          "name": "retryDelay",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "strategy === 'skip'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "onError",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "onError",
      "params": [
        {
          "name": "e as Error",
          "type": null
        },
        {
          "name": "asset",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "onError",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "onError",
      "params": [
        {
          "name": "e as Error",
          "type": null
        },
        {
          "name": "asset",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "Error",
      "params": [
        {
          "name": "`[Loader.load] Failed to load ${url}.\\n${e}`",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    }
  ],
  "properties": []
}