{
  "type": "class",
  "name": "AssetsClass",
  "sourcePath": "assets/Assets.ts",
  "extends": null,
  "implements": [],
  "description": "Callback function for tracking asset loading progress. The function is called repeatedly during the loading process with a progress value between 0.0 and 1.0. ```ts // Basic progress logging const onProgress = (progress: number) => { console.log(`Loading: ${Math.round(progress * 100)}%`); }; // Update loading bar const onProgress = (progress: number) => { loadingBar.width = progress * 100; loadingText.text = `${Math.round(progress * 100)}%`; }; // Load assets with progress tracking await Assets.load(['sprite1.png', 'sprite2.png'], onProgress); // Load bundle with progress tracking await Assets.loadBundle('levelAssets', (progress) => { // Progress is normalized (0.0 - 1.0) updateLoadingScreen(progress); }); ``` > [!IMPORTANT] Do not rely on the progress callback to determine when all assets are loaded. > Use the returned promise from `Assets.load()` or `Assets.loadBundle()` to know when loading is complete. / export type ProgressCallback = (progress: number) => void; /** Extensible preferences that can be used, for instance, when configuring loaders. / export interface AssetsPreferences extends LoadTextureConfig, LoadSVGConfig, PixiMixins.AssetsPreferences {} /** Options for initializing the Assets class. These options configure how assets are loaded, resolved, and managed in your PixiJS application. / export interface AssetInitOptions { /** Base path prepended to all asset URLs. Useful for CDN hosting. ```ts await Assets.init({ basePath: 'https://my-cdn.com/assets/' }); // Now you can load assets like this: // Will load from: https://my-cdn.com/assets/images/sprite.png const texture = await Assets.load('images/sprite.png'); ``` / basePath?: string; /** URL parameters to append to all asset URLs. Useful for cache-busting or version control. ```ts // As a string await Assets.init({ defaultSearchParams: 'version=1.0.0' }); // As an object await Assets.init({ defaultSearchParams: { version: '1.0.0', t: Date.now() } }); ``` / defaultSearchParams?: string | Record<string, any>; /** A manifest defining all your application's assets. Can be a URL to a JSON file or a manifest object. ```ts // Using a manifest object await Assets.init({ manifest: { bundles: [{ name: 'game-screen', assets: [ { alias: 'hero', src: 'hero.{png,webp}' }, { alias: 'map', src: 'map.json' } ] }] } }); // Using a URL to manifest await Assets.init({ manifest: 'assets/manifest.json' }); // loading a bundle from the manifest await Assets.loadBundle('game-screen'); // load individual assets from the manifest const heroTexture = await Assets.load('hero'); ``` / manifest?: string | AssetsManifest; /** Configure texture loading preferences. Useful for optimizing asset delivery based on device capabilities. ```ts await Assets.init({ texturePreference: { // Prefer high-res textures on retina displays resolution: window.devicePixelRatio, // Prefer modern formats, fallback to traditional format: ['avif', 'webp', 'png'] } }); ``` / texturePreference?: { /** Preferred texture resolution(s). Can be a single number or array of resolutions in order of preference. */ resolution?: number | number[]; /** Preferred texture formats in order of preference. Default: ['avif', 'webp', 'png', 'jpg', 'jpeg'] */ format?: ArrayOr<string>; }; /** Skip browser format detection for faster initialization. Only use if you know exactly what formats your target browsers support. ```ts await Assets.init({ skipDetections: true, texturePreference: { format: ['webp', 'png'] // Must explicitly set formats } }); ``` / skipDetections?: boolean; /** Override how bundle IDs are generated and resolved. This allows you to customize how assets are grouped and accessed via bundles and allow for multiple bundles to share the same asset keys. ```ts const manifest = { bundles: [ { name: 'bunny1', assets: [ { alias: ['character', 'character2'], src: 'textures/bunny.png', }, ], }, { name: 'bunny2', assets: [ { alias: ['character', 'character2'], src: 'textures/bunny-2.png', }, ], }, ] }; const bundleIdentifier: BundleIdentifierOptions = { connector: ':', }; await Assets.init({ manifest, basePath, bundleIdentifier }); const resources = await Assets.loadBundle('bunny1'); const resources2 = await Assets.loadBundle('bunny2'); console.log(resources.character === resources2.character); // false ``` / bundleIdentifier?: BundleIdentifierOptions; /** Optional preferences for asset loading behavior. ```ts await Assets.init({ preferences: { crossOrigin: 'anonymous', parseAsGraphicsContext: false } }); ``` / preferences?: Partial<AssetsPreferences>; /** Options for defining the loading behavior of assets. ```ts await Assets.init({ loadOptions: { onProgress: (progress) => console.log(`Loading: ${Math.round(progress * 100)}%`), onError: (error, asset) => console.error(`Error loading ${asset.src}: ${error.message}`), strategy: 'retry', retryCount: 5, retryDelay: 500, } }); ``` - `onProgress` callback receives values from 0.0 to 1.0 - `onError` callback is invoked for individual asset load failures - `strategy` can be 'throw' (default), 'retry', or 'skip' - `retryCount` sets how many times to retry failed assets (default 3) - `retryDelay` sets the delay between retries in milliseconds (default 250ms) / loadOptions?: Partial<LoadOptions>; } /** @internal",
  "category": "assets",
  "deprecated": false,
  "methods": [
    {
      "name": "init",
      "params": [
        {
          "name": "options",
          "type": "AssetInitOptions",
          "optional": true,
          "default": "{}"
        }
      ],
      "returnType": "Promise<void>",
      "description": "The URL resolver for assets. Maps various asset keys and URLs to their final loadable form. / public resolver: Resolver; /** The loader responsible for loading all assets. Handles different file types and transformations. / public loader: Loader; /** The global cache for all loaded assets. Manages storage and retrieval of processed assets. ```ts // Check if an asset is cached if (Assets.cache.has('myTexture')) { const texture = Assets.cache.get('myTexture'); } ``` / public cache: typeof Cache; /** takes care of loading assets in the background */ private readonly _backgroundLoader: BackgroundLoader; private readonly _detections: FormatDetectionParser[] = []; private _initialized = false; constructor() { this.resolver = new Resolver(); this.loader = new Loader(); this.cache = Cache; this._backgroundLoader = new BackgroundLoader(this.loader); this._backgroundLoader.active = true; this.reset(); } /** Initializes the Assets class with configuration options. While not required, calling this before loading assets is recommended to set up default behaviors. ```ts // Basic initialization (optional as Assets.load will call this automatically) await Assets.init(); // With CDN configuration await Assets.init({ basePath: 'https://my-cdn.com/assets/', defaultSearchParams: { version: '1.0.0' } }); // With manifest and preferences await Assets.init({ manifest: { bundles: [{ name: 'game-screen', assets: [ { alias: 'hero', src: 'hero.{png,webp}', data: { scaleMode: SCALE_MODES.NEAREST } }, { alias: 'map', src: 'map.json' } ] }] }, // Optimize for device capabilities texturePreference: { resolution: window.devicePixelRatio, format: ['webp', 'png'] }, // Set global preferences preferences: { crossOrigin: 'anonymous', } }); // Load assets after initialization const heroTexture = await Assets.load('hero'); ``` - Can be called only once; subsequent calls will be ignored with a warning - Format detection runs automatically unless `skipDetections` is true - The manifest can be a URL to a JSON file or an inline object"
    },
    {
      "name": "if",
      "params": [
        {
          "name": "this._initialized",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "warn",
      "params": [
        {
          "name": "'[Assets]AssetManager already initialized",
          "type": null
        },
        {
          "name": "did you load before calling this Assets.init(",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "options.defaultSearchParams",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "setDefaultSearchParams",
      "params": [
        {
          "name": "options.defaultSearchParams",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "options.basePath",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "options.bundleIdentifier",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "setBundleIdentifier",
      "params": [
        {
          "name": "options.bundleIdentifier",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "options.manifest",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "typeof manifest === 'string'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "addManifest",
      "params": [
        {
          "name": "manifest",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "prefer",
      "params": [
        {
          "name": "params",
          "type": "{\n                format: formats",
          "optional": false,
          "default": null
        },
        {
          "name": "resolution",
          "type": null
        },
        {
          "name": "}",
          "type": null
        },
        {
          "name": "}",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "options.preferences",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "setPreferences",
      "params": [
        {
          "name": "options.preferences",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "options.loadOptions",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "add",
      "params": [
        {
          "name": "assets",
          "type": "(ArrayOr<UnresolvedAsset>",
          "optional": false,
          "default": null
        }
      ],
      "returnType": null,
      "description": "Registers assets with the Assets resolver. This method maps keys (aliases) to asset sources, allowing you to load assets using friendly names instead of direct URLs. ```ts // Basic usage - single asset Assets.add({ alias: 'myTexture', src: 'assets/texture.png' }); const texture = await Assets.load('myTexture'); // Multiple aliases for the same asset Assets.add({ alias: ['hero', 'player'], src: 'hero.png' }); const hero1 = await Assets.load('hero'); const hero2 = await Assets.load('player'); // Same texture // Multiple format support Assets.add({ alias: 'character', src: 'character.{webp,png}' // Will choose best format }); Assets.add({ alias: 'character', src: ['character.webp', 'character.png'], // Explicitly specify formats }); // With texture options Assets.add({ alias: 'sprite', src: 'sprite.png', data: { scaleMode: 'nearest' } }); // Multiple assets at once Assets.add([ { alias: 'bg', src: 'background.png' }, { alias: 'music', src: 'music.mp3' }, { alias: 'spritesheet', src: 'sheet.json', data: { ignoreMultiPack: false } } ]); ``` - Assets are resolved when loaded, not when added - Multiple formats use the best available format for the browser - Adding with same alias overwrites previous definition - The `data` property is passed to the asset loader"
    },
    {
      "name": "add",
      "params": [
        {
          "name": "assets",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "addBundle",
      "params": [
        {
          "name": "bundleId",
          "type": "string",
          "optional": false,
          "default": null
        },
        {
          "name": "assets",
          "type": "AssetsBundle['assets']",
          "optional": false,
          "default": null
        }
      ],
      "returnType": "void",
      "description": "Loads one or more assets and returns a promise that resolves with the loaded content. Assets are cached, so subsequent loads will return the same instance of the asset without re-fetching. ```ts // Load a single asset const texture = await Assets.load('images/sprite.png'); // Load using an alias const heroTexture = await Assets.load({ alias: 'hero', src: 'images/hero.png' }); // Load multiple assets const assets = await Assets.load([ 'images/background.png', 'images/character.png', 'fonts/game.fnt' ]); console.log(assets['images/background.png']); // Access by URL // Load with progress tracking const textures = await Assets.load(['sprite1.png', 'sprite2.png'], (progress) => console.log(`Loading: ${Math.round(progress * 100)}%`) ); // Load with format preference const characterTexture = await Assets.load({ alias: 'character', src: 'character.{webp,png}' // Will choose best format }); // Load with custom options const spriteTexture = await Assets.load({ alias: 'sprite', src: 'sprite.png', data: { scaleMode: SCALE_MODES.NEAREST, mipmap: MIPMAP_MODES.ON } }); // Load with a specific loader, can be useful if your asset does not have an extension const image = await Assets.load({ alias: 'imageWithoutExtension', src: 'images/imageWithoutExtension', parser: 'texture' // Use the JSON loader }); ``` - Assets are cached automatically to prevent duplicate loading - URLs are resolved to the best format for the current browser - Asset types are detected automatically based on file extension - Progress callback receives values from 0.0 to 1.0 - You can define with loader to use for an asset by specifying the `parser` property, which is useful for assets that do not have a file extension. / public async load<T = any>( urls: string | UnresolvedAsset, onProgress?: ProgressCallback | LoadOptions, ): Promise<T>; public async load<T = any>( urls: string[] | UnresolvedAsset[], onProgress?: ProgressCallback | LoadOptions, ): Promise<Record<string, T>>; public async load<T = any>( urls: ArrayOr<string> | ArrayOr<UnresolvedAsset>, onProgress?: ProgressCallback | LoadOptions, ): Promise<T | Record<string, T>> { if (!this._initialized) { await this.init(); } const singleAsset = isSingleItem(urls); const urlArray: string[] = convertToList<UnresolvedAsset | string>(urls) .map((url) => { if (typeof url !== 'string') { const aliases = this.resolver.getAlias(url); if (aliases.some((alias) => !this.resolver.hasKey(alias))) { this.add(url); } return Array.isArray(aliases) ? aliases[0] : aliases; } // if it hasn't been added, add it now if (!this.resolver.hasKey(url)) this.add({ alias: url, src: url }); return url; }) as string[]; // check cache first... const resolveResults = this.resolver.resolve(urlArray); // remap to the keys used.. const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress); return singleAsset ? out[urlArray[0] as string] : out; } /** Registers a bundle of assets that can be loaded as a group. Bundles are useful for organizing assets into logical groups, such as game levels or UI screens. ```ts // Add a bundle using array format Assets.addBundle('animals', [ { alias: 'bunny', src: 'bunny.png' }, { alias: 'chicken', src: 'chicken.png' }, { alias: 'thumper', src: 'thumper.png' }, ]); // Add a bundle using object format Assets.addBundle('animals', { bunny: 'bunny.png', chicken: 'chicken.png', thumper: 'thumper.png', }); // Add a bundle with advanced options Assets.addBundle('ui', [ { alias: 'button', src: 'button.{webp,png}', data: { scaleMode: 'nearest' } }, { alias: ['logo', 'brand'],  // Multiple aliases src: 'logo.svg', data: { resolution: 2 } } ]); // Load the bundle await Assets.loadBundle('animals'); // Use the loaded assets const bunny = Sprite.from('bunny'); const chicken = Sprite.from('chicken'); ``` - Bundle IDs must be unique - Assets in bundles are not loaded until `loadBundle` is called - Bundles can be background loaded using `backgroundLoadBundle` - Assets in bundles can be loaded individually using their aliases"
    },
    {
      "name": "addBundle",
      "params": [
        {
          "name": "bundleId",
          "type": null
        },
        {
          "name": "assets",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "loadBundle",
      "params": [
        {
          "name": "bundleIds",
          "type": "ArrayOr<string>",
          "optional": false,
          "default": null
        },
        {
          "name": "onProgress",
          "type": "ProgressCallback",
          "optional": true,
          "default": null
        }
      ],
      "returnType": "Promise<any>",
      "description": "Loads a bundle or multiple bundles of assets. Bundles are collections of related assets that can be loaded together. ```ts // Define bundles in your manifest const manifest = { bundles: [ { name: 'load-screen', assets: [ { alias: 'background', src: 'sunset.png', }, { alias: 'bar', src: 'load-bar.{png,webp}', // use an array of individual assets }, ], }, { name: 'game-screen', assets: [ { alias: 'character', src: 'robot.png', }, { alias: 'enemy', src: 'bad-guy.png', }, ], }, ] }; // Initialize with manifest await Assets.init({ manifest }); // Or add bundles programmatically Assets.addBundle('load-screen', [...]); Assets.loadBundle('load-screen'); // Load a single bundle await Assets.loadBundle('load-screen'); const bg = Sprite.from('background'); // Uses alias from bundle // Load multiple bundles await Assets.loadBundle([ 'load-screen', 'game-screen' ]); // Load with progress tracking await Assets.loadBundle('game-screen', (progress) => { console.log(`Loading: ${Math.round(progress * 100)}%`); }); ``` - Bundle assets are cached automatically - Bundles can be pre-loaded using `backgroundLoadBundle` - Assets in bundles can be accessed by their aliases - Progress callback receives values from 0.0 to 1.0"
    },
    {
      "name": "if",
      "params": [
        {
          "name": "!this._initialized",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "init",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "typeof bundleIds === 'string'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "resolveBundle",
      "params": [
        {
          "name": "bundleIds",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "keys",
      "params": [
        {
          "name": "resolveResults",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "reduce",
      "params": [
        {
          "name": "(a",
          "type": null
        },
        {
          "name": "b",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "map",
      "params": [
        {
          "name": "(bundleId",
          "type": null
        },
        {
          "name": "i",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "values",
      "params": [
        {
          "name": "resolveResult",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "Set",
      "params": [
        {
          "name": "values.flat(",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "reduce",
      "params": [
        {
          "name": "(sum",
          "type": null
        },
        {
          "name": "asset",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "push",
      "params": [
        {
          "name": "0",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "then",
      "params": [
        {
          "name": "(resolveResult",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "all",
      "params": [
        {
          "name": "promises",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "backgroundLoad",
      "params": [
        {
          "name": "urls",
          "type": "ArrayOr<string>",
          "optional": false,
          "default": null
        }
      ],
      "returnType": "Promise<void>",
      "description": "Initiates background loading of assets. This allows assets to be loaded passively while other operations continue, making them instantly available when needed later. Background loading is useful for: - Preloading game levels while in a menu - Loading non-critical assets during gameplay - Reducing visible loading screens ```ts // Basic background loading Assets.backgroundLoad('images/level2-assets.png'); // Background load multiple assets Assets.backgroundLoad([ 'images/sprite1.png', 'images/sprite2.png', 'images/background.png' ]); // Later, when you need the assets const textures = await Assets.load([ 'images/sprite1.png', 'images/sprite2.png' ]); // Resolves immediately if background loading completed ``` - Background loading happens one asset at a time to avoid blocking the main thread - Loading can be interrupted safely by calling `Assets.load()` - Assets are cached as they complete loading - No progress tracking is available for background loading"
    },
    {
      "name": "if",
      "params": [
        {
          "name": "!this._initialized",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "init",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "typeof urls === 'string'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "resolve",
      "params": [
        {
          "name": "urls",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "add",
      "params": [
        {
          "name": "Object.values(resolveResults",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "backgroundLoadBundle",
      "params": [
        {
          "name": "bundleIds",
          "type": "ArrayOr<string>",
          "optional": false,
          "default": null
        }
      ],
      "returnType": "Promise<void>",
      "description": "Initiates background loading of asset bundles. Similar to backgroundLoad but works with predefined bundles of assets. Perfect for: - Preloading level bundles during gameplay - Loading UI assets during splash screens - Preparing assets for upcoming game states ```ts // Define bundles in your manifest await Assets.init({ manifest: { bundles: [ { name: 'home', assets: [ { alias: 'background', src: 'images/home-bg.png', }, { alias: 'logo', src: 'images/logo.png', } ] }, { name: 'level-1', assets: [ { alias: 'background', src: 'images/level1/bg.png', }, { alias: 'sprites', src: 'images/level1/sprites.json' } ] }] } }); // Load the home screen assets right away await Assets.loadBundle('home'); showHomeScreen(); // Start background loading while showing home screen Assets.backgroundLoadBundle('level-1'); // When player starts level, load completes faster await Assets.loadBundle('level-1'); hideHomeScreen(); startLevel(); ``` - Bundle assets are loaded one at a time - Loading can be interrupted safely by calling `Assets.loadBundle()` - Assets are cached as they complete loading - Requires bundles to be registered via manifest or `addBundle`"
    },
    {
      "name": "if",
      "params": [
        {
          "name": "!this._initialized",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "init",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "typeof bundleIds === 'string'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "resolveBundle",
      "params": [
        {
          "name": "bundleIds",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "values",
      "params": [
        {
          "name": "resolveResults",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "forEach",
      "params": [
        {
          "name": "(resolveResult",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "add",
      "params": [
        {
          "name": "Object.values(resolveResult",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "reset",
      "params": [],
      "returnType": "void",
      "description": "Only intended for development purposes. This will wipe the resolver and caches. You will need to reinitialize the Asset"
    },
    {
      "name": "reset",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "reset",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "reset",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "unload",
      "params": [
        {
          "name": "urls",
          "type": "ArrayOr<string> | ResolvedAsset | ResolvedAsset[]",
          "optional": false,
          "default": null
        }
      ],
      "returnType": "Promise<void>",
      "description": "Instantly gets an asset already loaded from the cache. Returns undefined if the asset hasn't been loaded yet. ```ts // Get a single cached asset const texture = Assets.get('hero'); if (texture) { const sprite = new Sprite(texture); } // Get multiple cached assets const textures = Assets.get([ 'hero', 'background', 'enemy' ]); // Safe pattern with loading fallback let texture = Assets.get('hero'); if (!texture) { texture = await Assets.load('hero'); } // Working with bundles await Assets.loadBundle('game-ui'); const uiAssets = Assets.get([ 'button', 'panel', 'icons' ]); ``` - Returns undefined if asset isn't loaded - No automatic loading - use `Assets.load()` for that - Cached assets are shared instances - Faster than `load()` for already cached assets > [!TIP] > When in doubt, use `Assets.load()` instead. It will return cached > assets instantly if they're already loaded. / public get<T = any>(keys: string): T; public get<T = any>(keys: string[]): Record<string, T>; public get<T = any>(keys: ArrayOr<string>): T | Record<string, T> { if (typeof keys === 'string') { return Cache.get(keys); } const assets: Record<string, T> = {}; for (let i = 0; i < keys.length; i++) { assets[i] = Cache.get(keys[i]); } return assets; } /** helper function to map resolved assets back to loaded assets / private async _mapLoadToResolve<T>( resolveResults: ResolvedAsset | Record<string, ResolvedAsset>, progressOrLoadOptions?: ProgressCallback | LoadOptions, ): Promise<Record<string, T>> { const resolveArray = [...new Set(Object.values(resolveResults))] as ResolvedAsset[]; // pause background loader... this._backgroundLoader.active = false; const loadedAssets = await this.loader.load<T>(resolveArray, progressOrLoadOptions); // resume background loader... this._backgroundLoader.active = true; // remap to the keys used.. const out: Record<string, T> = {}; resolveArray.forEach((resolveResult) => { const asset = loadedAssets[resolveResult.src]; const keys = [resolveResult.src]; if (resolveResult.alias) { keys.push(...resolveResult.alias); } keys.forEach((key) => { out[key] = asset; }); Cache.set(keys, asset); }); return out; } /** Unloads assets and releases them from memory. This method ensures proper cleanup of loaded assets when they're no longer needed. ```ts // Unload a single asset await Assets.unload('images/sprite.png'); // Unload using an alias await Assets.unload('hero'); // Unloads the asset registered with 'hero' alias // Unload multiple assets await Assets.unload([ 'images/background.png', 'images/character.png', 'hero' ]); // Unload and handle creation of new instances await Assets.unload('hero'); const newHero = await Assets.load('hero'); // Will load fresh from source ``` > [!WARNING] > Make sure assets aren't being used before unloading: > - Remove sprites using the texture > - Clear any references to the asset > - Textures will be destroyed and can't be used after unloading"
    },
    {
      "name": "if",
      "params": [
        {
          "name": "!this._initialized",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "init",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "map",
      "params": [
        {
          "name": "(url",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "resolve",
      "params": [
        {
          "name": "urlArray",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "unloadBundle",
      "params": [
        {
          "name": "bundleIds",
          "type": "ArrayOr<string>",
          "optional": false,
          "default": null
        }
      ],
      "returnType": "Promise<void>",
      "description": "Unloads all assets in a bundle. Use this to free memory when a bundle's assets are no longer needed, such as when switching game levels. ```ts // Define and load a bundle Assets.addBundle('level-1', { background: 'level1/bg.png', sprites: 'level1/sprites.json', music: 'level1/music.mp3' }); // Load the bundle const level1 = await Assets.loadBundle('level-1'); // Use the assets const background = Sprite.from(level1.background); // When done with the level, unload everything await Assets.unloadBundle('level-1'); // background sprite is now invalid! // Unload multiple bundles await Assets.unloadBundle([ 'level-1', 'level-2', 'ui-elements' ]); ``` > [!WARNING] > - All assets in the bundle will be destroyed > - Bundle needs to be reloaded to use assets again > - Make sure no sprites or other objects are using the assets"
    },
    {
      "name": "if",
      "params": [
        {
          "name": "!this._initialized",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "init",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "resolveBundle",
      "params": [
        {
          "name": "bundleIds",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "keys",
      "params": [
        {
          "name": "resolveResults",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "map",
      "params": [
        {
          "name": "(bundleId",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "all",
      "params": [
        {
          "name": "promises",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "values",
      "params": [
        {
          "name": "resolveResult",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "forEach",
      "params": [
        {
          "name": "(resolveResult",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "remove",
      "params": [
        {
          "name": "resolveResult.src",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "unload",
      "params": [
        {
          "name": "resolveArray",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "setPreferences",
      "params": [
        {
          "name": "preferences",
          "type": "Partial<AssetsPreferences>",
          "optional": false,
          "default": null
        }
      ],
      "returnType": "void",
      "description": "Detects the supported formats for the browser, and returns an array of supported formats, respecting the users preferred formats order. / private async _detectFormats(options: { preferredFormats: string | string[], skipDetections: boolean, detections: FormatDetectionParser[] }): Promise<string[]> { let formats: string[] = []; // set preferred formats if (options.preferredFormats) { formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats]; } // we should add any formats that are supported by the browser for (const detection of options.detections) { if (options.skipDetections || await detection.test()) { formats = await detection.add(formats); } else if (!options.skipDetections) { formats = await detection.remove(formats); } } // remove any duplicates formats = formats.filter((format, index) => formats.indexOf(format) === index); return formats; } /** All the detection parsers currently added to the Assets class. / public get detections(): FormatDetectionParser[] { return this._detections; } /** Sets global preferences for asset loading behavior. This method configures how assets are loaded and processed across all parsers. ```ts // Basic preferences Assets.setPreferences({ crossOrigin: 'anonymous', parseAsGraphicsContext: false }); ``` Preferences are applied to all compatible parsers and affect future asset loading. Common preferences include: - `crossOrigin`: CORS setting for loaded assets - `preferWorkers`: Whether to use web workers for loading textures - `preferCreateImageBitmap`: Use `createImageBitmap` for texture creation. Turning this off will use the `Image` constructor instead."
    },
    {
      "name": "forEach",
      "params": [
        {
          "name": "(parser",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "!parser.config",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "keys",
      "params": [
        {
          "name": "parser.config",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "as",
      "params": [
        {
          "name": "keyof AssetsPreferences",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "filter",
      "params": [
        {
          "name": "(key",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "forEach",
      "params": [
        {
          "name": "(key",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "options",
      "params": [
        {
          "name": "optional",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "init",
      "params": [
        {
          "name": "basePath",
          "type": "'https://my-cdn.com/assets/'",
          "optional": false,
          "default": null
        },
        {
          "name": "manifest",
          "type": "{\n *        bundles: [{ name: 'gameAssets'",
          "optional": false,
          "default": null
        },
        {
          "name": "assets",
          "type": "[] }",
          "optional": false,
          "default": null
        },
        {
          "name": "...]",
          "type": null
        },
        {
          "name": "*     }",
          "type": null
        },
        {
          "name": "texturePreference",
          "type": "{\n *         resolution: window.devicePixelRatio",
          "optional": false,
          "default": null
        },
        {
          "name": "format",
          "type": "['avif'",
          "optional": false,
          "default": null
        },
        {
          "name": "'webp'",
          "type": null
        },
        {
          "name": "'png']\n *     }\n * }",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "load",
      "params": [
        {
          "name": "'images/sprite.png'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "load",
      "params": [
        {
          "name": "[\n *     'images/bg.png'",
          "type": null
        },
        {
          "name": "*     'images/character.png'",
          "type": null
        },
        {
          "name": "*     'fonts/game.fnt'\n * ]",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "load",
      "params": [
        {
          "name": "alias",
          "type": "'hero'",
          "optional": false,
          "default": null
        },
        {
          "name": "src",
          "type": "'images/hero.{webp",
          "optional": false,
          "default": null
        },
        {
          "name": "png}' }",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "from",
      "params": [
        {
          "name": "'hero'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "backgroundLoad",
      "params": [
        {
          "name": "['images/level1.json'",
          "type": null
        },
        {
          "name": "'images/level2.json']",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "loadBundle",
      "params": [
        {
          "name": "'gameAssets'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "loadBundle",
      "params": [
        {
          "name": "'gameAssets'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "backgroundLoadBundle",
      "params": [
        {
          "name": "'resultsAssets'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "unload",
      "params": [
        {
          "name": "'hero'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "unloadBundle",
      "params": [
        {
          "name": "'levelOne'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "AssetsClass",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "handleByList",
      "params": [
        {
          "name": "ExtensionType.LoadParser",
          "type": null
        },
        {
          "name": "Assets.loader.parsers",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "handleByList",
      "params": [
        {
          "name": "ExtensionType.ResolveParser",
          "type": null
        },
        {
          "name": "Assets.resolver.parsers",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "handleByList",
      "params": [
        {
          "name": "ExtensionType.CacheParser",
          "type": null
        },
        {
          "name": "Assets.cache.parsers",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "handleByList",
      "params": [
        {
          "name": "ExtensionType.DetectionParser",
          "type": null
        },
        {
          "name": "Assets.detections",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "add",
      "params": [
        {
          "name": "cacheTextureArray",
          "type": null
        },
        {
          "name": "detectDefaults",
          "type": null
        },
        {
          "name": "detectAvif",
          "type": null
        },
        {
          "name": "detectWebp",
          "type": null
        },
        {
          "name": "detectMp4",
          "type": null
        },
        {
          "name": "detectOgv",
          "type": null
        },
        {
          "name": "detectWebm",
          "type": null
        },
        {
          "name": "loadJson",
          "type": null
        },
        {
          "name": "loadTxt",
          "type": null
        },
        {
          "name": "loadWebFont",
          "type": null
        },
        {
          "name": "loadSvg",
          "type": null
        },
        {
          "name": "loadTextures",
          "type": null
        },
        {
          "name": "loadVideoTextures",
          "type": null
        },
        {
          "name": "loadBitmapFont",
          "type": null
        },
        {
          "name": "bitmapFontCachePlugin",
          "type": null
        },
        {
          "name": "resolveTextureUrl",
          "type": null
        },
        {
          "name": "resolveJsonUrl",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "handle",
      "params": [
        {
          "name": "ExtensionType.Asset",
          "type": null
        },
        {
          "name": "(extension",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "entries",
      "params": [
        {
          "name": "assetKeyMap",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "filter",
      "params": [
        {
          "name": "([key]",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "forEach",
      "params": [
        {
          "name": "([key",
          "type": null
        },
        {
          "name": "type]",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "add",
      "params": [
        {
          "name": "Object.assign(\n            ref[key as AssetType]",
          "type": null
        },
        {
          "name": "// Allow the function to optionally define it's own\n            // ExtensionMetadata",
          "type": null
        },
        {
          "name": "extension",
          "type": "ref[key as AssetType].extension ?? type }",
          "optional": false,
          "default": null
        },
        {
          "name": "",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "keys",
      "params": [
        {
          "name": "assetKeyMap",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "filter",
      "params": [
        {
          "name": "(key",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "forEach",
      "params": [
        {
          "name": "(key",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "remove",
      "params": [
        {
          "name": "ref[key as AssetType]",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    }
  ],
  "properties": []
}