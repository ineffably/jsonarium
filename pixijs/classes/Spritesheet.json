{
  "type": "class",
  "name": "Spritesheet",
  "sourcePath": "spritesheet/Spritesheet.ts",
  "extends": null,
  "implements": [],
  "description": "Represents the JSON data for a spritesheet atlas. / export interface SpritesheetFrameData { /** The frame rectangle of the texture. */ frame: { x: number; y: number; w: number; h: number; }; /** Whether the texture is trimmed. */ trimmed?: boolean; /** Whether the texture is rotated. */ rotated?: boolean; /** The source size of the texture. */ sourceSize?: { w: number; h: number; }; /** The sprite source size. */ spriteSourceSize?: { h?: number; w?: number; x: number; y: number; }; /** The anchor point of the texture. */ anchor?: PointData; /** The 9-slice borders of the texture. */ borders?: TextureBorders } /** Atlas format. / export interface SpritesheetData { /** The frames of the atlas. */ frames: Dict<SpritesheetFrameData>; /** The animations of the atlas. */ animations?: Dict<string[]>; /** The meta data of the atlas. */ meta: { app?: string; format?: string; frameTags?: { from: number; name: string; to: number; direction: string; }[]; image?: string; layers?: { blendMode: string; name: string; opacity: number; }[]; scale: number | string; size?: { h: number; w: number; }; slices?: { color: string; name: string; keys: { frame: number, bounds: { x: number; y: number; w: number; h: number; }; }[]; }[]; related_multi_packs?: string[]; version?: string; }; } /** Options for loading a spritesheet from an atlas. / export interface SpritesheetOptions<S extends SpritesheetData = SpritesheetData> { /** Reference to Texture */ texture: BindableTexture; /** JSON data for the atlas. */ data: S; /** The filename to consider when determining the resolution of the spritesheet. */ resolutionFilename?: string; /** Prefix to add to texture names when adding to global TextureCache, using this option can be helpful if you have multiple texture atlases that share texture names and you need to disambiguate them. / cachePrefix?: string; } /** Utility class for maintaining reference to a collection of Textures on a single Spritesheet. To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader: ```js import { Assets } from 'pixi.js'; const sheet = await Assets.load('images/spritesheet.json'); ``` Alternately, you may circumvent the loader by instantiating the Spritesheet directly: ```js import { Spritesheet } from 'pixi.js'; const sheet = new Spritesheet(texture, spritesheetData); await sheet.parse(); console.log('Spritesheet ready to use!'); ``` With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite. Here's an example of a sprite sheet JSON data file: ```json { \"frames\": { \"enemy1.png\": { \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32}, \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32}, \"sourceSize\": {\"w\":32,\"h\":32}, \"anchor\": {\"x\":0.5,\"y\":0.5} }, \"enemy2.png\": { \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32}, \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32}, \"sourceSize\": {\"w\":32,\"h\":32}, \"anchor\": {\"x\":0.5,\"y\":0.5} }, \"button.png\": { \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100}, \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100}, \"sourceSize\": {\"w\":100,\"h\":100}, \"anchor\": {\"x\":0,\"y\":0}, \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35} } }, \"animations\": { \"enemy\": [\"enemy1.png\",\"enemy2.png\"] }, \"meta\": { \"image\": \"sheet.png\", \"format\": \"RGBA8888\", \"size\": {\"w\":136,\"h\":102}, \"scale\": \"1\" } } ``` Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker}, {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}. Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only supported by TexturePacker. Alternative ways for loading spritesheet image if you need more control: ```js import { Assets } from 'pixi.js'; const sheetTexture = await Assets.load('images/spritesheet.png'); Assets.add({ alias: 'atlas', src: 'images/spritesheet.json', data: {texture: sheetTexture} // using of preloaded texture }); const sheet = await Assets.load('atlas') ``` or: ```js import { Assets } from 'pixi.js'; Assets.add({ alias: 'atlas', src: 'images/spritesheet.json', data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\" }); const sheet = await Assets.load('atlas') ```",
  "category": "assets",
  "deprecated": false,
  "methods": [
    {
      "name": "if",
      "params": [
        {
          "name": "(optionsOrTexture as BindableTexture",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "parseFloat",
      "params": [
        {
          "name": "data.meta.scale as string",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "metaResolution",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "keys",
      "params": [
        {
          "name": "this._frames",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "parse",
      "params": [],
      "returnType": "Promise<Record<string, Texture>>",
      "description": "Parser spritesheet from loaded data. This is done asynchronously to prevent creating too many Texture within a single process."
    },
    {
      "name": "Promise",
      "params": [
        {
          "name": "(resolve",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "this._frameKeys.length <= Spritesheet.BATCH_SIZE",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "destroy",
      "params": [
        {
          "name": "destroyBase = false",
          "type": null
        }
      ],
      "returnType": "void",
      "description": "Process a batch of frames / private _processFrames(initialFrameIndex: number): void { let frameIndex = initialFrameIndex; const maxFrames = Spritesheet.BATCH_SIZE; while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) { const i = this._frameKeys[frameIndex]; const data = this._frames[i]; const rect = data.frame; if (rect) { let frame = null; let trim = null; const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame; const orig = new Rectangle( 0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution ); if (data.rotated) { frame = new Rectangle( Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution ); } else { frame = new Rectangle( Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution ); } //  Check to see if the sprite is trimmed if (data.trimmed !== false && data.spriteSourceSize) { trim = new Rectangle( Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution ); } this.textures[i] = new Texture({ source: this.textureSource, frame, orig, trim, rotate: data.rotated ? 2 : 0, defaultAnchor: data.anchor, defaultBorders: data.borders, label: i.toString(), }); } frameIndex++; } } /** Parse animations config. */ private _processAnimations(): void { const animations = this.data.animations || {}; for (const animName in animations) { this.animations[animName as keyof S['animations']] = []; for (let i = 0; i < animations[animName].length; i++) { const frameName = animations[animName][i]; this.animations[animName].push(this.textures[frameName]); } } } /** The parse has completed. */ private _parseComplete(): void { const callback = this._callback; this._callback = null; this._batchIndex = 0; callback.call(this, this.textures); } /** Begin the next batch of textures. */ private _nextBatch(): void { this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE); this._batchIndex++; setTimeout(() => { if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length) { this._nextBatch(); } else { this._processAnimations(); this._parseComplete(); } }, 0); } /** Destroy Spritesheet and don't use after this."
    },
    {
      "name": "for",
      "params": [
        {
          "name": "const i in this.textures",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "destroy",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "destroyBase",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "destroy",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "destroy",
      "params": [],
      "returnType": null,
      "description": null
    }
  ],
  "properties": []
}