{
  "type": "class",
  "name": "Filter",
  "sourcePath": "filters/Filter.ts",
  "extends": "Shader",
  "implements": [],
  "description": "The options to use when creating a new filter. / export interface FilterOptions { /** optional blend mode used by the filter when rendering (defaults to 'normal') */ blendMode?: BLEND_MODES; /** the resolution the filter should be rendered at. The lower the resolution, the more performant the filter will be, but the lower the quality of the output. (default 1) If 'inherit', the resolution of the render target is used. Consider lowering this for things like blurs filters / resolution?: number | 'inherit'; /** the amount of pixels to pad the container with when applying the filter. For example a blur extends the container out as it blurs, so padding is applied to ensure that extra detail is rendered as well without clipping occurring. (default 0) / padding?: number; /** If true the filter will make use of antialiasing. Although it looks better this can have a performance impact. If set to 'inherit', the filter will detect the antialiasing of the render target and change this automatically. Definitely don't set this to true if the render target has antialiasing set to false. As it will antialias, but you won't see the difference. (default 'off') This can be a boolean or [FilterAntialias]{@link FilterAntialias} string. / antialias?: FilterAntialias | boolean; /** If this is set to true, the filter system will grab a snap shot of the area being rendered to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need! (default false) / blendRequired?: boolean; /** If this is set to true, the filter system will clip filter texture into viewport This is useful for filters that applied to whole texture. (default true) / clipToViewport?: boolean; } /** Filter options mixed with shader resources. A filter needs a shader and some resources to work. / export type FilterWithShader = FilterOptions & IShaderWithResources; /** The antialiasing mode of the filter. This can be either: - `on` - the filter is always antialiased regardless of the render target settings - `off` - (default) the filter is never antialiased regardless of the render target settings - `inherit` - the filter uses the antialias settings of the render target / export type FilterAntialias = 'on' | 'off' | 'inherit'; /** The Filter class is the base for all filter effects used in Pixi.js As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU. If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer. A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc. Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene. The following happens under the hood when a filter is applied: .1. Break the current batch <br> .2. The target is measured using getGlobalBounds (recursively go through all children and figure out how big the object is) <br> .3. Get the closest Po2 Textures from the texture pool <br> .4. Render the target to that texture <br> .5. Render that texture back to the main frame buffer as a quad using the filters program. <br> <br> Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful! Its not generally the complexity of the shader that is the bottle neck, but all the framebuffer / shader switching that has to take place. One filter applied to a container with many objects is MUCH faster than many filter applied to many objects. import { Filter } from 'pixi.js'; const customFilter = new Filter({ glProgram: new GlProgram({ fragment, vertex, }), resources: { timeUniforms: { uTime: { value: 0.0, type: 'f32' }, }, }, }); // Apply the filter sprite.filters = [customFilter]; // Update uniform app.ticker.add((ticker) => { filter.resources.timeUniforms.uniforms.uTime += 0.04 * ticker.deltaTime; });",
  "category": "filters",
  "deprecated": false,
  "methods": [
    {
      "name": "super",
      "params": [
        {
          "name": "options as ShaderWithResources",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "typeof options.antialias === 'boolean'",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "addResource",
      "params": [
        {
          "name": "'uTexture'",
          "type": null
        },
        {
          "name": "0",
          "type": null
        },
        {
          "name": "1",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "apply",
      "params": [
        {
          "name": "filterManager",
          "type": "FilterSystem",
          "optional": false,
          "default": null
        },
        {
          "name": "input",
          "type": "Texture",
          "optional": false,
          "default": null
        },
        {
          "name": "output",
          "type": "RenderSurface",
          "optional": false,
          "default": null
        },
        {
          "name": "clearMode",
          "type": "boolean",
          "optional": false,
          "default": null
        }
      ],
      "returnType": "void",
      "description": "Applies the filter"
    },
    {
      "name": "applyFilter",
      "params": [
        {
          "name": "this",
          "type": null
        },
        {
          "name": "input",
          "type": null
        },
        {
          "name": "output",
          "type": null
        },
        {
          "name": "clearMode",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "from",
      "params": [
        {
          "name": "options",
          "type": "FilterOptions & ShaderFromResources",
          "optional": false,
          "default": null
        }
      ],
      "returnType": "Filter",
      "description": "Get the blend mode of the filter. / get blendMode(): BLEND_MODES { return this._state.blendMode; } /** Sets the blend mode of the filter. */ set blendMode(value: BLEND_MODES) { this._state.blendMode = value; } /** A short hand function to create a filter based of a vertex and fragment shader src."
    },
    {
      "name": "if",
      "params": [
        {
          "name": "gpu",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "from",
      "params": [
        {
          "name": "gpu",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "gl",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "from",
      "params": [
        {
          "name": "gl",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "Filter",
      "params": [
        {
          "name": "{\n            gpuProgram",
          "type": null
        },
        {
          "name": "glProgram",
          "type": null
        },
        {
          "name": "...rest\n        }",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    }
  ],
  "properties": [
    {
      "name": "blendMode",
      "type": "BLEND_MODES",
      "description": "Get the blend mode of the filter."
    }
  ]
}