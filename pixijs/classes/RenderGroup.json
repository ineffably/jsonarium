{
  "type": "class",
  "name": "RenderGroup",
  "sourcePath": "scene/container/RenderGroup.ts",
  "extends": null,
  "implements": [
    "Instruction"
  ],
  "description": "Options for caching a container as a texture. / export interface CacheAsTextureOptions { /** If true, the texture will be antialiased. This smooths out the edges of the texture. / antialias?: boolean; /** The resolution of the texture. A higher resolution means a sharper texture but uses more memory. By default the resolution is 1 which is the same as the rendererers resolution. / resolution?: number; /** Scale Mode to use for the cached texture ```ts const container = new Container(); container.cacheAsTexture({ scaleMode: 'nearest' }); ``` / scaleMode?: SCALE_MODE; } /** A RenderGroup is a class that is responsible for I generating a set of instructions that are used to render the root container and its children. It also watches for any changes in that container or its children, these changes are analysed and either the instruction set is rebuild or the instructions data is updated.",
  "category": "rendering",
  "deprecated": false,
  "methods": [
    {
      "name": "Matrix",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "create",
      "params": [
        {
          "name": "null",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "InstructionSet",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "addOnRender",
      "params": [
        {
          "name": "container",
          "type": "Container",
          "optional": false,
          "default": null
        }
      ],
      "returnType": null,
      "description": "Indicates if the cached texture needs to be updated. / public textureNeedsUpdate = true; /** Indicates if the container should be cached as a texture. / public isCachedAsTexture = false; /** The texture used for caching the container. this is only set if isCachedAsTexture is true. It can only be accessed after a render pass. / public texture?: Texture; /** The bounds of the cached texture. / public _textureBounds?: Bounds; /** The options for caching the container as a texture. / public textureOptions: CacheAsTextureOptions; /** holds a reference to the batchable render sprite / public _batchableRenderGroup: BatchableSprite; /** Holds a reference to the closest parent RenderGroup that has isCachedAsTexture enabled. This is used to properly transform coordinates when rendering into cached textures. / public _parentCacheAsTextureRenderGroup: RenderGroup; private _inverseWorldTransform: Matrix; private _textureOffsetInverseTransform: Matrix; private _inverseParentTextureTransform: Matrix; private _matrixDirty = 0b111; public init(root: Container) { this.root = root; if (root._onRender) this.addOnRender(root); root.didChange = true; const children = root.children; for (let i = 0; i < children.length; i++) { const child = children[i]; // make sure the children are all updated on the first pass.. child._updateFlags = 0b1111; this.addChild(child); } } public enableCacheAsTexture(options: CacheAsTextureOptions = {}): void { this.textureOptions = options; this.isCachedAsTexture = true; this.textureNeedsUpdate = true; } public disableCacheAsTexture(): void { this.isCachedAsTexture = false; if (this.texture) { TexturePool.returnTexture(this.texture, true); this.texture = null; } } public updateCacheTexture(): void { this.textureNeedsUpdate = true; const cachedParent = this._parentCacheAsTextureRenderGroup; // It's worth going bottom-up and notify all parents cached as texture // that cached child was updated. if (cachedParent && !cachedParent.textureNeedsUpdate) { cachedParent.updateCacheTexture(); } } public reset() { this.renderGroupChildren.length = 0; for (const i in this.childrenToUpdate) { const childrenAtDepth = this.childrenToUpdate[i]; childrenAtDepth.list.fill(null); childrenAtDepth.index = 0; } this.childrenRenderablesToUpdate.index = 0; this.childrenRenderablesToUpdate.list.fill(null); this.root = null; this.updateTick = 0; this.structureDidChange = true; this._onRenderContainers.length = 0; this.renderGroupParent = null; this.disableCacheAsTexture(); } get localTransform() { return this.root.localTransform; } public addRenderGroupChild(renderGroupChild: RenderGroup) { if (renderGroupChild.renderGroupParent) { renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild); } renderGroupChild.renderGroupParent = this; this.renderGroupChildren.push(renderGroupChild); } private _removeRenderGroupChild(renderGroupChild: RenderGroup) { const index = this.renderGroupChildren.indexOf(renderGroupChild); if (index > -1) { this.renderGroupChildren.splice(index, 1); } renderGroupChild.renderGroupParent = null; } public addChild(child: Container) { this.structureDidChange = true; child.parentRenderGroup = this; child.updateTick = -1; if (child.parent === this.root) { child.relativeRenderGroupDepth = 1; } else { child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1; } child.didChange = true; this.onChildUpdate(child); if (child.renderGroup) { this.addRenderGroupChild(child.renderGroup); return; } if (child._onRender) this.addOnRender(child); const children = child.children; for (let i = 0; i < children.length; i++) { this.addChild(children[i]); } } public removeChild(child: Container) { // remove all the children... this.structureDidChange = true; if (child._onRender) { // Remove the child to the onRender list under the following conditions: // 1. If the child is not a render group. // 2. If the child is a render group root of this render group - which it can't be removed from in this case. if (!child.renderGroup) { this.removeOnRender(child); } } child.parentRenderGroup = null; if (child.renderGroup) { this._removeRenderGroupChild(child.renderGroup); return; } const children = child.children; for (let i = 0; i < children.length; i++) { this.removeChild(children[i]); } } public removeChildren(children: Container[]) { for (let i = 0; i < children.length; i++) { this.removeChild(children[i]); } } public onChildUpdate(child: Container) { let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth]; if (!childrenToUpdate) { childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = { index: 0, list: [], }; } childrenToUpdate.list[childrenToUpdate.index++] = child; } public updateRenderable(renderable: ViewContainer) { if (renderable.globalDisplayStatus < 0b111) return; this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable); renderable.didViewUpdate = false; } public onChildViewUpdate(child: Container) { this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child; } get isRenderable(): boolean { return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0); } /** adding a container to the onRender list will make sure the user function passed in to the user defined 'onRender` callBack"
    },
    {
      "name": "push",
      "params": [
        {
          "name": "container",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "removeOnRender",
      "params": [
        {
          "name": "container",
          "type": "Container",
          "optional": false,
          "default": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "splice",
      "params": [
        {
          "name": "this._onRenderContainers.indexOf(container",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "runOnRender",
      "params": [
        {
          "name": "renderer",
          "type": "Renderer",
          "optional": false,
          "default": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "for",
      "params": [
        {
          "name": "let i = 0; i < this._onRenderContainers.length; i++",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "destroy",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "disableCacheAsTexture",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "getChildren",
      "params": [
        {
          "name": "out",
          "type": "Container[]",
          "optional": true,
          "default": "[]"
        }
      ],
      "returnType": "Container[]",
      "description": null
    },
    {
      "name": "for",
      "params": [
        {
          "name": "let i = 0; i < children.length; i++",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "push",
      "params": [
        {
          "name": "container",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "container.renderGroup",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "for",
      "params": [
        {
          "name": "let i = 0; i < children.length; i++",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "invalidateMatrices",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "(this._matrixDirty & 0b001",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "Matrix",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "copyFrom",
      "params": [
        {
          "name": "this.worldTransform",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "invert",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "(this._matrixDirty & 0b010",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "Matrix",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "copyFrom",
      "params": [
        {
          "name": "this.inverseWorldTransform",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "translate",
      "params": [
        {
          "name": "-this._textureBounds.x",
          "type": null
        },
        {
          "name": "-this._textureBounds.y",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "(this._matrixDirty & 0b100",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "parentCacheAsTexture",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "Matrix",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "copyFrom",
      "params": [
        {
          "name": "this.worldTransform",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "prepend",
      "params": [
        {
          "name": "parentCacheAsTexture.inverseWorldTransform",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "translate",
      "params": [
        {
          "name": "-parentCacheAsTexture._textureBounds.x",
          "type": null
        },
        {
          "name": "-parentCacheAsTexture._textureBounds.y",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    }
  ],
  "properties": []
}