{
  "type": "class",
  "name": "RopeGeometry",
  "sourcePath": "scene/mesh-simple/RopeGeometry.ts",
  "extends": "MeshGeometry",
  "implements": [],
  "description": "Constructor options used for `RopeGeometry` instances. ```js const ropeGeometry = new RopeGeometry({ points: [new Point(0, 0), new Point(100, 0)], width: 10, textureScale: 0, }); ``` / export interface RopeGeometryOptions { /** The width (i.e., thickness) of the rope. */ width?: number; /** An array of points that determine the rope. */ points?: PointData[]; /** Rope texture scale, if zero then the rope texture is stretched. By default the rope texture will be stretched to match rope length. If textureScale is positive this value will be treated as a scaling factor and the texture will preserve its aspect ratio instead. To create a tiling rope set baseTexture.wrapMode to 'repeat' and use a power of two texture, then set textureScale=1 to keep the original texture pixel size. In order to reduce alpha channel artifacts provide a larger texture and downsample - i.e. set textureScale=0.5 to scale it down twice. / textureScale?: number; } /** RopeGeometry allows you to draw a geometry across several points and then manipulate these points. import { Point, RopeGeometry } from 'pixi.js'; for (let i = 0; i < 20; i++) { points.push(new Point(i * 50, 0)); }; const rope = new RopeGeometry(100, points);",
  "category": "scene",
  "deprecated": false,
  "methods": [
    {
      "name": "super",
      "params": [
        {
          "name": "positions",
          "type": "new Float32Array(points.length * 4",
          "optional": false,
          "default": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "Float32Array",
      "params": [
        {
          "name": "points.length * 4",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "Uint32Array",
      "params": [
        {
          "name": "(points.length - 1",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "updateVertices",
      "params": [],
      "returnType": "void",
      "description": "The width (i.e., thickness) of the rope. / get width(): number { return this._width; } /** Refreshes Rope indices and uvs */ private _build(): void { const points = this.points; if (!points) return; const vertexBuffer = this.getBuffer('aPosition'); const uvBuffer = this.getBuffer('aUV'); const indexBuffer = this.getIndex(); // if too little points, or texture hasn't got UVs set yet just move on. if (points.length < 1) { return; } // if the number of points has changed we will need to recreate the arraybuffers if (vertexBuffer.data.length / 4 !== points.length) { vertexBuffer.data = new Float32Array(points.length * 4); uvBuffer.data = new Float32Array(points.length * 4); indexBuffer.data = new Uint16Array((points.length - 1) * 6); } const uvs = uvBuffer.data; const indices = indexBuffer.data; uvs[0] = 0; uvs[1] = 0; uvs[2] = 0; uvs[3] = 1; let amount = 0; let prev = points[0]; const textureWidth = this._width * this.textureScale; const total = points.length; // - 1; for (let i = 0; i < total; i++) { // time to do some smart drawing! const index = i * 4; if (this.textureScale > 0) { // calculate pixel distance from previous point const dx = prev.x - points[i].x; const dy = prev.y - points[i].y; const distance = Math.sqrt((dx * dx) + (dy * dy)); prev = points[i]; amount += distance / textureWidth; } else { // stretch texture amount = i / (total - 1); } uvs[index] = amount; uvs[index + 1] = 0; uvs[index + 2] = amount; uvs[index + 3] = 1; } let indexCount = 0; for (let i = 0; i < total - 1; i++) { const index = i * 2; indices[indexCount++] = index; indices[indexCount++] = index + 1; indices[indexCount++] = index + 2; indices[indexCount++] = index + 2; indices[indexCount++] = index + 1; indices[indexCount++] = index + 3; } // ensure that the changes are uploaded uvBuffer.update(); indexBuffer.update(); this.updateVertices(); } /** refreshes vertices of Rope mesh"
    },
    {
      "name": "if",
      "params": [
        {
          "name": "points.length < 1",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "for",
      "params": [
        {
          "name": "let i = 0; i < total; i++",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "i < points.length - 1",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "ratio > 1",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "sqrt",
      "params": [
        {
          "name": "(perpX * perpX",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "if",
      "params": [
        {
          "name": "perpLength < 1e-6",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "update",
      "params": [],
      "returnType": null,
      "description": null
    },
    {
      "name": "update",
      "params": [],
      "returnType": "void",
      "description": "Refreshes Rope indices and uvs"
    },
    {
      "name": "if",
      "params": [
        {
          "name": "this.textureScale > 0",
          "type": null
        }
      ],
      "returnType": null,
      "description": null
    },
    {
      "name": "updateVertices",
      "params": [],
      "returnType": null,
      "description": null
    }
  ],
  "properties": [
    {
      "name": "width",
      "type": "number",
      "description": "The width (i.e., thickness) of the rope."
    }
  ]
}