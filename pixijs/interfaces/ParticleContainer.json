{
  "type": "interface",
  "name": "ParticleContainer",
  "sourcePath": "scene/particle-container/shared/ParticleContainer.ts",
  "extends": [
    "PixiMixins"
  ],
  "description": null,
  "category": null,
  "deprecated": false,
  "properties": [
    {
      "name": "dynamicProperties",
      "type": "{\n            /** Indicates if vertex positions are dynamic. */\n            vertex: false,\n            /** Indicates if particle positions are dynamic. */\n            position: true,\n            /** Indicates if particle rotations are dynamic. */\n            rotation: false,\n            /** Indicates if UV coordinates are dynamic. */\n            uvs: false,\n            /** Indicates if particle colors are dynamic. */\n            color: false,\n        },\n        /** Indicates if pixels should be rounded for rendering. */\n        roundPixels: false\n    }",
      "optional": false,
      "description": "The ParticleContainer class is a highly optimized container that can render 1000s or particles at great speed. A ParticleContainer is specialized in that it can only contain and render particles. Particles are lightweight objects that use minimal memory, which helps boost performance. It can render particles EXTREMELY fast! The tradeoff of using a ParticleContainer is that most advanced functionality is unavailable. Particles are simple and cannot have children, filters, masks, etc. They possess only the basic properties: position, scale, rotation, and color. All particles must share the same texture source (using something like a sprite sheet works well here). When creating a ParticleContainer, a developer can specify which of these properties are static and which are dynamic. - Static properties are only updated when you add or remove a child, or when the `update` function is called. - Dynamic properties are updated every frame. It is up to the developer to specify which properties are static and which are dynamic. Generally, the more static properties you have (i.e., those that do not change per frame), the faster the rendering. If the developer modifies the children order or any static properties of the particle, they must call the `update` method. By default, only the `position` property is set to dynamic, which makes rendering very fast! Developers can also provide a custom shader to the particle container, allowing them to render particles in a custom way. To help with performance, the particle containers bounds are not calculated. It's up to the developer to set the boundsArea property. It's extremely easy to use. Below is an example of rendering thousands of sprites at lightning speed. --------- EXPERIMENTAL --------- This is a new API, things may change and it may not work as expected. We want to hear your feedback as we go! -------------------------------- ```ts import { ParticleContainer, Particle } from 'pixi.js'; const container = new ParticleContainer(); for (let i = 0; i < 100; ++i) { let particle = new Particle(texture); container.addParticle(particle); } ``` / export class ParticleContainer extends ViewContainer<ParticleBuffer> implements Instruction { /** Defines the default options for creating a ParticleContainer. ```ts // Change defaults globally ParticleContainer.defaultOptions = { dynamicProperties: { position: true,  // Update positions each frame rotation: true,  // Update rotations each frame vertex: false,   // Static vertices uvs: false,      // Static texture coordinates color: false     // Static colors }, roundPixels: true // Enable pixel rounding for crisp rendering }; ``` / public static defaultOptions: ParticleContainerOptions = { /** Specifies which properties are dynamic."
    },
    {
      "name": "renderPipeId",
      "type": "string = 'particle'",
      "optional": false,
      "description": null
    },
    {
      "name": "_properties",
      "type": "Record<string, ParticleRendererProperty>",
      "optional": false,
      "description": null
    },
    {
      "name": "particleChildren",
      "type": "IParticle[]",
      "optional": false,
      "description": null
    },
    {
      "name": "shader",
      "type": "Shader",
      "optional": false,
      "description": null
    },
    {
      "name": "texture",
      "type": "Texture",
      "optional": false,
      "description": null
    },
    {
      "name": "options",
      "type": "ParticleContainerOptions = {})\n    {\n        options = {\n            ...ParticleContainer.defaultOptions,\n            ...options,\n            dynamicProperties: {\n                ...ParticleContainer.defaultOptions.dynamicProperties,\n                ...options?.dynamicProperties,\n            },\n        }",
      "optional": false,
      "description": null
    },
    {
      "name": "label",
      "type": "'ParticleContainer',\n            ...rest,\n        })",
      "optional": false,
      "description": null
    },
    {
      "name": "children",
      "type": "IParticle[]): IParticle\n    {\n        for (let i = 0",
      "optional": false,
      "description": null
    },
    {
      "name": "children",
      "type": "IParticle[]): IParticle\n    {\n        let didRemove = false",
      "optional": false,
      "description": null
    },
    {
      "name": "texture",
      "type": "Texture.from('particle.png')\n     * })",
      "optional": false,
      "description": null
    },
    {
      "name": "minX",
      "type": "0,\n     *     minY: 0,\n     *     maxX: 800,\n     *     maxY: 600\n     * }",
      "optional": false,
      "description": null
    },
    {
      "name": "texture",
      "type": "true, textureSource: true, children: true })",
      "optional": false,
      "description": null
    },
    {
      "name": "options",
      "type": "DestroyOptions = false)\n    {\n        super.destroy(options)",
      "optional": false,
      "description": null
    },
    {
      "name": "beginIndex",
      "type": "number, endIndex?: number)\n    {\n        beginIndex ??= 0",
      "optional": true,
      "description": null
    },
    {
      "name": "index",
      "type": "number): U\n    {\n        const child = this.particleChildren.splice(index, 1)",
      "optional": false,
      "description": null
    },
    {
      "name": "child",
      "type": "U, index: number): U\n    {\n        this.particleChildren.splice(index, 0, child)",
      "optional": false,
      "description": null
    },
    {
      "name": "_children",
      "type": "U): U[0]\n    {\n        throw new Error(\n            'ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()',\n        )",
      "optional": false,
      "description": null
    },
    {
      "name": "_children",
      "type": "U): U[0]\n    {\n        throw new Error(\n            'ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()',\n        )",
      "optional": false,
      "description": null
    },
    {
      "name": "_beginIndex",
      "type": "number, _endIndex?: number): ContainerChild[]\n    {\n        throw new Error(\n            'ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()',\n        )",
      "optional": true,
      "description": null
    },
    {
      "name": "_index",
      "type": "number): U\n    {\n        throw new Error(\n            'ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()',\n        )",
      "optional": false,
      "description": null
    },
    {
      "name": "_index",
      "type": "number): U\n    {\n        throw new Error(\n            'ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()',\n        )",
      "optional": false,
      "description": null
    },
    {
      "name": "_child",
      "type": "ContainerChild, _index: number): void\n    {\n        throw new Error(\n            'ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()',\n        )",
      "optional": false,
      "description": null
    },
    {
      "name": "_child",
      "type": "ContainerChild): number\n    {\n        throw new Error(\n            'ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()',\n        )",
      "optional": false,
      "description": null
    },
    {
      "name": "_child",
      "type": "U, _index: number): U\n    {\n        throw new Error(\n            'ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()',\n        )",
      "optional": false,
      "description": null
    },
    {
      "name": "_child",
      "type": "U, _child2: U): void\n    {\n        throw new Error(\n            'ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()',\n        )",
      "optional": false,
      "description": null
    },
    {
      "name": "_child",
      "type": "ContainerChild[]): any\n    {\n        throw new Error('ParticleContainer.reparentChild() is not available with the particle container')",
      "optional": false,
      "description": null
    },
    {
      "name": "_child",
      "type": "ContainerChild, _index: number): any\n    {\n        throw new Error('ParticleContainer.reparentChildAt() is not available with the particle container')",
      "optional": false,
      "description": null
    }
  ]
}