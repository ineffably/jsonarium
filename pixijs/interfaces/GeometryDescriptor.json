{
  "type": "interface",
  "name": "GeometryDescriptor",
  "sourcePath": "rendering/renderers/shared/geometry/Geometry.ts",
  "extends": [],
  "description": "the buffer that this attributes data belongs to */ buffer: Buffer; /** the format of the attribute */ format?: VertexFormat; /** the stride of the data in the buffer - in bytes*/ stride?: number; /** the offset of the attribute from the buffer, defaults to 0 - in bytes*/ offset?: number; /** is this an instanced buffer? (defaults to false) */ instance?: boolean; /** the number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */ size?: number; /** the starting vertex in the geometry to start drawing from. If not specified, drawing will start from the first vertex. / start?: number; /** attribute divisor for instanced rendering. Note: this is a **WebGL-only** feature, the WebGPU renderer will issue a warning if one of the attributes has divisor set. / divisor?: number; } /** The attribute option used by the constructor for adding geometries attributes extends {@link Attribute} but allows for the buffer to be a typed or number array / export type AttributeOption = Omit<Attribute, 'buffer'> & { buffer: Buffer | TypedArray | number[]} | Buffer | TypedArray | number[]; /** The attribute options used by the constructor for adding geometries attributes extends {@link Attribute} but allows for the buffer to be a typed or number array / export type AttributeOptions = Record<string, AttributeOption>; /** the interface that describes the structure of the geometry",
  "category": "rendering",
  "deprecated": false,
  "properties": [
    {
      "name": "label",
      "type": "string",
      "optional": true,
      "description": "an optional label to easily identify the geometry"
    },
    {
      "name": "attributes",
      "type": "AttributeOptions",
      "optional": true,
      "description": "the attributes that make up the geometry"
    },
    {
      "name": "indexBuffer",
      "type": "Buffer | TypedArray | number[]",
      "optional": true,
      "description": "optional index buffer for this geometry"
    },
    {
      "name": "topology",
      "type": "Topology",
      "optional": true,
      "description": "the topology of the geometry, defaults to 'triangle-list'"
    },
    {
      "name": "instanceCount",
      "type": "number",
      "optional": true,
      "description": null
    },
    {
      "name": "attribute",
      "type": "AttributeOption): Attribute\n{\n    if (attribute instanceof Buffer || Array.isArray(attribute) || (attribute as TypedArray).BYTES_PER_ELEMENT)\n    {\n        attribute = {\n            buffer: attribute as Buffer | TypedArray | number[],\n        }",
      "optional": false,
      "description": null
    },
    {
      "name": "components",
      "type": "* <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * })",
      "optional": false,
      "description": null
    },
    {
      "name": "update",
      "type": "Geometry,\n    destroy: Geometry,\n}>\n{\n    /** The topology of the geometry. */\n    public topology: Topology",
      "optional": false,
      "description": null
    },
    {
      "name": "uid",
      "type": "number = uid('geometry')",
      "optional": false,
      "description": null
    },
    {
      "name": "attributes",
      "type": "Record<string, Attribute>",
      "optional": false,
      "description": null
    },
    {
      "name": "buffers",
      "type": "Buffer[]",
      "optional": false,
      "description": null
    },
    {
      "name": "indexBuffer",
      "type": "Buffer",
      "optional": false,
      "description": null
    },
    {
      "name": "_bounds",
      "type": "Bounds = new Bounds()",
      "optional": false,
      "description": null
    },
    {
      "name": "options",
      "type": "GeometryDescriptor = {})\n    {\n        super()",
      "optional": false,
      "description": null
    },
    {
      "name": "id",
      "type": "string): Attribute\n    {\n        return this.attributes[id]",
      "optional": false,
      "description": null
    },
    {
      "name": "id",
      "type": "string): Buffer\n    {\n        return this.getAttribute(id).buffer",
      "optional": false,
      "description": null
    },
    {
      "name": "name",
      "type": "string, attributeOption: AttributeOption): void\n    {\n        const attribute = ensureIsAttribute(attributeOption)",
      "optional": false,
      "description": null
    },
    {
      "name": "indexBuffer",
      "type": "Buffer | TypedArray | number[]): void\n    {\n        this.indexBuffer = ensureIsBuffer(indexBuffer, true)",
      "optional": false,
      "description": null
    }
  ]
}