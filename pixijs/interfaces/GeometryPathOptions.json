{
  "type": "interface",
  "name": "GeometryPathOptions",
  "sourcePath": "scene/graphics/shared/utils/buildGeometryFromPath.ts",
  "extends": [],
  "description": "Options for building geometry from a graphics path. Provides a possibility to specify a transformation Matrix for the texture's UVs and output mesh geometry. ```ts const options: GeometryPathOptions = { path: new GraphicsPath().rect(0, 0, 64, 64), textureMatrix: new Matrix() .scale(2, 2) .rotate(Math.PI / 4), out: meshGeometry }; const geometry:MeshGeometry = buildGeometryFromPath(options); const mesh = new Mesh({ geometry: meshGeometry, texture: bunnyTexture }); ```",
  "category": "scene",
  "deprecated": false,
  "properties": [
    {
      "name": "path",
      "type": "GraphicsPath\n    /** a `Matrix` that can be used to modify the texture UVs of the path being built */\n    textureMatrix?: Matrix\n    /** an optional `MeshGeometry` to write too instead of creating a new one*/\n    out?: MeshGeometry\n}\n\n/**\n * When building a mesh, it helps to leverage the simple API we have in `GraphicsPath` as it can often be easier to\n * define the geometry in a more human-readable way. This function takes a `GraphicsPath` and returns a `MeshGeometry`.\n * @example\n * ```ts\n *\n * const path = new GraphicsPath()\n *    .drawRect(0, 0, 100, 100)\n *\n * const geometry:MeshGeometry = buildGeometryFromPath(path)",
      "optional": false,
      "description": "the path to build the geometry from"
    },
    {
      "name": "options",
      "type": "GraphicsPath | GeometryPathOptions): MeshGeometry\n{\n    if (options instanceof GraphicsPath)\n    {\n        options = {\n            path: options,\n            textureMatrix: null,\n            out: null,\n        }",
      "optional": false,
      "description": null
    },
    {
      "name": "vertices",
      "type": "number[] = []",
      "optional": false,
      "description": null
    },
    {
      "name": "uvs",
      "type": "number[] = []",
      "optional": false,
      "description": null
    },
    {
      "name": "indices",
      "type": "number[] = []",
      "optional": false,
      "description": null
    },
    {
      "name": "transform",
      "type": "matrix }) =>\n    {\n        const indexOffset = indices.length",
      "optional": false,
      "description": null
    },
    {
      "name": "points",
      "type": "number[] = []",
      "optional": false,
      "description": null
    },
    {
      "name": "positions",
      "type": "new Float32Array(vertices),\n        uvs: new Float32Array(uvs),\n        indices: new Uint32Array(indices),\n    })",
      "optional": false,
      "description": null
    }
  ]
}