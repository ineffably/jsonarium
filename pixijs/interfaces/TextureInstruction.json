{
  "type": "interface",
  "name": "TextureInstruction",
  "sourcePath": "scene/graphics/shared/GraphicsContext.ts",
  "extends": [],
  "description": null,
  "category": null,
  "deprecated": false,
  "properties": [
    {
      "name": "action",
      "type": "'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\n/** @internal */\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction",
      "optional": false,
      "description": null
    },
    {
      "name": "color",
      "type": "0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n        /** Whether coordinates are 'global' or 'local' */\n        textureSpace: 'local',\n    }",
      "optional": false,
      "description": "The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths. It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects, This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused, much like sprites reusing textures. / export class GraphicsContext extends EventEmitter<{ update: GraphicsContext destroy: GraphicsContext }> { /** The default fill style to use when none is provided. */ public static defaultFillStyle: ConvertedFillStyle = { /** The color to use for the fill."
    },
    {
      "name": "width",
      "type": "1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n        /** Whether coordinates are 'global' or 'local' */\n        textureSpace: 'local',\n        /** If the stroke is a pixel line. */\n        pixelLine: false,\n    }",
      "optional": false,
      "description": "The default stroke style to use when none is provided. */ public static defaultStrokeStyle: ConvertedStrokeStyle = { /** The width of the stroke."
    },
    {
      "name": "uid",
      "type": "number = uid('graphicsContext')",
      "optional": false,
      "description": null
    },
    {
      "name": "batchMode",
      "type": "BatchMode = 'auto'",
      "optional": false,
      "description": null
    },
    {
      "name": "instructions",
      "type": "GraphicsInstructions[] = []",
      "optional": false,
      "description": null
    },
    {
      "name": "customShader",
      "type": "Shader",
      "optional": true,
      "description": null
    },
    {
      "name": "_activePath",
      "type": "GraphicsPath = new GraphicsPath()",
      "optional": false,
      "description": null
    },
    {
      "name": "_transform",
      "type": "Matrix = new Matrix()",
      "optional": false,
      "description": null
    },
    {
      "name": "_fillStyle",
      "type": "ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle }",
      "optional": false,
      "description": null
    },
    {
      "name": "_strokeStyle",
      "type": "ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle }",
      "optional": false,
      "description": null
    },
    {
      "name": "_stateStack",
      "type": "{ fillStyle: ConvertedFillStyle",
      "optional": false,
      "description": null
    },
    {
      "name": "strokeStyle",
      "type": "ConvertedStrokeStyle, transform: Matrix }[] = []",
      "optional": false,
      "description": null
    },
    {
      "name": "value",
      "type": "FillInput)\n    {\n        this._fillStyle = toFillStyle(value, GraphicsContext.defaultFillStyle)",
      "optional": false,
      "description": null
    },
    {
      "name": "value",
      "type": "FillInput)\n    {\n        this._strokeStyle = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle)",
      "optional": false,
      "description": null
    },
    {
      "name": "style",
      "type": "FillInput): this\n    {\n        this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle)",
      "optional": false,
      "description": null
    },
    {
      "name": "style",
      "type": "StrokeInput): this\n    {\n        this._strokeStyle = toFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle",
      "optional": false,
      "description": null
    },
    {
      "name": "texture",
      "type": "Texture): this",
      "optional": false,
      "description": null
    },
    {
      "name": "texture",
      "type": "Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this",
      "optional": false,
      "description": null
    },
    {
      "name": "texture",
      "type": "Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        })",
      "optional": false,
      "description": null
    },
    {
      "name": "style",
      "type": "FillInput): this",
      "optional": true,
      "description": null
    },
    {
      "name": "color",
      "type": "ColorSource, alpha: number): this",
      "optional": false,
      "description": null
    },
    {
      "name": "style",
      "type": "FillInput, alpha?: number): this\n    {\n        let path: GraphicsPath",
      "optional": true,
      "description": null
    },
    {
      "name": "color",
      "type": "style, alpha }",
      "optional": false,
      "description": null
    },
    {
      "name": "action",
      "type": "'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        })",
      "optional": false,
      "description": null
    },
    {
      "name": "style",
      "type": "StrokeInput): this\n    {\n        let path: GraphicsPath",
      "optional": true,
      "description": null
    },
    {
      "name": "action",
      "type": "'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        })",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "x1",
      "type": "number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "rx",
      "type": "number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "points",
      "type": "the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number, radius: number): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "path",
      "type": "GraphicsPath): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "points",
      "type": "the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number, w: number, h: number): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "points",
      "type": "number[] | PointData[], close?: boolean): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "points",
      "type": "RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "svg",
      "type": "string): this\n    {\n        this._tick++",
      "optional": false,
      "description": null
    },
    {
      "name": "transform",
      "type": "this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        })",
      "optional": false,
      "description": null
    },
    {
      "name": "angle",
      "type": "number): this\n    {\n        this._transform.rotate(angle)",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number = x): this\n    {\n        this._transform.scale(x, y)",
      "optional": false,
      "description": null
    },
    {
      "name": "transform",
      "type": "Matrix): this",
      "optional": false,
      "description": null
    },
    {
      "name": "a",
      "type": "number, b: number, c: number, d: number, dx: number, dy: number): this",
      "optional": false,
      "description": null
    },
    {
      "name": "a",
      "type": "number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty)",
      "optional": false,
      "description": null
    },
    {
      "name": "transform",
      "type": "Matrix): this",
      "optional": false,
      "description": null
    },
    {
      "name": "a",
      "type": "number, b: number, c: number, d: number, dx: number, dy: number): this",
      "optional": false,
      "description": null
    },
    {
      "name": "a",
      "type": "number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a)",
      "optional": false,
      "description": null
    },
    {
      "name": "x",
      "type": "number, y: number = x): this\n    {\n        this._transform.translate(x, y)",
      "optional": false,
      "description": null
    },
    {
      "name": "point",
      "type": "PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false",
      "optional": false,
      "description": null
    },
    {
      "name": "texture",
      "type": "true, textureSource: true })",
      "optional": false,
      "description": null
    },
    {
      "name": "options",
      "type": "TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        this._stateStack.length = 0",
      "optional": false,
      "description": null
    }
  ]
}