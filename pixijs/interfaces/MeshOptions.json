{
  "type": "interface",
  "name": "MeshOptions",
  "sourcePath": "scene/mesh/shared/Mesh.ts",
  "extends": [],
  "description": "The texture that the shader uses. */ texture: Texture; } /** Constructor options used for `Mesh` instances. Extends {@link MeshViewOptions} ```js const mesh = new Mesh({ texture: Texture.from('assets/image.png'), geometry: new PlaneGeometry(), shader: Shader.from(VERTEX, FRAGMENT), }); ``` / /** Options for creating a Mesh instance.",
  "category": "scene",
  "deprecated": false,
  "properties": [
    {
      "name": "geometry",
      "type": "GEOMETRY",
      "optional": false,
      "description": "Includes vertex positions, face indices, colors, UVs, and custom attributes within buffers, reducing the cost of passing all this data to the GPU. Can be shared between multiple Mesh objects."
    },
    {
      "name": "shader",
      "type": "SHADER | null",
      "optional": true,
      "description": "Represents the vertex and fragment shaders that processes the geometry and runs on the GPU. Can be shared between multiple Mesh objects."
    },
    {
      "name": "state",
      "type": "State",
      "optional": true,
      "description": "The state of WebGL required to render the mesh."
    },
    {
      "name": "texture",
      "type": "Texture",
      "optional": true,
      "description": "The texture that the Mesh uses. Null for non-MeshMaterial shaders"
    },
    {
      "name": "roundPixels",
      "type": "boolean",
      "optional": true,
      "description": "Whether or not to round the x/y position."
    },
    {
      "name": "following",
      "type": "* - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @category scene\n * @advanced\n */\nexport class Mesh<\n    GEOMETRY extends Geometry = MeshGeometry,\n    SHADER extends Shader = TextureShader\n> extends ViewContainer<MeshGpuData> implements View, Instruction\n{\n    /** @internal */\n    public override readonly renderPipeId: string = 'mesh'",
      "optional": false,
      "description": null
    },
    {
      "name": "state",
      "type": "State",
      "optional": false,
      "description": null
    },
    {
      "name": "_texture",
      "type": "Texture",
      "optional": false,
      "description": null
    },
    {
      "name": "_geometry",
      "type": "GEOMETRY",
      "optional": false,
      "description": null
    },
    {
      "name": "_shader",
      "type": "SHADER | null = null",
      "optional": false,
      "description": null
    },
    {
      "name": "options",
      "type": "MeshOptions<GEOMETRY, SHADER>)",
      "optional": false,
      "description": null
    },
    {
      "name": "geometry",
      "type": "GEOMETRY, shader: SHADER, state?: State, drawMode?: Topology)",
      "optional": false,
      "description": null
    },
    {
      "name": "args",
      "type": "[MeshOptions<GEOMETRY, SHADER>] | [GEOMETRY, SHADER, State?, Topology?])\n    {\n        let options = args[0]",
      "optional": false,
      "description": null
    },
    {
      "name": "Mesh",
      "type": "use new Mesh({ geometry, shader }) instead')",
      "optional": false,
      "description": null
    },
    {
      "name": "geometry",
      "type": "options,\n                shader: args[1],\n            } as MeshOptions<GEOMETRY, SHADER>",
      "optional": false,
      "description": null
    },
    {
      "name": "Mesh",
      "type": "drawMode argument has been removed, use geometry.topology instead')",
      "optional": false,
      "description": null
    },
    {
      "name": "label",
      "type": "'Mesh',\n            ...rest\n        })",
      "optional": false,
      "description": null
    },
    {
      "name": "value",
      "type": "SHADER | null)\n    {\n        if (this._shader === value) return",
      "optional": false,
      "description": null
    },
    {
      "name": "value",
      "type": "GEOMETRY)\n    {\n        if (this._geometry === value) return",
      "optional": false,
      "description": null
    },
    {
      "name": "value",
      "type": "Texture)\n    {\n        value ||= Texture.EMPTY",
      "optional": false,
      "description": null
    },
    {
      "name": "point",
      "type": "PointData)\n    {\n        const { x, y } = point",
      "optional": false,
      "description": null
    },
    {
      "name": "texture",
      "type": "true, textureSource: true })",
      "optional": false,
      "description": null
    },
    {
      "name": "options",
      "type": "DestroyOptions): void\n    {\n        super.destroy(options)",
      "optional": true,
      "description": null
    }
  ]
}