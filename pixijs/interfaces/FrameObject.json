{
  "type": "interface",
  "name": "FrameObject",
  "sourcePath": "scene/sprite-animated/AnimatedSprite.ts",
  "extends": [],
  "description": "The speed that the AnimatedSprite will play at. Higher is faster, lower is slower. ```ts // Create an AnimatedSprite with a slower animation speed const animation = new AnimatedSprite({ textures: [Texture.from('frame1.png'), Texture.from('frame2.png')], animationSpeed: 0.5 // Slower animation }); // Update the animation speed to make it faster animation.animationSpeed = 2; // Faster animation ``` / animationSpeed?: number; /** Whether to start the animation immediately on creation. If set to `true`, the animation will start playing as soon as the `AnimatedSprite` is created. If set to `false`, you will need to call the `play` method to start the animation. ```ts // Create an AnimatedSprite that starts playing immediately const animation = new AnimatedSprite({ textures: [Texture.from('frame1.png'), Texture.from('frame2.png')], autoPlay: true }); // Create an AnimatedSprite that does not start playing immediately const animation = new AnimatedSprite({ textures: [Texture.from('frame1.png'), Texture.from('frame2.png')], autoPlay: false }); animation.play(); // Start the animation manually ``` / autoPlay?: boolean; /** Whether to use Ticker.shared to auto update animation time. This is useful for animations that need to be updated every frame. If set to `false`, you will need to manually call the `update` method to update the animation. ```ts // Create an AnimatedSprite that does not auto update const animation = new AnimatedSprite({ textures: [Texture.from('frame1.png'), Texture.from('frame2.png')], autoUpdate: false }); // Manually update the animation in your game loop ticker.add((ticker) => { animation.update(ticker); } ``` / autoUpdate?: boolean; /** Whether or not the animation repeats after playing. / loop?: boolean; /** User-assigned function to call when an AnimatedSprite finishes playing. ```ts animation.onComplete = () => { // Finished! console.log('Animation complete'); }; ``` / onComplete?: () => void; /** User-assigned function to call when an AnimatedSprite changes which texture is being rendered. ```ts animation.onFrameChange = (currentFrame) => { // Updated! console.log('Current frame:', currentFrame); }; ``` / onFrameChange?: (currentFrame: number) => void; /** User-assigned function to call when `loop` is true, and an AnimatedSprite is played and loops around to start again. ```ts animation.onLoop = () => { // Looped! }; ``` / onLoop?: () => void; /** An array of {@link Texture} or frame objects that make up the animation. ```ts // Create an AnimatedSprite with an array of textures const animation = new AnimatedSprite({ textures: [ Texture.from('frame1.png'), Texture.from('frame2.png'), Texture.from('frame3.png') ] }); * // Create an AnimatedSprite with an array of frame objects const animation = new AnimatedSprite({ textures: [ { texture: Texture.from('frame1.png'), time: 100 }, { texture: Texture.from('frame2.png'), time: 200 }, { texture: Texture.from('frame3.png'), time: 300 } ] }); ``` / textures: AnimatedSpriteFrames; /** Update anchor to [Texture's defaultAnchor]{@link Texture#defaultAnchor} when frame changes. Useful with [sprite sheet animations]{@link Spritesheet#animations} created with tools. Changing anchor for each frame allows to pin sprite origin to certain moving feature of the frame (e.g. left foot). > [!NOTE] Enabling this will override any previously set `anchor` on each frame change. ```ts // Create an AnimatedSprite with updateAnchor enabled const animation = new AnimatedSprite({ textures: [Texture.from('frame1.png'), Texture.from('frame2.png')], updateAnchor: true }); ``` / updateAnchor?: boolean; } // eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc export interface AnimatedSprite extends PixiMixins.AnimatedSprite, Sprite {} /** An AnimatedSprite is a simple way to display an animation depicted by a list of textures. ```js import { AnimatedSprite, Texture } from 'pixi.js'; const alienImages = [ 'image_sequence_01.png', 'image_sequence_02.png', 'image_sequence_03.png', 'image_sequence_04.png', ]; const textureArray = []; for (let i = 0; i < 4; i++) { const texture = Texture.from(alienImages[i]); textureArray.push(texture); } const animatedSprite = new AnimatedSprite(textureArray); ``` The more efficient and simpler way to create an animated sprite is using a {@link Spritesheet} containing the animation definitions: ```js import { AnimatedSprite, Assets } from 'pixi.js'; const sheet = await Assets.load('assets/spritesheet.json'); animatedSprite = new AnimatedSprite(sheet.animations['image_sequence']); ``` / export class AnimatedSprite extends Sprite { /** The speed that the AnimatedSprite will play at. Higher is faster, lower is slower. ```ts // Create a sprite with normal speed animation const sprite = new AnimatedSprite({ textures: [ Texture.from('walk1.png'), Texture.from('walk2.png'), Texture.from('walk3.png') ], animationSpeed: 1 // Default speed }); // Slow down the animation sprite.animationSpeed = 0.5; // Speed up the animation sprite.animationSpeed = 2; // Reverse the animation sprite.animationSpeed = -1; // Stop the animation sprite.animationSpeed = 0; ``` / public animationSpeed: number; /** Whether or not the animation repeats after playing. When true, the animation will restart from the beginning after reaching the last frame. When false, the animation will stop on the last frame. ```ts // Create a looping animation const sprite = new AnimatedSprite({ textures: [ Texture.from('walk1.png'), Texture.from('walk2.png'), Texture.from('walk3.png') ], loop: true // Will repeat }); // Play animation once sprite.loop = false; sprite.onComplete = () => console.log('Animation finished!'); sprite.play(); // Toggle looping at runtime sprite.loop = !sprite.loop; ``` / public loop: boolean; /** Update anchor to [Texture's defaultAnchor]{@link Texture#defaultAnchor} when frame changes. Useful with [sprite sheet animations]{@link Spritesheet#animations} created with tools. Changing anchor for each frame allows to pin sprite origin to certain moving feature of the frame (e.g. left foot). > [!NOTE] Enabling this will override any previously set `anchor` on each frame change. / public updateAnchor: boolean; /** User-assigned function to call when an AnimatedSprite finishes playing. This function is called when the animation reaches the end and stops playing. If the animation is set to loop, this function will not be called. ```ts animation.onComplete = () => { // Finished! }; ``` / public onComplete?: () => void; /** User-assigned function to call when an AnimatedSprite changes which texture is being rendered. This function is called every time the current frame changes during playback. It receives the current frame index as an argument. animation.onFrameChange = () => { // Updated! }; / public onFrameChange?: (currentFrame: number) => void; /** User-assigned function to call when `loop` is true, and an AnimatedSprite is played and loops around to start again. animation.onLoop = () => { // Looped! }; / public onLoop?: () => void; private _playing: boolean; private _textures: Texture[]; private _durations: number[]; /** `true` uses Ticker.shared to auto update animation time. / private _autoUpdate: boolean; /** `true` if the instance is currently connected to Ticker.shared to auto update animation time. / private _isConnectedToTicker: boolean; /** Elapsed time since animation has been started, used internally to display current texture. */ private _currentTime: number; /** The texture index that was displayed last time. */ private _previousFrame: number; /** / constructor(frames: AnimatedSpriteFrames, autoUpdate?: boolean); /** / constructor(options: AnimatedSpriteOptions); constructor(...args: [AnimatedSpriteOptions?] | [AnimatedSpriteFrames?] | [AnimatedSpriteFrames?, boolean?]) { let options = args[0] as AnimatedSpriteOptions; if (Array.isArray(args[0])) { options = { textures: args[0] as AnimatedSpriteFrames, autoUpdate: args[1] as boolean, }; } const { animationSpeed = 1, autoPlay = false, autoUpdate = true, loop = true, onComplete = null, onFrameChange = null, onLoop = null, textures, updateAnchor = false, ...rest } = options; const [firstFrame] = textures; super({ ...rest, texture: firstFrame instanceof Texture ? firstFrame : firstFrame.texture, }); this._textures = null; this._durations = null; this._autoUpdate = autoUpdate; this._isConnectedToTicker = false; this.animationSpeed = animationSpeed; this.loop = loop; this.updateAnchor = updateAnchor; this.onComplete = onComplete; this.onFrameChange = onFrameChange; this.onLoop = onLoop; this._currentTime = 0; this._playing = false; this._previousFrame = null; this.textures = textures; if (autoPlay) { this.play(); } } /** Stops the animation playback and freezes the current frame. Does not reset the current frame or animation progress. ```ts // Create an animated sprite const sprite = new AnimatedSprite({ textures: [ Texture.from('walk1.png'), Texture.from('walk2.png'), Texture.from('walk3.png') ], autoPlay: true }); // Stop at current frame sprite.stop(); // Stop at specific frame sprite.gotoAndStop(1); // Stops at second frame // Stop and reset sprite.stop(); sprite.currentFrame = 0; // Stop with completion check if (sprite.playing) { sprite.stop(); sprite.onComplete?.(); } ``` / public stop(): void { if (!this._playing) { return; } this._playing = false; if (this._autoUpdate && this._isConnectedToTicker) { Ticker.shared.remove(this.update, this); this._isConnectedToTicker = false; } } /** Starts or resumes the animation playback. If the animation was previously stopped, it will continue from where it left off. ```ts // Basic playback const sprite = new AnimatedSprite({ textures: [ Texture.from('walk1.png'), Texture.from('walk2.png'), ], autoPlay: false }); sprite.play(); // Play after stopping sprite.stop(); sprite.currentFrame = 0; // Reset to start sprite.play(); // Play from beginning // Play with auto-update disabled sprite.autoUpdate = false; sprite.play(); app.ticker.add(() => { sprite.update(app.ticker); // Manual updates }); ``` / public play(): void { if (this._playing) { return; } this._playing = true; if (this._autoUpdate && !this._isConnectedToTicker) { Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH); this._isConnectedToTicker = true; } } /** Stops the AnimatedSprite and sets it to a specific frame. ```ts // Create an animated sprite const sprite = new AnimatedSprite({ textures: [ Texture.from('walk1.png'), Texture.from('walk2.png'), Texture.from('walk3.png'), ] }); // Go to specific frames sprite.gotoAndStop(0);  // First frame sprite.gotoAndStop(2);  // Third frame // Jump to last frame sprite.gotoAndStop(sprite.totalFrames - 1); ``` / public gotoAndStop(frameNumber: number): void { this.stop(); this.currentFrame = frameNumber; } /** Goes to a specific frame and begins playing the AnimatedSprite from that point. Combines frame navigation and playback start in one operation. ```ts // Start from specific frame sprite.gotoAndPlay(1); // Starts playing from second frame ``` / public gotoAndPlay(frameNumber: number): void { this.currentFrame = frameNumber; this.play(); } /** Updates the object transform for rendering. This method handles animation timing, frame updates, and manages looping behavior. ```ts // Create an animated sprite with manual updates const sprite = new AnimatedSprite({ textures: [ Texture.from('frame1.png'), Texture.from('frame2.png'), Texture.from('frame3.png') ], autoUpdate: false // Disable automatic updates }); // Manual update with app ticker app.ticker.add((ticker) => { sprite.update(ticker); }); ``` / public update(ticker: Ticker): void { // If the animation isn't playing, no update is needed. if (!this._playing) { return; } // Calculate elapsed time based on ticker's deltaTime and animation speed. const deltaTime = ticker.deltaTime; const elapsed = this.animationSpeed * deltaTime; const previousFrame = this.currentFrame; // If there are specific durations set for each frame: if (this._durations !== null) { // Calculate the lag for the current frame based on the current time. let lag = this._currentTime % 1 * this._durations[this.currentFrame]; // Adjust the lag based on elapsed time. lag += elapsed / 60 * 1000; // If the lag is negative, adjust the current time and the lag. while (lag < 0) { this._currentTime--; lag += this._durations[this.currentFrame]; } const sign = Math.sign(this.animationSpeed * deltaTime); // Floor the current time to get a whole number frame. this._currentTime = Math.floor(this._currentTime); // Adjust the current time and the lag until the lag is less than the current frame's duration. while (lag >= this._durations[this.currentFrame]) { lag -= this._durations[this.currentFrame] * sign; this._currentTime += sign; } // Adjust the current time based on the lag and current frame's duration. this._currentTime += lag / this._durations[this.currentFrame]; } else { // If no specific durations set, simply adjust the current time by elapsed time. this._currentTime += elapsed; } // Handle scenarios when animation reaches the start or the end. if (this._currentTime < 0 && !this.loop) { // If the animation shouldn't loop and it reaches the start, go to the first frame. this.gotoAndStop(0); // If there's an onComplete callback, call it. if (this.onComplete) { this.onComplete(); } } else if (this._currentTime >= this._textures.length && !this.loop) { // If the animation shouldn't loop and it reaches the end, go to the last frame. this.gotoAndStop(this._textures.length - 1); // If there's an onComplete callback, call it. if (this.onComplete) { this.onComplete(); } } else if (previousFrame !== this.currentFrame) { // If the current frame is different from the last update, handle loop scenarios. if (this.loop && this.onLoop) { if ((this.animationSpeed > 0 && this.currentFrame < previousFrame) || (this.animationSpeed < 0 && this.currentFrame > previousFrame)) { // If the animation loops, and there's an onLoop callback, call it. this.onLoop(); } } // Update the texture for the current frame. this._updateTexture(); } } /** Updates the displayed texture to match the current frame index. */ private _updateTexture(): void { const currentFrame = this.currentFrame; if (this._previousFrame === currentFrame) { return; } this._previousFrame = currentFrame; this.texture = this._textures[currentFrame]; if (this.updateAnchor && this.texture.defaultAnchor) { this.anchor.copyFrom(this.texture.defaultAnchor); } if (this.onFrameChange) { this.onFrameChange(this.currentFrame); } } /** Stops the AnimatedSprite and destroys it. This method stops the animation playback, removes it from the ticker, and cleans up any resources associated with the sprite. ```ts // Destroy the sprite when done sprite.destroy(); // Or with options sprite.destroy({ children: true, texture: true, textureSource: true }); ``` / public destroy(options: DestroyOptions = false): void { const destroyTexture = typeof options === 'boolean' ? options : options?.texture; if (destroyTexture) { const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource; this._textures.forEach((texture) => { // the current texture will be destroyed by the base sprite class if (this.texture !== texture) { texture.destroy(destroyTextureSource); } }); } this._textures = []; this._durations = null; this.stop(); super.destroy(options); this.onComplete = null; this.onFrameChange = null; this.onLoop = null; } /** A short hand way of creating an AnimatedSprite from an array of frame ids. Uses texture frames from the cache to create an animation sequence. ```ts // Create from frame IDs const frameIds = [ 'walk_001.png', 'walk_002.png', 'walk_003.png' ]; const walkingAnimation = AnimatedSprite.fromFrames(frameIds); walkingAnimation.play(); ``` / public static fromFrames(frames: string[]): AnimatedSprite { const textures = []; for (let i = 0; i < frames.length; ++i) { textures.push(Texture.from(frames[i])); } return new AnimatedSprite(textures); } /** A short hand way of creating an AnimatedSprite from an array of image urls. Each image will be used as a frame in the animation. ```ts // Create from image URLs const images = [ 'assets/walk1.png', 'assets/walk2.png', 'assets/walk3.png' ]; const walkingSprite = AnimatedSprite.fromImages(images); walkingSprite.play(); ``` / public static fromImages(images: string[]): AnimatedSprite { const textures = []; for (let i = 0; i < images.length; ++i) { textures.push(Texture.from(images[i])); } return new AnimatedSprite(textures); } /** The total number of frames in the AnimatedSprite. This is the same as number of textures assigned to the AnimatedSprite. ```ts // Create an animated sprite const sprite = new AnimatedSprite({ textures: [ Texture.from('frame1.png'), Texture.from('frame2.png'), Texture.from('frame3.png') ] }); // Get total frames console.log(sprite.totalFrames); // Outputs: 3 // Use with frame navigation sprite.gotoAndStop(sprite.totalFrames - 1); // Go to last frame ``` / get totalFrames(): number { return this._textures.length; } /** The array of textures or frame objects used for the animation sequence. Can be set to either an array of Textures or an array of FrameObjects with custom timing. ```ts // Update textures at runtime sprite.textures = [ Texture.from('run1.png'), Texture.from('run2.png') ]; // Use custom frame timing sprite.textures = [ { texture: Texture.from('explosion1.png'), time: 100 }, { texture: Texture.from('explosion2.png'), time: 200 }, { texture: Texture.from('explosion3.png'), time: 300 } ]; // Use with spritesheet const sheet = await Assets.load('animations.json'); sprite.textures = sheet.animations['walk']; ``` / get textures(): AnimatedSpriteFrames { return this._textures; } set textures(value: AnimatedSpriteFrames) { if (value[0] instanceof Texture) { this._textures = value as Texture[]; this._durations = null; } else { this._textures = []; this._durations = []; for (let i = 0; i < value.length; i++) { this._textures.push((value[i] as FrameObject).texture); this._durations.push((value[i] as FrameObject).time); } } this._previousFrame = null; this.gotoAndStop(0); this._updateTexture(); } /** Gets or sets the current frame index of the animation. When setting, the value will be clamped between 0 and totalFrames - 1. ```ts // Create an animated sprite const sprite = new AnimatedSprite({ textures: [ Texture.from('walk1.png'), Texture.from('walk2.png'), Texture.from('walk3.png') ] }); // Get current frame console.log(sprite.currentFrame); // 0 // Set specific frame sprite.currentFrame = 1; // Show second frame // Use with frame callbacks sprite.onFrameChange = (frame) => { console.log(`Now showing frame: ${frame}`); }; sprite.currentFrame = 2; ``` / get currentFrame(): number { let currentFrame = Math.floor(this._currentTime) % this._textures.length; if (currentFrame < 0) { currentFrame += this._textures.length; } return currentFrame; } set currentFrame(value: number) { if (value < 0 || value > this.totalFrames - 1) { throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, ` + `expected to be between 0 and totalFrames ${this.totalFrames}.`); } const previousFrame = this.currentFrame; this._currentTime = value; if (previousFrame !== this.currentFrame) { this._updateTexture(); } } /** Indicates if the AnimatedSprite is currently playing. This is a read-only property that reflects the current playback state. ```ts // Check if animation is playing console.log('Playing:', sprite.playing); // true // Use with play control if (!sprite.playing) { sprite.play(); } ``` / get playing(): boolean { return this._playing; } /** Controls whether the animation automatically updates using the shared ticker. When enabled, the animation will update on each frame. When disabled, you must manually call update() to advance the animation. ```ts // Create sprite with auto-update disabled const sprite = new AnimatedSprite({ textures: [], autoUpdate: false }); // Manual update with app ticker app.ticker.add((ticker) => { sprite.update(ticker); }); // Enable auto-update later sprite.autoUpdate = true; ``` / get autoUpdate(): boolean { return this._autoUpdate; } set autoUpdate(value: boolean) { if (value !== this._autoUpdate) { this._autoUpdate = value; if (!this._autoUpdate && this._isConnectedToTicker) { Ticker.shared.remove(this.update, this); this._isConnectedToTicker = false; } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) { Ticker.shared.add(this.update, this); this._isConnectedToTicker = true; } } } } /** A reference to a frame in an {@link AnimatedSprite}",
  "category": "scene",
  "deprecated": false,
  "properties": [
    {
      "name": "texture",
      "type": "Texture",
      "optional": false,
      "description": "The {@link Texture} of the frame."
    },
    {
      "name": "time",
      "type": "number",
      "optional": false,
      "description": "The duration of the frame, in milliseconds."
    }
  ]
}