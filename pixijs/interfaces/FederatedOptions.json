{
  "type": "interface",
  "name": "FederatedOptions",
  "sourcePath": "events/FederatedEventTarget.ts",
  "extends": [],
  "description": "Checks if the given coordinates are inside this hit area. / contains(x: number, y: number): boolean; } /** Function type for handlers, e.g., onclick / export type FederatedEventHandler<T = FederatedPointerEvent> = (event: T) => void; /** The type of interaction behavior for a Container. This is set via the {@link Container#eventMode} property. ```ts // Basic event mode setup const sprite = new Sprite(texture); sprite.eventMode = 'static';    // Enable standard interaction sprite.on('pointerdown', () => { console.log('clicked!'); }); // Different event modes sprite.eventMode = 'none';      // Disable all interaction sprite.eventMode = 'passive';   // Only allow interaction on children sprite.eventMode = 'auto';      // Like DOM pointer-events: auto sprite.eventMode = 'dynamic';   // For moving/animated objects ``` Available modes: - `'none'`: Ignores all interaction events, even on its children - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive children. Interactive children will still emit events. - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7 - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7 - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to allow for interaction when the mouse isn't moving Performance tips: - Use `'none'` for pure visual elements - Use `'passive'` for containers with some interactive children - Use `'static'` for standard buttons/controls - Use `'dynamic'` only for moving/animated interactive elements / export type EventMode = 'none' | 'passive' | 'auto' | 'static' | 'dynamic'; /** The properties available for any interactive object. This interface defines the core interaction properties and event handlers that can be set on any Container in PixiJS. ```ts // Basic interactive setup const sprite = new Sprite(texture); sprite.eventMode = 'static'; sprite.cursor = 'pointer'; // Using event handlers sprite.on('click', (event) => console.log('Sprite clicked!', event)); sprite.on('pointerdown', (event) => console.log('Pointer down!', event)); // Using property-based event handlers sprite.onclick = (event) => console.log('Clicked!'); sprite.onpointerenter = () => sprite.alpha = 0.7; sprite.onpointerleave = () => sprite.alpha = 1.0; // Custom hit area sprite.hitArea = new Rectangle(0, 0, 100, 100); ``` Core Properties: - `eventMode`: Controls how the object handles interaction events - `cursor`: Sets the mouse cursor when hovering - `hitArea`: Defines custom hit testing area - `interactive`: Alias for `eventMode` to enable interaction with \"static\" or \"passive\" modes - `interactiveChildren`: Controls hit testing on children Event Handlers: - Mouse: click, mousedown, mouseup, mousemove, mouseenter, mouseleave - Touch: touchstart, touchend, touchmove, tap - Pointer: pointerdown, pointerup, pointermove, pointerover - Global: globalpointermove, globalmousemove, globaltouchmove > [!IMPORTANT] Global events are fired when the pointer moves even if it is outside the bounds of the Container.",
  "category": "events",
  "deprecated": false,
  "properties": [
    {
      "name": "cursor",
      "type": "Cursor | (string & {})",
      "optional": true,
      "description": "The cursor style to display when the mouse pointer is hovering over the object. Accepts any valid CSS cursor value or custom cursor URL. ```ts // Common cursor types sprite.cursor = 'pointer';     // Hand cursor for clickable elements sprite.cursor = 'grab';        // Grab cursor for draggable elements sprite.cursor = 'crosshair';   // Precise cursor for selection sprite.cursor = 'not-allowed'; // Indicate disabled state // Direction cursors sprite.cursor = 'n-resize';    // North resize sprite.cursor = 'ew-resize';   // East-west resize sprite.cursor = 'nesw-resize'; // Northeast-southwest resize // Custom cursor with fallback sprite.cursor = 'url(\"custom.png\"), auto'; sprite.cursor = 'url(\"cursor.cur\") 2 2, pointer'; // With hotspot offset ```"
    },
    {
      "name": "eventMode",
      "type": "EventMode",
      "optional": true,
      "description": "Enable interaction events for the Container. Touch, pointer and mouse events are supported. ```ts const sprite = new Sprite(texture); // Enable standard interaction (like buttons) sprite.eventMode = 'static'; sprite.on('pointerdown', () => console.log('clicked!')); // Enable for moving objects sprite.eventMode = 'dynamic'; sprite.on('pointermove', () => updatePosition()); // Disable all interaction sprite.eventMode = 'none'; // Only allow child interactions sprite.eventMode = 'passive'; ``` Available modes: - `'none'`: Ignores all interaction events, even on its children. Best for pure visuals. - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive children. Interactive children will still emit events. - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7. - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7. Best for buttons/UI. - `'dynamic'`: Like static but also receives synthetic events when pointer is idle. Best for moving objects. Performance tips: - Use `'none'` for pure visual elements - Use `'passive'` for containers with some interactive children - Use `'static'` for standard UI elements - Use `'dynamic'` only when needed for moving/animated elements"
    },
    {
      "name": "interactive",
      "type": "boolean\n    /**\n     * Controls whether children of this container can receive pointer events.\n     *\n     * Setting this to false allows PixiJS to skip hit testing on all children,\n     * improving performance for containers with many non-interactive children.\n     * @default true\n     * @example\n     * ```ts\n     * // Container with many visual-only children\n     * const container = new Container()",
      "optional": true,
      "description": "Whether this object should fire UI events. This is an alias for `eventMode` set to `'static'` or `'passive'`. Setting this to true will enable interaction events like `pointerdown`, `click`, etc. Setting it to false will disable all interaction events on this object. ```ts // Enable interaction events sprite.interactive = true;  // Sets eventMode = 'static' sprite.interactive = false; // Sets eventMode = 'passive' ```"
    },
    {
      "name": "interactiveChildren",
      "type": "boolean",
      "optional": true,
      "description": null
    },
    {
      "name": "hitArea",
      "type": "IHitArea | null",
      "optional": true,
      "description": "Defines a custom hit area for pointer interaction testing. When set, this shape will be used for hit testing instead of the container's standard bounds. ```ts import { Rectangle, Circle, Sprite } from 'pixi.js'; // Rectangular hit area const button = new Sprite(texture); button.eventMode = 'static'; button.hitArea = new Rectangle(0, 0, 100, 50); // Circular hit area const icon = new Sprite(texture); icon.eventMode = 'static'; icon.hitArea = new Circle(32, 32, 32); // Custom hit area with polygon const custom = new Sprite(texture); custom.eventMode = 'static'; custom.hitArea = new Polygon([0,0, 100,0, 100,100, 0,100]); // Custom hit testing logic sprite.hitArea = { contains(x: number, y: number) { // Custom collision detection return x >= 0 && x <= width && y >= 0 && y <= height; } }; ``` - Takes precedence over the container's bounds for hit testing - Can improve performance by simplifying collision checks - Useful for irregular shapes or precise click areas"
    },
    {
      "name": "onclick",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `click` event. Fired when a pointer device (mouse, touch, etc.) completes a click action. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('click', (event) => { console.log('Sprite clicked at:', event.global.x, event.global.y); }); // Using property-based handler sprite.onclick = (event) => { console.log('Clicked at:', event.global.x, event.global.y); }; ```"
    },
    {
      "name": "onmousedown",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `mousedown` event. Fired when a mouse button is pressed while the pointer is over the object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('mousedown', (event) => { sprite.alpha = 0.5; // Visual feedback console.log('Mouse button:', event.button); }); // Using property-based handler sprite.onmousedown = (event) => { sprite.alpha = 0.5; // Visual feedback console.log('Mouse button:', event.button); }; ```"
    },
    {
      "name": "onmouseenter",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `mouseenter` event. Fired when the mouse pointer enters the bounds of the object. Does not bubble. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('mouseenter', (event) => { sprite.scale.set(1.1); }); // Using property-based handler sprite.onmouseenter = (event) => { sprite.scale.set(1.1); }; ```"
    },
    {
      "name": "onmouseleave",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `mouseleave` event. Fired when the pointer leaves the bounds of the display object. Does not bubble. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('mouseleave', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.onmouseleave = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "onmousemove",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `mousemove` event. Fired when the pointer moves while over the display object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('mousemove', (event) => { // Get coordinates relative to the sprite console.log('Local:', event.getLocalPosition(sprite)); }); // Using property-based handler sprite.onmousemove = (event) => { // Get coordinates relative to the sprite console.log('Local:', event.getLocalPosition(sprite)); }; ```"
    },
    {
      "name": "onglobalmousemove",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `globalmousemove` event. Fired when the mouse moves anywhere, regardless of whether the pointer is over this object. The object must have `eventMode` set to 'static' or 'dynamic' to receive this event. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('globalmousemove', (event) => { // Move sprite to mouse position sprite.position.copyFrom(event.global); }); // Using property-based handler sprite.onglobalmousemove = (event) => { // Move sprite to mouse position sprite.position.copyFrom(event.global); }; ``` - Fires even when the mouse is outside the object's bounds - Useful for drag operations or global mouse tracking - Must have `eventMode` set appropriately to receive events - Part of the global move events family along with `globalpointermove` and `globaltouchmove`"
    },
    {
      "name": "onmouseout",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `mouseout` event. Fired when the pointer moves out of the bounds of the display object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('mouseout', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.onmouseout = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "onmouseover",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `mouseover` event. Fired when the pointer moves onto the bounds of the display object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('mouseover', (event) => { sprite.scale.set(1.1); }); // Using property-based handler sprite.onmouseover = (event) => { sprite.scale.set(1.1); }; ```"
    },
    {
      "name": "onmouseup",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `mouseup` event. Fired when a mouse button is released over the display object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('mouseup', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.onmouseup = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "onmouseupoutside",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `mouseupoutside` event. Fired when a mouse button is released outside the display object that initially registered a mousedown. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('mouseupoutside', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.onmouseupoutside = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "onpointercancel",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `pointercancel` event. Fired when a pointer device interaction is canceled or lost. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('pointercancel', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.onpointercancel = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "onpointerdown",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `pointerdown` event. Fired when a pointer device button (mouse, touch, pen, etc.) is pressed. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('pointerdown', (event) => { sprite.position.set(event.global.x, event.global.y); }); // Using property-based handler sprite.onpointerdown = (event) => { sprite.position.set(event.global.x, event.global.y); }; ```"
    },
    {
      "name": "onpointerenter",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `pointerenter` event. Fired when a pointer device enters the bounds of the display object. Does not bubble. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('pointerenter', (event) => { sprite.scale.set(1.2); }); // Using property-based handler sprite.onpointerenter = (event) => { sprite.scale.set(1.2); }; ```"
    },
    {
      "name": "onpointerleave",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `pointerleave` event. Fired when a pointer device leaves the bounds of the display object. Does not bubble. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('pointerleave', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.onpointerleave = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "onpointermove",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `pointermove` event. Fired when a pointer device moves while over the display object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('pointermove', (event) => { sprite.position.set(event.global.x, event.global.y); }); // Using property-based handler sprite.onpointermove = (event) => { sprite.position.set(event.global.x, event.global.y); }; ```"
    },
    {
      "name": "onglobalpointermove",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `globalpointermove` event. Fired when the pointer moves anywhere, regardless of whether the pointer is over this object. The object must have `eventMode` set to 'static' or 'dynamic' to receive this event. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('globalpointermove', (event) => { sprite.position.set(event.global.x, event.global.y); }); // Using property-based handler sprite.onglobalpointermove = (event) => { sprite.position.set(event.global.x, event.global.y); }; ``` - Fires even when the mouse is outside the object's bounds - Useful for drag operations or global mouse tracking - Must have `eventMode` set appropriately to receive events - Part of the global move events family along with `globalpointermove` and `globaltouchmove`"
    },
    {
      "name": "onpointerout",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `pointerout` event. Fired when the pointer moves out of the bounds of the display object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('pointerout', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.onpointerout = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "onpointerover",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `pointerover` event. Fired when the pointer moves over the bounds of the display object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('pointerover', (event) => { sprite.scale.set(1.2); }); // Using property-based handler sprite.onpointerover = (event) => { sprite.scale.set(1.2); }; ```"
    },
    {
      "name": "onpointertap",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `pointertap` event. Fired when a pointer device completes a tap action (e.g., touch or mouse click). ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('pointertap', (event) => { console.log('Sprite tapped at:', event.global.x, event.global.y); }); // Using property-based handler sprite.onpointertap = (event) => { console.log('Sprite tapped at:', event.global.x, event.global.y); }; ```"
    },
    {
      "name": "onpointerup",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `pointerup` event. Fired when a pointer device button (mouse, touch, pen, etc.) is released. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('pointerup', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.onpointerup = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "onpointerupoutside",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `pointerupoutside` event. Fired when a pointer device button is released outside the bounds of the display object that initially registered a pointerdown. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('pointerupoutside', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.onpointerupoutside = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "onrightclick",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `rightclick` event. Fired when a right-click (context menu) action is performed on the object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('rightclick', (event) => { console.log('Right-clicked at:', event.global.x, event.global.y); }); // Using property-based handler sprite.onrightclick = (event) => { console.log('Right-clicked at:', event.global.x, event.global.y); }; ```"
    },
    {
      "name": "onrightdown",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `rightdown` event. Fired when a right mouse button is pressed down over the display object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('rightdown', (event) => { sprite.scale.set(0.9); }); // Using property-based handler sprite.onrightdown = (event) => { sprite.scale.set(0.9); }; ```"
    },
    {
      "name": "onrightup",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `rightup` event. Fired when a right mouse button is released over the display object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('rightup', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.onrightup = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "onrightupoutside",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `rightupoutside` event. Fired when a right mouse button is released outside the bounds of the display object that initially registered a rightdown. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('rightupoutside', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.onrightupoutside = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "ontap",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `tap` event. Fired when a tap action (touch) is completed on the object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('tap', (event) => { console.log('Sprite tapped at:', event.global.x, event.global.y); }); // Using property-based handler sprite.ontap = (event) => { console.log('Sprite tapped at:', event.global.x, event.global.y); }; ```"
    },
    {
      "name": "ontouchcancel",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `touchcancel` event. Fired when a touch interaction is canceled, such as when the touch is interrupted. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('touchcancel', (event) => { console.log('Touch canceled at:', event.global.x, event.global.y); }); // Using property-based handler sprite.ontouchcancel = (event) => { console.log('Touch canceled at:', event.global.x, event.global.y); }; ```"
    },
    {
      "name": "ontouchend",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `touchend` event. Fired when a touch interaction ends, such as when the finger is lifted from the screen. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('touchend', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.ontouchend = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "ontouchendoutside",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `touchendoutside` event. Fired when a touch interaction ends outside the bounds of the display object that initially registered a touchstart. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('touchendoutside', (event) => { sprite.scale.set(1.0); }); // Using property-based handler sprite.ontouchendoutside = (event) => { sprite.scale.set(1.0); }; ```"
    },
    {
      "name": "ontouchmove",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `touchmove` event. Fired when a touch interaction moves while over the display object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('touchmove', (event) => { sprite.position.set(event.global.x, event.global.y); }); // Using property-based handler sprite.ontouchmove = (event) => { sprite.position.set(event.global.x, event.global.y); }; ```"
    },
    {
      "name": "onglobaltouchmove",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `globaltouchmove` event. Fired when a touch interaction moves anywhere, regardless of whether the pointer is over this object. The object must have `eventMode` set to 'static' or 'dynamic' to receive this event. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('globaltouchmove', (event) => { sprite.position.set(event.global.x, event.global.y); }); // Using property-based handler sprite.onglobaltouchmove = (event) => { sprite.position.set(event.global.x, event.global.y); }; ``` - Fires even when the touch is outside the object's bounds - Useful for drag operations or global touch tracking - Must have `eventMode` set appropriately to receive events - Part of the global move events family along with `globalpointermove` and `globalmousemove`"
    },
    {
      "name": "ontouchstart",
      "type": "FederatedEventHandler | null",
      "optional": true,
      "description": "Property-based event handler for the `touchstart` event. Fired when a touch interaction starts, such as when a finger touches the screen. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('touchstart', (event) => { sprite.scale.set(0.9); }); // Using property-based handler sprite.ontouchstart = (event) => { sprite.scale.set(0.9); }; ```"
    },
    {
      "name": "onwheel",
      "type": "FederatedEventHandler<FederatedWheelEvent> | null",
      "optional": true,
      "description": "Property-based event handler for the `wheel` event. Fired when the mouse wheel is scrolled while over the display object. ```ts const sprite = new Sprite(texture); sprite.eventMode = 'static'; // Using emitter handler sprite.on('wheel', (event) => { sprite.scale.x += event.deltaY * 0.01; // Zoom in/out sprite.scale.y += event.deltaY * 0.01; // Zoom in/out }); // Using property-based handler sprite.onwheel = (event) => { sprite.scale.x += event.deltaY * 0.01; // Zoom in/out sprite.scale.y += event.deltaY * 0.01; // Zoom in/out }; ```"
    },
    {
      "name": "_internalEventMode",
      "type": "EventMode",
      "optional": false,
      "description": "The options for the `addEventListener` method. / export type AddListenerOptions = boolean | AddEventListenerOptions; /** The options for the `removeEventListener` method. / export type RemoveListenerOptions = boolean | EventListenerOptions; /** Additional properties for a Container that is used for interaction events. / export interface IFederatedContainer extends FederatedOptions { /** The parent of this event target. */ readonly parent?: Container | null; /** The children of this event target. */ readonly children?: ReadonlyArray<Container>; /** @private"
    },
    {
      "name": "isInteractive",
      "type": "() => boolean",
      "optional": false,
      "description": "Determines if the container is interactive or not import { Sprite } from 'pixi.js'; const sprite = new Sprite(texture); sprite.eventMode = 'static'; sprite.isInteractive(); // true sprite.eventMode = 'dynamic'; sprite.isInteractive(); // true sprite.eventMode = 'none'; sprite.isInteractive(); // false sprite.eventMode = 'passive'; sprite.isInteractive(); // false sprite.eventMode = 'auto'; sprite.isInteractive(); // false"
    },
    {
      "name": "1",
      "type": "prefix = 'single'",
      "optional": false,
      "description": null
    },
    {
      "name": "2",
      "type": "prefix = 'double'",
      "optional": false,
      "description": null
    },
    {
      "name": "3",
      "type": "prefix = 'triple'",
      "optional": false,
      "description": null
    },
    {
      "name": "default",
      "type": "prefix = e.detail + 'th'",
      "optional": false,
      "description": null
    },
    {
      "name": "capture",
      "type": "true,\n     * })",
      "optional": false,
      "description": null
    },
    {
      "name": "type",
      "type": "K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: AddListenerOptions\n    ): void",
      "optional": false,
      "description": null
    },
    {
      "name": "type",
      "type": "string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    ): void",
      "optional": false,
      "description": null
    },
    {
      "name": "type",
      "type": "K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: RemoveListenerOptions\n    ): void",
      "optional": false,
      "description": null
    },
    {
      "name": "type",
      "type": "string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    ): void",
      "optional": false,
      "description": null
    },
    {
      "name": "e",
      "type": "FederatedEvent): boolean",
      "optional": false,
      "description": null
    },
    {
      "name": "FederatedContainer",
      "type": "IFederatedContainer = {\n    onclick: null,\n    onmousedown: null,\n    onmouseenter: null,\n    onmouseleave: null,\n    onmousemove: null,\n    onglobalmousemove: null,\n    onmouseout: null,\n    onmouseover:  null,\n    onmouseup:  null,\n    onmouseupoutside: null,\n    onpointercancel: null,\n    onpointerdown:  null,\n    onpointerenter: null,\n    onpointerleave:  null,\n    onpointermove:  null,\n    onglobalpointermove:  null,\n    onpointerout:  null,\n    onpointerover:  null,\n    onpointertap:  null,\n    onpointerup:  null,\n    onpointerupoutside:  null,\n    onrightclick:  null,\n    onrightdown:  null,\n    onrightup:  null,\n    onrightupoutside:  null,\n    ontap:  null,\n    ontouchcancel:  null,\n    ontouchend:  null,\n    ontouchendoutside:  null,\n    ontouchmove:  null,\n    onglobaltouchmove:  null,\n    ontouchstart:  null,\n    onwheel:  null,\n    get interactive()\n    {\n        return this.eventMode === 'dynamic' || this.eventMode === 'static'",
      "optional": false,
      "description": null
    },
    {
      "name": "value",
      "type": "boolean)\n    {\n        this.eventMode = value ? 'static' : 'passive'",
      "optional": false,
      "description": null
    },
    {
      "name": "_internalEventMode",
      "type": "undefined,\n    get eventMode()\n    {\n        return this._internalEventMode ?? EventSystem.defaultEventMode",
      "optional": false,
      "description": null
    },
    {
      "name": "interactiveChildren",
      "type": "true,\n    hitArea: null,\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n        || (typeof options === 'object' && options.capture)",
      "optional": false,
      "description": null
    },
    {
      "name": "type",
      "type": "string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n            || (typeof options === 'object' && options.capture)",
      "optional": false,
      "description": null
    },
    {
      "name": "e",
      "type": "Event): boolean\n    {\n        if (!(e instanceof FederatedEvent))\n        {\n            throw new Error('Container cannot propagate events outside of the Federated Events API')",
      "optional": false,
      "description": null
    }
  ]
}